import { CoreProvider, CoreError, CoreErrorCode, assertUnreachable, maybe, dateInputToDate, BigNumber, Module, toCamelCase } from '@moralisweb3/common-core';
import { isAddress, getAddress } from '@ethersproject/address';
import { joinSignature, splitSignature, hexlify } from '@ethersproject/bytes';

/******************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
/* global Reflect, Promise */

var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
    return extendStatics(d, b);
};

function __extends(d, b) {
    if (typeof b !== "function" && b !== null)
        throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
    extendStatics(d, b);
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
}

var __assign = function() {
    __assign = Object.assign || function __assign(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};

var CommonEvmUtilsConfig = {
    formatEvmChainId: {
        name: 'formatEvmChainId',
        defaultValue: 'hex',
    },
    formatEvmAddress: {
        name: 'formatEvmAddress',
        defaultValue: 'lowercase',
    },
    defaultEvmApiChain: {
        name: 'defaultEvmApiChain',
        defaultValue: '0x1',
    },
};

/**
 * A representation of an address on the EVM network.
 *
 * Use this class any time you work with an address, as it will provide utilities to validate the address,
 * and format it to lowercase and checksum format.
 *
 * @category DataType
 */
var EvmAddress = /** @class */ (function () {
    function EvmAddress(address, config) {
        this.config = config;
        this._value = EvmAddress.parse(address);
    }
    Object.defineProperty(EvmAddress, "ZERO_ADDRESS", {
        /**
         * @returns EvmAddress instance of the zero address: "0x0000000000000000000000000000000000000000"
         * @example `EvmAddress.ZERO_ADDRESS`
         */
        get: function () {
            return EvmAddress.create('0x0000000000000000000000000000000000000000');
        },
        enumerable: false,
        configurable: true
    });
    /**
     * Create a new instance of EvmAddress from any valid address input
     *
     * @example
     * ```
     * const address = EvmAddress.create("0xfb6916095ca1df60bb79ce92ce3ea74c37c5d359")
     * const address = EvmAddress.create("0xfB6916095ca1df60bB79Ce92cE3Ea74c37c5d359")
     * const address = EvmAddress.ZERO_ADDRESS
     * ```
     */
    EvmAddress.create = function (address, core) {
        if (address instanceof EvmAddress) {
            return address;
        }
        var finalCore = core || CoreProvider.getDefault();
        return new EvmAddress(address, finalCore.config);
    };
    EvmAddress.parse = function (address) {
        if (!isAddress(address)) {
            throw new CoreError({
                code: CoreErrorCode.INVALID_ARGUMENT,
                message: 'Invalid address provided',
            });
        }
        return getAddress(address);
    };
    /**
     * Check the equality between two Evm addresses
     * @example `EvmAddress.equals("0xfB6916095ca1df60bB79Ce92cE3Ea74c37c5d359", "0xfb6916095ca1df60bb79ce92ce3ea74c37c5d359")`
     */
    EvmAddress.equals = function (addressA, addressB) {
        return EvmAddress.create(addressA)._value === EvmAddress.create(addressB)._value;
    };
    /**
     * Checks the equality of the current address with another evm address
     * @example `address.equals("0xfb6916095ca1df60bb79ce92ce3ea74c37c5d359")`
     */
    EvmAddress.prototype.equals = function (address) {
        return EvmAddress.equals(this, address);
    };
    /**
     * Formats the address to a specific format.
     * If no formatStyle is provided as argument, it will use the `formatEvmAddress` set in the config.
     * @example `address.format() // "0xfB6916095ca1df60bB79Ce92cE3Ea74c37c5d359"`
     */
    EvmAddress.prototype.format = function (style) {
        var formatStyle = style !== null && style !== void 0 ? style : this.config.get(CommonEvmUtilsConfig.formatEvmAddress);
        if (formatStyle === 'checksum') {
            return this.checksum;
        }
        if (formatStyle === 'lowercase') {
            return this.lowercase;
        }
        throw new CoreError({
            code: CoreErrorCode.INVALID_ARGUMENT,
            message: 'Cannot format address, invalid config.formatAddress',
        });
    };
    Object.defineProperty(EvmAddress.prototype, "checksum", {
        /**
         * @returns the address value in checksum (EIP-55) format (see https://eips.ethereum.org/EIPS/eip-55)
         * @example `address.checksum // "0xfB6916095ca1df60bB79Ce92cE3Ea74c37c5d359"`
         */
        get: function () {
            return this._value;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(EvmAddress.prototype, "lowercase", {
        /**
         * @returns the address value in lowercase format
         * @example `address.lowercase // "0xfb6916095ca1df60bb79ce92ce3ea74c37c5d359"`
         */
        get: function () {
            return this._value.toLowerCase();
        },
        enumerable: false,
        configurable: true
    });
    return EvmAddress;
}());

// source: https://chainid.network/chains.json
var chainList = [
    {
        name: 'Ethereum Mainnet',
        chain: 'ETH',
        icon: 'ethereum',
        rpc: [
            'https://mainnet.infura.io/v3/${INFURA_API_KEY}',
            'wss://mainnet.infura.io/ws/v3/${INFURA_API_KEY}',
            'https://api.mycryptoapi.com/eth',
            'https://cloudflare-eth.com',
        ],
        features: [
            {
                name: 'EIP155',
            },
            {
                name: 'EIP1559',
            },
        ],
        faucets: [],
        nativeCurrency: {
            name: 'Ether',
            symbol: 'ETH',
            decimals: 18,
        },
        infoURL: 'https://ethereum.org',
        shortName: 'eth',
        chainId: 1,
        networkId: 1,
        slip44: 60,
        ens: {
            registry: '0x00000000000C2E074eC69A0dFb2997BA6C7d2e1e',
        },
        explorers: [
            {
                name: 'etherscan',
                url: 'https://etherscan.io',
                standard: 'EIP3091',
            },
        ],
    },
    {
        name: 'Goerli',
        title: 'Ethereum Testnet Goerli',
        chain: 'ETH',
        rpc: [
            'https://goerli.infura.io/v3/${INFURA_API_KEY}',
            'wss://goerli.infura.io/v3/${INFURA_API_KEY}',
            'https://rpc.goerli.mudit.blog/',
        ],
        faucets: [
            'http://fauceth.komputing.org?chain=5&address=${ADDRESS}',
            'https://goerli-faucet.slock.it?address=${ADDRESS}',
            'https://faucet.goerli.mudit.blog',
        ],
        nativeCurrency: {
            name: 'Goerli Ether',
            symbol: 'ETH',
            decimals: 18,
        },
        infoURL: 'https://goerli.net/#about',
        shortName: 'gor',
        chainId: 5,
        networkId: 5,
        ens: {
            registry: '0x112234455c3a32fd11230c42e7bccd4a84e02010',
        },
        explorers: [
            {
                name: 'etherscan-goerli',
                url: 'https://goerli.etherscan.io',
                standard: 'EIP3091',
            },
        ],
    },
    {
        name: 'Cronos Mainnet Beta',
        chain: 'CRO',
        rpc: ['https://evm.cronos.org'],
        features: [
            {
                name: 'EIP1559',
            },
        ],
        faucets: [],
        nativeCurrency: {
            name: 'Cronos',
            symbol: 'CRO',
            decimals: 18,
        },
        infoURL: 'https://cronos.org/',
        shortName: 'cro',
        chainId: 25,
        networkId: 25,
        explorers: [
            {
                name: 'Cronos Explorer',
                url: 'https://cronoscan.com',
                standard: 'none',
            },
        ],
    },
    {
        name: 'Binance Smart Chain Mainnet',
        chain: 'BSC',
        rpc: [
            'https://bsc-dataseed1.binance.org',
            'https://bsc-dataseed2.binance.org',
            'https://bsc-dataseed3.binance.org',
            'https://bsc-dataseed4.binance.org',
            'https://bsc-dataseed1.defibit.io',
            'https://bsc-dataseed2.defibit.io',
            'https://bsc-dataseed3.defibit.io',
            'https://bsc-dataseed4.defibit.io',
            'https://bsc-dataseed1.ninicoin.io',
            'https://bsc-dataseed2.ninicoin.io',
            'https://bsc-dataseed3.ninicoin.io',
            'https://bsc-dataseed4.ninicoin.io',
            'wss://bsc-ws-node.nariox.org',
        ],
        faucets: ['https://free-online-app.com/faucet-for-eth-evm-chains/'],
        nativeCurrency: {
            name: 'Binance Chain Native Token',
            symbol: 'BNB',
            decimals: 18,
        },
        infoURL: 'https://www.binance.org',
        shortName: 'bnb',
        chainId: 56,
        networkId: 56,
        slip44: 714,
        explorers: [
            {
                name: 'bscscan',
                url: 'https://bscscan.com',
                standard: 'EIP3091',
            },
        ],
    },
    {
        name: 'Binance Smart Chain Testnet',
        chain: 'BSC',
        rpc: [
            'https://data-seed-prebsc-1-s1.binance.org:8545',
            'https://data-seed-prebsc-2-s1.binance.org:8545',
            'https://data-seed-prebsc-1-s2.binance.org:8545',
            'https://data-seed-prebsc-2-s2.binance.org:8545',
            'https://data-seed-prebsc-1-s3.binance.org:8545',
            'https://data-seed-prebsc-2-s3.binance.org:8545',
        ],
        faucets: ['https://testnet.binance.org/faucet-smart'],
        nativeCurrency: {
            name: 'Binance Chain Native Token',
            symbol: 'tBNB',
            decimals: 18,
        },
        infoURL: 'https://testnet.binance.org/',
        shortName: 'bnbt',
        chainId: 97,
        networkId: 97,
        explorers: [
            {
                name: 'bscscan-testnet',
                url: 'https://testnet.bscscan.com',
                standard: 'EIP3091',
            },
        ],
    },
    {
        name: 'Polygon Mainnet',
        chain: 'Polygon',
        icon: 'polygon',
        rpc: [
            'https://polygon-rpc.com/',
            'https://rpc-mainnet.matic.network',
            'https://matic-mainnet.chainstacklabs.com',
            'https://rpc-mainnet.maticvigil.com',
            'https://rpc-mainnet.matic.quiknode.pro',
            'https://matic-mainnet-full-rpc.bwarelabs.com',
            'https://polygon-bor.publicnode.com',
        ],
        faucets: [],
        nativeCurrency: {
            name: 'MATIC',
            symbol: 'MATIC',
            decimals: 18,
        },
        infoURL: 'https://polygon.technology/',
        shortName: 'matic',
        chainId: 137,
        networkId: 137,
        slip44: 966,
        explorers: [
            {
                name: 'polygonscan',
                url: 'https://polygonscan.com',
                standard: 'EIP3091',
            },
        ],
    },
    {
        name: 'Fantom Opera',
        chain: 'FTM',
        rpc: ['https://rpc.ftm.tools'],
        faucets: ['https://free-online-app.com/faucet-for-eth-evm-chains/'],
        nativeCurrency: {
            name: 'Fantom',
            symbol: 'FTM',
            decimals: 18,
        },
        infoURL: 'https://fantom.foundation',
        shortName: 'ftm',
        chainId: 250,
        networkId: 250,
        icon: 'fantom',
        explorers: [
            {
                name: 'ftmscan',
                url: 'https://ftmscan.com',
                icon: 'ftmscan',
                standard: 'EIP3091',
            },
        ],
    },
    {
        name: 'Cronos Testnet',
        chain: 'CRO',
        rpc: ['https://evm-t3.cronos.org'],
        faucets: ['https://cronos.org/faucet'],
        nativeCurrency: {
            name: 'Cronos Test Coin',
            symbol: 'TCRO',
            decimals: 18,
        },
        infoURL: 'https://cronos.org',
        shortName: 'tcro',
        chainId: 338,
        networkId: 338,
        explorers: [
            {
                name: 'Cronos Testnet Explorer',
                url: 'https://testnet.cronoscan.com',
                standard: 'none',
            },
        ],
    },
    {
        name: 'Arbitrum One',
        chainId: 42161,
        shortName: 'arb1',
        chain: 'ETH',
        networkId: 42161,
        nativeCurrency: {
            name: 'Ether',
            symbol: 'ETH',
            decimals: 18,
        },
        rpc: [
            'https://arbitrum-mainnet.infura.io/v3/${INFURA_API_KEY}',
            'https://arb-mainnet.g.alchemy.com/v2/${ALCHEMY_API_KEY}',
            'https://arb1.arbitrum.io/rpc',
        ],
        faucets: [],
        explorers: [
            {
                name: 'Arbiscan',
                url: 'https://arbiscan.io',
                standard: 'EIP3091',
            },
            {
                name: 'Arbitrum Explorer',
                url: 'https://explorer.arbitrum.io',
                standard: 'EIP3091',
            },
        ],
        infoURL: 'https://arbitrum.io',
        parent: {
            type: 'L2',
            chain: 'eip155-1',
            bridges: [
                {
                    url: 'https://bridge.arbitrum.io',
                },
            ],
        },
    },
    {
        name: 'Avalanche Fuji Testnet',
        chain: 'AVAX',
        icon: 'avax',
        rpc: ['https://api.avax-test.network/ext/bc/C/rpc'],
        faucets: ['https://faucet.avax-test.network/'],
        nativeCurrency: {
            name: 'Avalanche',
            symbol: 'AVAX',
            decimals: 18,
        },
        infoURL: 'https://cchain.explorer.avax-test.network',
        shortName: 'Fuji',
        chainId: 43113,
        networkId: 1,
        explorers: [
            {
                name: 'snowtrace',
                url: 'https://testnet.snowtrace.io',
                standard: 'EIP3091',
            },
        ],
    },
    {
        name: 'Avalanche C-Chain',
        chain: 'AVAX',
        icon: 'avax',
        rpc: ['https://api.avax.network/ext/bc/C/rpc'],
        features: [
            {
                name: 'EIP1559',
            },
        ],
        faucets: ['https://free-online-app.com/faucet-for-eth-evm-chains/'],
        nativeCurrency: {
            name: 'Avalanche',
            symbol: 'AVAX',
            decimals: 18,
        },
        infoURL: 'https://www.avax.network/',
        shortName: 'avax',
        chainId: 43114,
        networkId: 43114,
        slip44: 9005,
        explorers: [
            {
                name: 'snowtrace',
                url: 'https://snowtrace.io',
                standard: 'EIP3091',
            },
        ],
    },
    {
        name: 'Mumbai',
        title: 'Polygon Testnet Mumbai',
        chain: 'Polygon',
        icon: 'polygon',
        rpc: [
            'https://matic-mumbai.chainstacklabs.com',
            'https://rpc-mumbai.maticvigil.com',
            'https://matic-testnet-archive-rpc.bwarelabs.com',
        ],
        faucets: ['https://faucet.polygon.technology/'],
        nativeCurrency: {
            name: 'MATIC',
            symbol: 'MATIC',
            decimals: 18,
        },
        infoURL: 'https://polygon.technology/',
        shortName: 'maticmum',
        chainId: 80001,
        networkId: 80001,
        explorers: [
            {
                name: 'polygonscan',
                url: 'https://mumbai.polygonscan.com',
                standard: 'EIP3091',
            },
        ],
    },
    {
        name: 'Sepolia',
        title: 'Ethereum Testnet Sepolia',
        chain: 'ETH',
        rpc: ['https://rpc.sepolia.org', 'https://rpc-sepolia.rockx.com'],
        faucets: ['http://fauceth.komputing.org?chain=11155111&address=${ADDRESS}'],
        nativeCurrency: {
            name: 'Sepolia Ether',
            symbol: 'ETH',
            decimals: 18,
        },
        infoURL: 'https://sepolia.otterscan.io',
        shortName: 'sep',
        chainId: 11155111,
        networkId: 11155111,
        explorers: [
            {
                name: 'etherscan-sepolia',
                url: 'https://sepolia.etherscan.io',
                standard: 'EIP3091',
            },
            {
                name: 'otterscan-sepolia',
                url: 'https://sepolia.otterscan.io',
                standard: 'EIP3091',
            },
        ],
    },
    {
        name: 'Palm',
        chain: 'Palm',
        rpc: ['https://palm-mainnet.infura.io/v3/${INFURA_API_KEY}'],
        faucets: [],
        nativeCurrency: {
            name: 'PALM',
            symbol: 'PALM',
            decimals: 18,
        },
        infoURL: 'https://palm.io',
        shortName: 'palm',
        chainId: 11297108109,
        networkId: 11297108109,
        explorers: [
            {
                name: 'Palm Explorer',
                url: 'https://explorer.palm.io',
                standard: 'EIP3091',
            },
        ],
    },
];

var INVALID_VALUES = ['0x', '0x0', '0', 0];
var EvmChainParser = /** @class */ (function () {
    function EvmChainParser() {
    }
    EvmChainParser.parse = function (chain) {
        if (INVALID_VALUES.includes(chain)) {
            throw new CoreError({
                code: CoreErrorCode.INVALID_ARGUMENT,
                message: "Invalid provided chain, value must be a positive number, or a hex-string starting with '0x'",
            });
        }
        if (typeof chain === 'string') {
            if (chain.startsWith('0x')) {
                return chain;
            }
            try {
                var parsed = parseInt(chain, 10);
                if (Number.isNaN(parsed)) {
                    throw new Error('Cannot parse the provided string value to a valid chain number');
                }
                return "0x".concat(parsed.toString(16));
            }
            catch (error) {
                throw new CoreError({
                    code: CoreErrorCode.INVALID_ARGUMENT,
                    message: "Invalid provided chain, value must be a positive number, or a hex-string starting with '0x'",
                });
            }
        }
        if (chain <= 0) {
            throw new CoreError({
                code: CoreErrorCode.INVALID_ARGUMENT,
                message: "Invalid provided chain, value must be a positive number, or a hex-string starting with '0x'",
            });
        }
        return "0x".concat(chain.toString(16));
    };
    return EvmChainParser;
}());

/**
 * The EvmChain class is a MoralisData that references to a EVM chain
 * @category DataType
 */
var EvmChain = /** @class */ (function () {
    function EvmChain(value, config) {
        var _this = this;
        var _a;
        this.config = config;
        this._value = EvmChainParser.parse(value);
        this._chainlistData = (_a = chainList.find(function (chainData) { return chainData.chainId === _this.decimal; })) !== null && _a !== void 0 ? _a : null;
    }
    Object.defineProperty(EvmChain, "ETHEREUM", {
        /**
         * Returns ETHEREUM chain
         *
         * @example EvmChain.ETHEREUM
         */
        get: function () {
            return EvmChain.create(1);
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(EvmChain, "GOERLI", {
        /**
         * Returns GOERLI chain
         *
         * @example EvmChain.GOERLI
         */
        get: function () {
            return EvmChain.create(5);
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(EvmChain, "SEPOLIA", {
        /**
         * Returns SEPOLIA chain
         *
         * @example EvmChain.SEPOLIA
         */
        get: function () {
            return EvmChain.create(11155111);
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(EvmChain, "POLYGON", {
        /**
         * Returns POLYGON chain
         *
         * @example EvmChain.POLYGON
         */
        get: function () {
            return EvmChain.create(137);
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(EvmChain, "MUMBAI", {
        /**
         * Returns MUMBAI chain
         *
         * @example EvmChain.MUMBAI
         */
        get: function () {
            return EvmChain.create(80001);
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(EvmChain, "BSC", {
        /**
         * Returns BSC chain
         *
         * @example EvmChain.BSC
         */
        get: function () {
            return EvmChain.create(56);
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(EvmChain, "BSC_TESTNET", {
        /**
         * Returns BSC_TESTNET chain
         *
         * @example EvmChain.BSC_TESTNET
         */
        get: function () {
            return EvmChain.create(97);
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(EvmChain, "AVALANCHE", {
        /**
         * Returns AVALANCHE chain
         *
         * @example EvmChain.AVALANCHE
         */
        get: function () {
            return EvmChain.create(43114);
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(EvmChain, "FUJI", {
        /**
         * Returns FUJI chain
         *
         * @example EvmChain.FUJI
         */
        get: function () {
            return EvmChain.create(43113);
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(EvmChain, "FANTOM", {
        /**
         * Returns FANTOM chain
         *
         * @example EvmChain.FANTOM
         */
        get: function () {
            return EvmChain.create(250);
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(EvmChain, "CRONOS", {
        /**
         * Returns CRONOS chain
         *
         * @example EvmChain.CRONOS
         */
        get: function () {
            return EvmChain.create(25);
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(EvmChain, "CRONOS_TESTNET", {
        /**
         * Returns CRONOS_TESTNET chain
         *
         * @example EvmChain.CRONOS_TESTNET
         */
        get: function () {
            return EvmChain.create(338);
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(EvmChain, "PALM", {
        /**
         * Returns PALM chain
         *
         * @example EvmChain.PALM
         */
        get: function () {
            return EvmChain.create(11297108109);
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(EvmChain, "ARBITRUM", {
        /**
         * Returns ARBITRUM chain
         *
         * @example EvmChain.ARBITRUM
         */
        get: function () {
            return EvmChain.create(42161);
        },
        enumerable: false,
        configurable: true
    });
    /**
     * Create a new instance of EvmChain from any valid address input.
     *
     * @example
     * ```ts
     * const chain = EvmChain.create(1)
     * const chain = EvmChain.create("0x3")
     * ```
     */
    EvmChain.create = function (chain, core) {
        if (chain instanceof EvmChain) {
            return chain;
        }
        var c = core || CoreProvider.getDefault();
        return new EvmChain(chain, c.config);
    };
    // Getter to return _chainlistData and throws an error if it is not defined
    EvmChain.prototype._getChainlistData = function () {
        if (!this._chainlistData) {
            return null;
        }
        return this._chainlistData;
    };
    /**
     * Compares if 2 chains are equal, based on the chainId
     *
     * @param chainA - The first chain to compare
     * @param chainB - The second chain to compare
     *
     * @returns true if the chains are equal, false otherwise
     * @example
     * ```ts
     * EvmChain.equals("1", "0x1")
     * ```
     */
    EvmChain.equals = function (chainA, chainB) {
        return EvmChain.create(chainA)._value === EvmChain.create(chainB)._value;
    };
    /**
     * Compares if the current chain is equal to the provided chain, based on the chainId
     * @param chain - The chain to compare to
     * @returns true if the chains are equal, false otherwise
     * @example
     * ```ts
     * chain.equals(EvmChain.ETHEREUM)
     * ```
     */
    EvmChain.prototype.equals = function (chain) {
        return EvmChain.equals(this, chain);
    };
    /**
     * Formats the chain to the given output; in decimal value or as hex-string.
     * The default formatting can be set in MoralisConfig
     * @param _formatStyle - The output format to use
     * @example chain.format() // 1
     * @example chain.format('hex') // "0x1"
     * @example chain.format('decimal') // 1
     *
     * @returns The formatted chain
     */
    EvmChain.prototype.format = function (_formatStyle) {
        var formatStyle = _formatStyle !== null && _formatStyle !== void 0 ? _formatStyle : this.config.get(CommonEvmUtilsConfig.formatEvmChainId);
        if (formatStyle === 'decimal') {
            return this.decimal;
        }
        if (formatStyle === 'hex') {
            return this.hex;
        }
        return assertUnreachable(formatStyle);
    };
    /**
     * Displays the chain hex-string representation of the chain and also the chain name if not null
     *
     * @example chain.display() // "Ethereum (0x1)" | "0x1"
     */
    EvmChain.prototype.display = function () {
        return this.name ? "".concat(this.name, " (").concat(this.hex, ")") : this.hex;
    };
    /**
     * This function returns the explorer url of a block, transaction, account or token.
     *
     * @param value - An object containing the `block`, `transaction`, `account` or `erc20` to get the explorer url for.
     *
     * @example chain.getExplorerUrl({ block: 'block_here' }) // "https://etherscan.io/block/block_here"
     * @example chain.getExplorerUrl({ transaction: 'some_transaction' }) // "https://etherscan.io/tx/some_transaction"
     * @example chain.getExplorerUrl({ account: 'accoun_here' }) // "https://etherscan.io/address/accoun_here"
     * @example chain.getExplorerUrl({ erc20: 'token_here' }) // "https://etherscan.io/token/token_here"
     */
    EvmChain.prototype.getExplorerPath = function (value) {
        var explorer = this.explorer;
        if (!explorer || explorer.standard !== 'EIP3091') {
            return null;
        }
        var url = explorer.url;
        // See https://eips.ethereum.org/EIPS/eip-3091 for paths
        if ('block' in value) {
            return "".concat(url, "/block/").concat(value.block);
        }
        if ('transaction' in value) {
            return "".concat(url, "/tx/").concat(value.transaction);
        }
        if ('account' in value) {
            return "".concat(url, "/address/").concat(value.account);
        }
        if ('erc20' in value) {
            return "".concat(url, "/token/").concat(value.erc20);
        }
        return null;
    };
    Object.defineProperty(EvmChain.prototype, "decimal", {
        /**
         * Returns the decimal representation of the chain
         * @example chain.decimal // 1
         */
        get: function () {
            return parseInt(this._value, 16);
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(EvmChain.prototype, "hex", {
        /**
         * Returns the hex-string representation of the chain
         * @example chain.hex // "0x1"
         */
        get: function () {
            return this._value;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(EvmChain.prototype, "apiHex", {
        /**
         * Validate and cast to api compatible hex
         *
         * @example chain.apiHex // "0x1"
         */
        get: function () {
            return this._value;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(EvmChain.prototype, "name", {
        /**
         * Returns the name of the chain
         * @example chain.name // "Ethereum"
         */
        get: function () {
            var _a;
            return (_a = this._getChainlistData()) === null || _a === void 0 ? void 0 : _a.name;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(EvmChain.prototype, "currency", {
        /**
         * Returns the currency of the chain
         * @returns The cuurrency of the chain or undefined if not found
         *
         * @example chain.currency // EvmNativeCurrency
         */
        get: function () {
            var _a;
            return (_a = this._getChainlistData()) === null || _a === void 0 ? void 0 : _a.nativeCurrency;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(EvmChain.prototype, "rpcUrls", {
        /**
         * Returns the rpc Urls of the chain
         *
         * @example chain.rpcUrls // ["https://mainnet.infura.io/v3/<infura-key>"]
         */
        get: function () {
            var _a;
            return (_a = this._getChainlistData()) === null || _a === void 0 ? void 0 : _a.rpc;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(EvmChain.prototype, "explorer", {
        /**
         * Returns the explorer Urls of the chain
         *
         * @example chain.explorerUrls // ["https://etherscan.io/"]
         */
        get: function () {
            var _a;
            var explorers = (_a = this._getChainlistData()) === null || _a === void 0 ? void 0 : _a.explorers;
            if (!explorers || explorers.length === 0) {
                return null;
            }
            return explorers[0];
        },
        enumerable: false,
        configurable: true
    });
    return EvmChain;
}());

/**
 * The Erc20Token class is a MoralisData that references to a Erc20 Token
 * It holds data about the data and metadata of an Erc20 token
 *
 * @category DataType
 */
var Erc20Token = /** @class */ (function () {
    function Erc20Token(value, core) {
        this._value = Erc20Token.parse(value, core);
    }
    /**
     *  Create a new instance of Erc20Token from any valid Erc20Token input
     *
     * @param value - the Erc20Tokenish type
     * @param core - The MoralisCore instance
     * @example
     * ```ts
     * const token = Erc20Token.create(value);
     * ```
     */
    Erc20Token.create = function (value, core) {
        if (value instanceof Erc20Token) {
            return value;
        }
        var finalCore = core !== null && core !== void 0 ? core : CoreProvider.getDefault();
        return new Erc20Token(value, finalCore);
    };
    /**
     * Compares two Erc20Token instances. This checks if the chain and contractAddress of both tokens are equal.
     *
     * @param valueA - the first Erc20Token to compare
     * @param valueB - the second Erc20Token to compare
     * @returns true if the two Erc20Tokens are equal
     * @example
     * ```ts
     * Erc20Token.equals(valueA, valueB);
     * ```
     */
    Erc20Token.equals = function (valueA, valueB) {
        var erc20A = Erc20Token.create(valueA);
        var erc20B = Erc20Token.create(valueB);
        if (!erc20A._value.chain.equals(erc20B._value.chain)) {
            return false;
        }
        if (!erc20A._value.contractAddress.equals(erc20B._value.contractAddress)) {
            return false;
        }
        return true;
    };
    /**
     * Compares Erc20Token instance to current instance
     *
     * @param value - the Erc20Tokenish to compare
     * @returns true if the Erc20Token is equals given token
     * @example
     * ```ts
     * token.equals(value);
     * ```
     */
    Erc20Token.prototype.equals = function (value) {
        return Erc20Token.equals(this, value);
    };
    /**
     * Returns the token as JSON
     *
     * @returns the Erc20Token as a JSON object
     * @example
     * ```ts
     * token.toJSON();
     * ```
     */
    Erc20Token.prototype.toJSON = function () {
        var value = this._value;
        return __assign(__assign({}, value), { contractAddress: value.contractAddress.format(), chain: value.chain.format() });
    };
    /**
     * Returns the token as JSON
     *
     * @returns the Erc20Token as a JSON object
     * @example
     * ```ts
     * token.format();
     * ```
     */
    Erc20Token.prototype.format = function () {
        return this.toJSON();
    };
    Object.defineProperty(Erc20Token.prototype, "result", {
        /**
         * Returns the processed Erc20Token.
         *
         * @returns the Erc20Token value
         * @example
         * ```ts
         * token.result;
         *  ```
         */
        get: function () {
            return this._value;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Erc20Token.prototype, "decimals", {
        /**
         * @returns the decimals of the token.
         *
         * @example
         * ```ts
         * token.decimals;
         * ```
         */
        get: function () {
            return this._value.decimals;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Erc20Token.prototype, "name", {
        /**
         * @returns The name of the token.
         *
         * @example
         * ```ts
         * token.name;
         * ```
         */
        get: function () {
            return this._value.name;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Erc20Token.prototype, "symbol", {
        /**
         * @returns The symbol of the token.
         *
         * @example
         * ```ts
         * token.symbol;
         * ```
         */
        get: function () {
            return this._value.symbol;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Erc20Token.prototype, "contractAddress", {
        /**
         * @returns The contract address of the token.
         *
         * @example
         * ```ts
         * token.contractAddress;
         * ```
         */
        get: function () {
            return this._value.contractAddress;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Erc20Token.prototype, "chain", {
        /**
         * @returns The chain of the token.
         *
         * @example
         * ```ts
         * token.chain;
         * ```
         */
        get: function () {
            return this._value.chain;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Erc20Token.prototype, "logo", {
        /**
         * @returns The logo of the token.
         *
         * @example
         * ```ts
         * token.logo;
         * ```
         */
        get: function () {
            return this._value.logo;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Erc20Token.prototype, "logoHash", {
        /**
         * @returns The logo hash of the token.
         *
         * @example
         * ```ts
         * token.logoHash;
         * ```
         */
        get: function () {
            return this._value.logoHash;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Erc20Token.prototype, "thumbnail", {
        /**
         * @returns The thumbnail of the token.
         *
         * @example
         * ```ts
         * token.thumbnail;
         * ```
         */
        get: function () {
            return this._value.thumbnail;
        },
        enumerable: false,
        configurable: true
    });
    Erc20Token.parse = function (value, core) { return ({
        decimals: +value.decimals,
        name: value.name,
        symbol: value.symbol,
        contractAddress: EvmAddress.create(value.contractAddress, core),
        logo: maybe(value.logo),
        logoHash: maybe(value.logoHash),
        thumbnail: maybe(value.thumbnail),
        chain: EvmChain.create(value.chain, core),
    }); };
    return Erc20Token;
}());

/**
 * The Erc20Transfer is a representation of an Erc20 token transfer.
 *
 * @category DataType
 */
var Erc20Transfer = /** @class */ (function () {
    function Erc20Transfer(data) {
        this._data = Erc20Transfer.parse(data);
    }
    /**
     * Create a new instance of Erc20Transfer from any valid input
     * @param data - the Erc20Transferish type
     * @example
     * ```
     * const transfer = Erc20Transfer.create(data);
     *```
     */
    Erc20Transfer.create = function (data) {
        if (data instanceof Erc20Transfer) {
            return data;
        }
        return new Erc20Transfer(data);
    };
    /**
     * Check the equality between two Erc20 transfers
     * @param dataA - The first transfer to compare
     * @param dataB - The second transfer to compare
     * @example Erc20Transfer.equals(dataA, dataB)
     * @returns true if the transfers are equal, false otherwise
     */
    Erc20Transfer.equals = function (dataA, dataB) {
        var tokenA = Erc20Transfer.create(dataA);
        var tokenB = Erc20Transfer.create(dataB);
        return JSON.stringify(tokenA.toJSON()) === JSON.stringify(tokenB.toJSON());
    };
    /**
     * Checks the equality of the current trnasfer with another erc20 trnasfer
     * @param data - the transfer to compare with
     * @example transfer.equals(data)
     * @returns true if the transfers are equal, false otherwise
     */
    Erc20Transfer.prototype.equals = function (data) {
        return Erc20Transfer.equals(this, data);
    };
    /**
     * @returns a JSON represention of the transfer.
     * @example transfer.toJSON()
     */
    Erc20Transfer.prototype.toJSON = function () {
        var data = this._data;
        return __assign(__assign({}, data), { chain: data.chain.format(), address: data.address.format(), blockNumber: data.blockNumber.toString(), toAddress: data.toAddress.format(), fromAddress: data.fromAddress.format(), value: data.value.toString() });
    };
    /**
     * @returns a JSON represention of the transfer.
     * @example transfer.format()
     */
    Erc20Transfer.prototype.format = function () {
        return this.toJSON();
    };
    Object.defineProperty(Erc20Transfer.prototype, "result", {
        /**
         * @returns all the data without casting it to JSON.
         * @example transfer.result
         */
        get: function () {
            return this._data;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Erc20Transfer.prototype, "address", {
        /**
         * @returns the address of the tranfer
         * @example transfer.address // EvmAddress
         */
        get: function () {
            return this._data.address;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Erc20Transfer.prototype, "blockHash", {
        /**
         * @returns the block hash of the tranfer
         * @example transfer.blockHash // "0x0372c302e3c52e8f2e15d155e2c545e6d802e479236564af052759253b20fd86"
         */
        get: function () {
            return this._data.blockHash;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Erc20Transfer.prototype, "blockNumber", {
        /**
         * @returns the block number of the tranfer
         * @example transfer.blockNumber // BigNumber
         */
        get: function () {
            return this._data.blockNumber;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Erc20Transfer.prototype, "blockTimestamp", {
        /**
         * @returns the block timestamp of the tranfer
         * @example transfer.blockTimestamp // Date
         */
        get: function () {
            return this._data.blockTimestamp;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Erc20Transfer.prototype, "chain", {
        /**
         * @returns the chain of the tranfer
         * @example transfer.chain // EvmChain
         */
        get: function () {
            return this._data.chain;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Erc20Transfer.prototype, "fromAddress", {
        /**
         * @returns the from address of the tranfer
         * @example transfer.fromAddress // EvmAddress
         */
        get: function () {
            return this._data.fromAddress;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Erc20Transfer.prototype, "toAddress", {
        /**
         * @returns the to address of the tranfer
         * @example transfer.toAddress // EvmAddress
         */
        get: function () {
            return this._data.toAddress;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Erc20Transfer.prototype, "transactionHash", {
        /**
         * @returns the transaction hash of the tranfer
         * @example transfer.transactionHash // "0x0372c302e3c52e8f2e15d155e2c545e6d802e479236564af052759253b20fd86"
         */
        get: function () {
            return this._data.transactionHash;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Erc20Transfer.prototype, "value", {
        /**
         * @returns the value of the tranfer
         * @example transfer.value // BigNumber
         */
        get: function () {
            return this._data.value;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Erc20Transfer.prototype, "transactionIndex", {
        /**
         * @returns the transactionIndex of the tranfer
         * @example transfer.transactionIndex // 3
         */
        get: function () {
            return this._data.transactionIndex;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Erc20Transfer.prototype, "logIndex", {
        /**
         * @returns the logIndex of the tranfer
         * @example transfer.logIndex // 2
         */
        get: function () {
            return this._data.logIndex;
        },
        enumerable: false,
        configurable: true
    });
    Erc20Transfer.parse = function (data) { return (__assign(__assign({}, data), { chain: EvmChain.create(data.chain), address: EvmAddress.create(data.address), blockTimestamp: dateInputToDate(data.blockTimestamp), blockNumber: BigNumber.create(data.blockNumber), toAddress: EvmAddress.create(data.toAddress), fromAddress: EvmAddress.create(data.fromAddress), value: BigNumber.create(data.value) })); };
    return Erc20Transfer;
}());

var EVM_ERC20_DEFAULT_DECIMALS = 18;
/**
 * The Erc20Value class is a MoralisData that references to a the value of an Erc20Token
 * It holds data about the data about the amount of tokens and the number of decimals.
 *
 * @category DataType
 */
var Erc20Value = /** @class */ (function () {
    function Erc20Value(amount, options, core) {
        var _this = this;
        var _a, _b, _c;
        /**
         * Displays the token in text format
         * @returns the value and also the token symbol if available
         * @example value.display();
         */
        this.display = function () {
            if (!_this._token) {
                return "".concat(_this.value);
            }
            return "".concat(_this.value, " ").concat(_this._token.symbol);
        };
        this._value = Erc20Value.parse({
            amount: amount,
            decimals: (_c = (_a = options === null || options === void 0 ? void 0 : options.decimals) !== null && _a !== void 0 ? _a : (_b = options === null || options === void 0 ? void 0 : options.token) === null || _b === void 0 ? void 0 : _b.decimals) !== null && _c !== void 0 ? _c : EVM_ERC20_DEFAULT_DECIMALS,
            token: options === null || options === void 0 ? void 0 : options.token,
        });
        if (options === null || options === void 0 ? void 0 : options.token) {
            this._token = Erc20Token.create(options.token, core);
        }
    }
    /**
     * Create a new instance of Erc20Value from any valid input
     * @param value - The value to create
     * @param options - The options for the token
     * @param core - The MoralisCore instance
     * @example Erc20Value.create(1000, { decimals: 3 });
     * @returns The created value
     * @throws CoreError if the value is invalid
     */
    Erc20Value.create = function (value, options, core) {
        if (value instanceof Erc20Value) {
            return value;
        }
        return new Erc20Value(value, options, core);
    };
    /**
     * Compares two Erc20Valueish instances.
     * @param valueA - The first value to compare
     * @param valueB - The second value to compare
     * @returns True if the values are equal
     * @example
     * ```ts
     * const valueA = Erc20Value.create(1000, { decimals: 3 });
     * const valueB = Erc20Value.create(10000, { decimals: 4 });
     * Erc20Value.equals(valueA, valueB); // true
     * ```
     */
    Erc20Value.equals = function (valueA, valueB) {
        var erc20ValueA = Erc20Value.create(valueA);
        var erc20ValueB = Erc20Value.create(valueB);
        return erc20ValueA.value === erc20ValueB.value;
    };
    /**
     * Compares Erc20Value with current instance.
     * @param value - The value to compare
     * @returns True if the values are equal
     * @example value.equals(valueA);
     */
    Erc20Value.prototype.equals = function (value) {
        return Erc20Value.equals(this, value);
    };
    /**
     * Convert the value to a number
     * @returns the value in number format
     * @example value.toNumber();
     */
    Erc20Value.prototype.toNumber = function () {
        return +this.value;
    };
    /**
     * Convert the value to a string
     * @returns the value in string format
     * @example value.toString();
     */
    Erc20Value.prototype.toString = function () {
        return this.value;
    };
    /**
     * Convert the value to a string
     * @returns the value in string format
     * @example value.format();
     */
    Erc20Value.prototype.format = function () {
        return this.toString();
    };
    /**
     * Displays the token in JSON format
     * @returns the value and also the token if available
     * @example value.toJSON();
     */
    Erc20Value.prototype.toJSON = function () {
        if (this.token) {
            return { value: this.value, token: this.token.toJSON() };
        }
        return { value: this.value };
    };
    Object.defineProperty(Erc20Value.prototype, "decimals", {
        /**
         * @returns the token decimals
         * @example value.decimals; // 15
         */
        get: function () {
            return this._value.decimals;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Erc20Value.prototype, "amount", {
        /**
         * @returns the token amount
         * @example value.amount; // BigNumber
         */
        get: function () {
            return this._value.amount;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Erc20Value.prototype, "value", {
        /**
         * @returns the token value
         * @example value.value; // "1000"
         */
        get: function () {
            return this._value.amount.toDecimal(this.decimals);
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Erc20Value.prototype, "token", {
        /**
         * @returns the token
         * @example value.token; // Erc20Token
         */
        get: function () {
            var _a;
            return (_a = this._token) !== null && _a !== void 0 ? _a : null;
        },
        enumerable: false,
        configurable: true
    });
    Erc20Value.parse = function (_a) {
        var amount = _a.amount, decimals = _a.decimals, token = _a.token;
        if (token && token.decimals && +token.decimals !== +decimals) {
            throw new CoreError({
                code: CoreErrorCode.INVALID_DATA,
                message: 'Decimals do not match',
            });
        }
        return {
            amount: BigNumber.create(amount),
            decimals: +decimals,
        };
    };
    return Erc20Value;
}());

var unitToDecimals = {
    ether: 18,
    finney: 15,
    szabo: 12,
    gwei: 9,
    mwei: 6,
    kwei: 3,
    wei: 0,
};
/**
 * The EvmNative class is a MoralisData that references to the value of an EVM native currency (like ETH, BNB etc.)
 *
 * @category DataType
 */
var EvmNative = /** @class */ (function () {
    function EvmNative(native, unit) {
        if (unit === void 0) { unit = 'ether'; }
        this.rawValue = EvmNative.parse(native, unit);
    }
    Object.defineProperty(EvmNative, "ONE_ETH", {
        /**
         * Returns value of one ether.
         *
         * @example EvmNative.ONE_ETH
         */
        get: function () {
            return EvmNative.create(1, 'ether');
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(EvmNative, "ONE_GWEI", {
        /**
         * Returns value of one gwei.
         *
         * @example EvmNative.ONE_GWEI
         */
        get: function () {
            return EvmNative.create(1, 'gwei');
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(EvmNative, "ONE_WEI", {
        /**
         * Returns value of one wei.
         *
         * @example EvmNative.ONE_WEI
         */
        get: function () {
            return EvmNative.create(1, 'wei');
        },
        enumerable: false,
        configurable: true
    });
    /**
     * Create a new instance of EvmNative from any valid {@link EvmNativeish} value.
     * @param native - the value to create the EvmNative from
     * @param unit - the unit of the value (optional), defaults to `ether`
     * @returns a new instance of EvmNative
     * @example
     * ```ts
     * const native = EvmNative.create(2, 'gwei');
     * const native = EvmNative.create(2);
     * const native = EvmNative.create(2, 'wei');
     *```
     */
    EvmNative.create = function (native, unit) {
        if (native instanceof EvmNative) {
            return native;
        }
        return new EvmNative(native, unit);
    };
    EvmNative.parse = function (native, unit) {
        var decimals;
        if (typeof unit === 'number') {
            decimals = unit;
        }
        else {
            if (unitToDecimals[unit] == null) {
                throw new CoreError({
                    code: CoreErrorCode.INVALID_ARGUMENT,
                    message: 'Unit should be a decimal number or valid EvmNativeUnit string',
                });
            }
            decimals = unitToDecimals[unit];
        }
        return BigNumber.fromDecimal(native.toString(), decimals);
    };
    /**
     * Compares two EvmNative values.
     * @param valueA - the first value to compare
     * @param valueB - the second value to compare
     * @returns true if the values are equal
     * @example
     * ```ts
     * EvmNative.equals(EvmNative.create(1, 'ether'), EvmNative.create(1, 'ether')); // true
     * ```
     */
    EvmNative.equals = function (valueA, valueB) {
        var evmNativeA = EvmNative.create(valueA);
        var evmNativeB = EvmNative.create(valueB);
        return evmNativeA.rawValue.equals(evmNativeB.rawValue);
    };
    /**
     * Compares EvmNative with current instance.
     * @param value - the value to compare with
     * @returns true if the values are equal
     * @example
     * ```ts
     * const native = EvmNative.create(1, 'gwei');
     * native.equals(EvmNative.create(1, 'ether')); // false
     * ```
     */
    EvmNative.prototype.equals = function (value) {
        return EvmNative.equals(this, value);
    };
    /**
     * Converts the EvmNative to a string.
     * @returns the value of the EvmNative as a string
     * @example `native.toString()`
     */
    EvmNative.prototype.toString = function () {
        return this.wei;
    };
    /**
     * Converts the EvmNative to a string.
     * @returns the value of the EvmNative as a string
     * @example `native.format()`
     */
    EvmNative.prototype.format = function () {
        return this.toString();
    };
    Object.defineProperty(EvmNative.prototype, "value", {
        /**
         * @returns the value of the EvmNative as a BigNumber
         * @example `native.value`
         */
        get: function () {
            return this.rawValue;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(EvmNative.prototype, "wei", {
        /**
         * Converts the EvmNative to a string representation of the value in wei.
         * @returns the value of the EvmNative as a string
         * @example `native.wei`
         */
        get: function () {
            return this.value.toString();
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(EvmNative.prototype, "gwei", {
        /**
         * Converts the EvmNative to a string representation of the value in gwei.
         * @returns the value of the EvmNative as a string
         * @example `native.gwei`
         */
        get: function () {
            return this.rawValue.toDecimal(unitToDecimals['gwei']);
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(EvmNative.prototype, "ether", {
        /**
         * Converts the EvmNative to a string representation of the value in ether.
         * @returns the value of the EvmNative as a string
         * @example `native.ether`
         */
        get: function () {
            return this.rawValue.toDecimal(unitToDecimals['ether']);
        },
        enumerable: false,
        configurable: true
    });
    return EvmNative;
}());

/**
 * The EvmTransactionLog class is a MoralisData that references an EVM transaction log.
 *
 * @category DataType
 */
var EvmTransactionLog = /** @class */ (function () {
    function EvmTransactionLog(value, core) {
        this._value = EvmTransactionLog.parse(value, core);
    }
    /**
     * Create a new instance of EvmTransactionLog from any valid address input
     *
     * @example
     * ```
     * const log = EvmTransactionLog.create(value, core);
     * ```
     * @param value - A valid EvmTransactionLogish
     * @param core - The Core instance
     */
    EvmTransactionLog.create = function (value, core) {
        if (value instanceof EvmTransactionLog) {
            return value;
        }
        var finalCore = core !== null && core !== void 0 ? core : CoreProvider.getDefault();
        return new EvmTransactionLog(value, finalCore);
    };
    EvmTransactionLog.parse = function (value, core) {
        return {
            chain: EvmChain.create(value.chain, core),
            logIndex: maybe(value.logIndex, function (index) { return +index; }),
            transactionHash: value.transactionHash,
            transactionIndex: maybe(value.transactionIndex),
            data: value.data,
            topics: value.topics,
            blockHash: value.blockHash,
            blockNumber: value.blockNumber,
            blockTimestamp: value.blockTimestamp,
            address: EvmAddress.create(value.address, core),
        };
    };
    /**
     * Compares the log to another log for equality.
     *
     * @param value - The value to compare with
     * @returns true if the logs are equal, otherwise false
     * @example
     * ```ts
     * log.equals(log);
     * ```
     */
    EvmTransactionLog.prototype.equals = function (value) {
        return (value._value.transactionHash === this._value.transactionHash &&
            value._value.address.equals(this._value.address) &&
            value._value.logIndex === this._value.logIndex &&
            value._value.chain.equals(this._value.chain));
    };
    /**
     * Converts the log to a JSON object.
     *
     * @returns the EvmTransactionLog as a JSON object
     * @example
     * ```ts
     * log.toJSON();
     * ```
     */
    EvmTransactionLog.prototype.toJSON = function () {
        var value = this._value;
        return __assign(__assign({}, value), { address: value.address.format(), chain: value.chain.format() });
    };
    /**
     * Converts the log to a JSON object.
     *
     * @returns the EvmTransactionLog as a JSON object
     * @example
     * ```ts
     * log.format();
     * ```
     */
    EvmTransactionLog.prototype.format = function () {
        return this.toJSON();
    };
    Object.defineProperty(EvmTransactionLog.prototype, "result", {
        /**
         * Returns the processed Erc20Token.
         *
         * @returns the EvmTransactionLog value
         * @example
         * ```ts
         * log.result;
         *  ```
         */
        get: function () {
            return this._value;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(EvmTransactionLog.prototype, "transactionHash", {
        /**
         * @returns the transaction hash of the log.
         *
         * @example
         * ```ts
         * log.transactionHash; // "0xdd9006489e46670e0e85d1fb88823099e7f596b08aeaac023e9da0851f26fdd5"
         * ```
         */
        get: function () {
            return this._value.transactionHash;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(EvmTransactionLog.prototype, "address", {
        /**
         * Returns the address of the log.
         *
         * @example
         * ```ts
         * log.address; // EvmAddress
         * ```
         */
        get: function () {
            return this._value.address;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(EvmTransactionLog.prototype, "chain", {
        /**
         * Returns the chain of the log.
         *
         * @example
         * ```ts
         * log.chain; // EvmChain
         * ```
         */
        get: function () {
            return this._value.chain;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(EvmTransactionLog.prototype, "logIndex", {
        /**
         * @returns the log index of the log.
         *
         * @example
         * ```ts
         * log.logIndex; // 273
         * ```
         */
        get: function () {
            return this._value.logIndex;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(EvmTransactionLog.prototype, "data", {
        /**
         * @returns the data of the log.
         *
         * @example
         * ```ts
         * log.data; // "0x00000000000000000000000000000000000000000000000de05239bccd4d537400000000000000000000000000024dbc80a9f80e3d5fc0a0ee30e2693781a443"
         * ```
         */
        get: function () {
            return this._value.data;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(EvmTransactionLog.prototype, "topics", {
        /**
         * @returns the topics of the log.
         *
         * @example
         * ```ts
         * log.topic0; // ["0x0000000000000000000000000000000000000000000000000000000000000001", "0x0000000000000000000000000000000000000000000000000000000000000002"]
         * ```
         */
        get: function () {
            return this._value.topics;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(EvmTransactionLog.prototype, "blockHash", {
        /**
         * @returns the block hash of the log.
         *
         * @example
         * ```ts
         * log.blockHash; // "0x9b559aef7ea858608c2e554246fe4a24287e7aeeb976848df2b9a2531f4b9171"
         * ```
         */
        get: function () {
            return this._value.blockHash;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(EvmTransactionLog.prototype, "blockNumber", {
        /**
         * @returns the block number of the log.
         *
         * @example
         * ```ts
         * log.blockNumber; // 12386788
         * ```
         */
        get: function () {
            return this._value.blockNumber;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(EvmTransactionLog.prototype, "blockTimestamp", {
        /**
         * @returns the block timestamp of the log.
         *
         * @example
         * ```ts
         * log.blockTimestamp; // "2021-05-07T11:08:35.000Z"
         * ```
         */
        get: function () {
            return this._value.blockTimestamp;
        },
        enumerable: false,
        configurable: true
    });
    return EvmTransactionLog;
}());

/**
 * Represents of a signed EVM signature
 * Can be created with a valid r,s,v signature or a hex string
 */
var EvmSignature = /** @class */ (function () {
    function EvmSignature(data) {
        this._data = EvmSignature.parse(data);
    }
    EvmSignature.create = function (data) {
        if (data instanceof EvmSignature) {
            return data;
        }
        return new EvmSignature(data);
    };
    EvmSignature.equals = function (dataA, dataB) {
        var signatureA = EvmSignature.create(dataA);
        var signatureB = EvmSignature.create(dataB);
        return signatureA.serialized === signatureB.serialized;
    };
    /**
     * Checks the equality of the current transfer instance with another nft transfer
     * @param data - the transfer to compare with
     * @example transaction.equals(data)
     * @returns true if the transfers are equal, false otherwise
     */
    EvmSignature.prototype.equals = function (data) {
        return EvmSignature.equals(this, data);
    };
    Object.defineProperty(EvmSignature.prototype, "r", {
        get: function () {
            return this._data.r;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(EvmSignature.prototype, "s", {
        get: function () {
            return this._data.s;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(EvmSignature.prototype, "v", {
        get: function () {
            return this._data.v;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(EvmSignature.prototype, "serialized", {
        get: function () {
            return joinSignature(this._data);
        },
        enumerable: false,
        configurable: true
    });
    EvmSignature.prototype.toJSON = function () {
        return {
            r: this.r,
            s: this.s,
            v: this.v.toString(),
        };
    };
    EvmSignature.prototype.format = function () {
        return this.serialized;
    };
    EvmSignature.parse = function (data) {
        if (typeof data === 'string') {
            return splitSignature(data);
        }
        return splitSignature({
            r: hexlify(BigNumber.create(data.r).toBigInt()),
            s: hexlify(BigNumber.create(data.s).toBigInt()),
            v: +data.v,
        });
    };
    return EvmSignature;
}());

/**
 * The EvmTranaction is a representation of a published transaction.
 *
 * Use this class any time you work with a transaction.
 *
 * @category DataType
 */
var EvmTransaction = /** @class */ (function () {
    function EvmTransaction(data, core) {
        this._data = EvmTransaction.parse(data, core);
    }
    /**
     * Create a new instance of EvmTransaction from any valid transaction input
     * @param data - the EvmTransactionish type
     * @example
     * ```
     * const transaction = EvmTransaction.create(data);
     *```
     */
    EvmTransaction.create = function (data, core) {
        if (data instanceof EvmTransaction) {
            return data;
        }
        var finalCore = core !== null && core !== void 0 ? core : CoreProvider.getDefault();
        return new EvmTransaction(data, finalCore);
    };
    /**
     * Check the equality between two Evm transactions
     * @param dataA - The first transaction
     * @param dataB - The second transaction
     * @example
     * ```ts
     * EvmTransaction.equals(dataA, dataB)
     * ```
     */
    EvmTransaction.equals = function (dataA, dataB) {
        var transactionA = EvmTransaction.create(dataA);
        var transactionB = EvmTransaction.create(dataB);
        if (!transactionA._data.chain.equals(transactionB._data.chain)) {
            return false;
        }
        if (transactionA._data.hash !== transactionB._data.hash) {
            return false;
        }
        return true;
    };
    /**
     * Checks the equality of the current transaction with another evm transaction
     * @param data - the transaction to compare with
     * @example
     * ```ts
     * transaction.equals(data)
     * ```
     */
    EvmTransaction.prototype.equals = function (data) {
        return EvmTransaction.equals(this, data);
    };
    EvmTransaction.prototype.toJSON = function () {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m;
        var data = this._data;
        return __assign(__assign({}, data), { to: (_a = data.to) === null || _a === void 0 ? void 0 : _a.format(), from: (_b = data.from) === null || _b === void 0 ? void 0 : _b.format(), nonce: (_c = data.nonce) === null || _c === void 0 ? void 0 : _c.toString(), gas: (_d = data.gas) === null || _d === void 0 ? void 0 : _d.toString(), gasPrice: (_e = data.gasPrice) === null || _e === void 0 ? void 0 : _e.toString(), gasUsed: (_f = data.gasUsed) === null || _f === void 0 ? void 0 : _f.toString(), cumulativeGasUsed: (_g = data.cumulativeGasUsed) === null || _g === void 0 ? void 0 : _g.toString(), value: (_h = data.value) === null || _h === void 0 ? void 0 : _h.toString(), chain: (_j = data.chain) === null || _j === void 0 ? void 0 : _j.format(), contractAddress: (_k = data.contractAddress) === null || _k === void 0 ? void 0 : _k.format(), logs: data.logs.map(function (log) { return log.toJSON(); }), signature: (_l = data.signature) === null || _l === void 0 ? void 0 : _l.toJSON(), blockNumber: (_m = data.blockNumber) === null || _m === void 0 ? void 0 : _m.toString(), blockTimestamp: data.blockTimestamp.toString() });
    };
    /**
     * @returns a JSON represention of the transaction.
     * @example
     * ```
     * transaction.format()
     * ```
     */
    EvmTransaction.prototype.format = function () {
        return this.toJSON();
    };
    Object.defineProperty(EvmTransaction.prototype, "result", {
        /**
         * @returns the transaction
         * @example
         * ```
         * transaction.result
         * ```
         */
        get: function () {
            return this._data;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(EvmTransaction.prototype, "to", {
        /**
         * @returns the transaction to address
         * @example
         * ```
         * transaction.to // EvmAddress
         * ```
         */
        get: function () {
            return this._data.to;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(EvmTransaction.prototype, "from", {
        /**
         * @returns the transaction from address
         * @example
         * ```
         * transaction.address // EvmAddress
         * ```
         */
        get: function () {
            return this._data.from;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(EvmTransaction.prototype, "nonce", {
        /**
         * @returns the transaction nonce
         * @example
         * ```
         * transaction.nonce // 326595425
         * ```
         */
        get: function () {
            return this._data.nonce;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(EvmTransaction.prototype, "gas", {
        /**
         * @returns the transaction gas
         * @example
         * ```
         * transaction.gas // 6721975
         * ```
         */
        get: function () {
            return this._data.gas;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(EvmTransaction.prototype, "gasPrice", {
        /**
         * @returns the transaction gas price
         * @example
         * ```
         * transaction.gasPrice // 20000000000
         * ```
         */
        get: function () {
            return this._data.gasPrice;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(EvmTransaction.prototype, "gasUsed", {
        /**
         * @returns the transaction gas used
         * @example
         * ```
         * transaction.gasUsed // 1340925
         * ```
         */
        get: function () {
            return this._data.gasUsed;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(EvmTransaction.prototype, "cumulativeGasUsed", {
        /**
         * @returns the transaction cumulative gas used
         * @example
         * ```
         * transaction.cumulativeGasUsed // 1340925
         * ```
         */
        get: function () {
            return this._data.cumulativeGasUsed;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(EvmTransaction.prototype, "blockNumber", {
        /**
         * @returns the transaction block number
         * @example
         * ```
         * transaction.blockNumber // 12526958
         * ```
         */
        get: function () {
            return this._data.blockNumber;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(EvmTransaction.prototype, "value", {
        /**
         * @returns the transaction value
         * @example
         * ```
         * transaction.value // EvmNative
         * ```
         */
        get: function () {
            return this._data.value;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(EvmTransaction.prototype, "chain", {
        /**
         * @returns the transaction chain
         * @example
         * ```
         * transaction.chain // EvmChain
         * ```
         */
        get: function () {
            return this._data.chain;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(EvmTransaction.prototype, "contractAddress", {
        /**
         * @returns the transaction contract address
         * @example
         * ```
         * transaction.contractAddress // EvmAddress
         * ```
         */
        get: function () {
            return this._data.contractAddress;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(EvmTransaction.prototype, "logs", {
        /**
         * @returns the transaction logs
         * @example
         * ```
         * transaction.logs // EvmTransactionLog[]
         * ```
         */
        get: function () {
            return this._data.logs;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(EvmTransaction.prototype, "receiptRoot", {
        /**
         * @returns the transaction receipt root
         * @example
         * ```
         * transaction.receiptRoot // string
         * ```
         */
        get: function () {
            return this._data.receiptRoot;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(EvmTransaction.prototype, "receiptStatus", {
        /**
         * @returns the transaction receipt status
         * @example
         * ```
         * transaction.receiptStatus // 1
         * ```
         */
        get: function () {
            return this._data.receiptStatus;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(EvmTransaction.prototype, "data", {
        /**
         * @returns the transaction data
         * @example
         * ```
         * transaction.data // 0x000000000000000000000000000000000000000000000000000000000000002
         * ```
         */
        get: function () {
            return this._data.data;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(EvmTransaction.prototype, "hash", {
        /**
         * @returns the transaction hash
         * @example
         * ```
         * transaction.hash // 0x057Ec652A4F150f7FF94f089A38008f49a0DF88e
         * ```
         */
        get: function () {
            return this._data.hash;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(EvmTransaction.prototype, "type", {
        /**
         * @returns the transaction type
         * @example
         * ```
         * transaction.type // 1
         * ```
         */
        get: function () {
            return this._data.type;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(EvmTransaction.prototype, "blockHash", {
        /**
         * @returns the transaction black hash
         * @example
         * ```
         * transaction.blockHash // 0x0372c302e3c52e8f2e15d155e2c545e6d802e479236564af052759253b20fd86
         * ```
         */
        get: function () {
            return this._data.blockHash;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(EvmTransaction.prototype, "blockTimestamp", {
        /**
         * @returns the transaction block timestamp
         * @example
         * ```
         * transaction.blockTimestamp // Date
         * ```
         */
        get: function () {
            return this._data.blockTimestamp;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(EvmTransaction.prototype, "signature", {
        /**
         * @returns the signature (if available)
         * @example
         * ```
         * transaction.signature // EvmSignature
         * ```
         */
        get: function () {
            return this._data.signature;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(EvmTransaction.prototype, "index", {
        /**
         * @returns the index
         * @example
         * ```
         * transaction.index // 1
         * ```
         */
        get: function () {
            return this._data.index;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(EvmTransaction.prototype, "v", {
        get: function () {
            var _a;
            return (_a = this._data.signature) === null || _a === void 0 ? void 0 : _a.v;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(EvmTransaction.prototype, "r", {
        get: function () {
            var _a;
            return (_a = this._data.signature) === null || _a === void 0 ? void 0 : _a.r;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(EvmTransaction.prototype, "s", {
        get: function () {
            var _a;
            return (_a = this._data.signature) === null || _a === void 0 ? void 0 : _a.s;
        },
        enumerable: false,
        configurable: true
    });
    EvmTransaction.parse = function (data, core) {
        var _a;
        return ({
            from: EvmAddress.create(data.from, core),
            to: maybe(data.to, function (to) { return EvmAddress.create(to, core); }),
            nonce: maybe(data.nonce, BigNumber.create),
            data: maybe(data.data),
            value: maybe(data.value, function (val) { return EvmNative.create(val, 'wei'); }),
            hash: data.hash,
            type: maybe(data.type, function (value) { return +value; }),
            chain: EvmChain.create(data.chain),
            gas: maybe(data.gas, BigNumber.create),
            gasPrice: BigNumber.create(data.gasPrice),
            index: +data.index,
            blockNumber: BigNumber.create(data.blockNumber),
            blockHash: data.blockHash,
            blockTimestamp: dateInputToDate(data.blockTimestamp),
            cumulativeGasUsed: BigNumber.create(data.cumulativeGasUsed),
            gasUsed: BigNumber.create(data.gasUsed),
            contractAddress: maybe(data.contractAddress, function (address) { return EvmAddress.create(address, core); }),
            receiptRoot: maybe(data.receiptRoot),
            receiptStatus: maybe(data.receiptStatus, function (status) { return +status; }),
            logs: ((_a = data.logs) !== null && _a !== void 0 ? _a : []).map(function (log) { return EvmTransactionLog.create(log); }),
            signature: maybe(data.signature, EvmSignature.create),
        });
    };
    return EvmTransaction;
}());

/**
 * The EvmSimpleBlock is a representation of a block.
 *
 * @category DataType
 */
var EvmSimpleBlock = /** @class */ (function () {
    function EvmSimpleBlock(data, core) {
        this._data = EvmSimpleBlock.parse(data, core);
    }
    /**
     * Create a new instance of EvmSimpleBlock from any valid transaction input
     * @param data - the EvmSimpleBlockish type
     * @example const transaction = EvmTransaction.create(data);
     */
    EvmSimpleBlock.create = function (data, core) {
        if (data instanceof EvmSimpleBlock) {
            return data;
        }
        var finalCore = core !== null && core !== void 0 ? core : CoreProvider.getDefault();
        return new EvmSimpleBlock(data, finalCore);
    };
    /**
     * Check the equality between two Evm blocks. It compares their hashes and blocks.
     * @param dataA - The first block to compare
     * @param dataB - The second block to compare
     * @example EvmTransaction.equals(dataA, dataB)
     */
    EvmSimpleBlock.equals = function (dataA, dataB) {
        var blockA = EvmSimpleBlock.create(dataA);
        var blockB = EvmSimpleBlock.create(dataB);
        if (!blockA.chain.equals(blockB.chain)) {
            return false;
        }
        if (blockA.hash !== blockB.hash) {
            return false;
        }
        if (!blockA.number.equals(blockB.number)) {
            return false;
        }
        return true;
    };
    /**
     * Checks the equality of the current block with another evm block
     * @param data - the block to compare with
     * @example
     * ```ts
     * block.equals(data)
     * ```
     */
    EvmSimpleBlock.prototype.equals = function (data) {
        return EvmSimpleBlock.equals(this, data);
    };
    /**
     * @returns a JSON represention of the block.
     * @example
     * ```
     * block.toJSON()
     * ```
     */
    EvmSimpleBlock.prototype.toJSON = function () {
        var data = this._data;
        return __assign(__assign({}, data), { number: data.number.toString(), chain: data.chain.format() });
    };
    /**
     * @returns a JSON represention of the block.
     * @example
     * ```
     * block.format()
     * ```
     */
    EvmSimpleBlock.prototype.format = function () {
        return this.toJSON();
    };
    Object.defineProperty(EvmSimpleBlock.prototype, "result", {
        /**
         * @returns all the data without casting it to JSON.
         * @example block.result
         */
        get: function () {
            return this._data;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(EvmSimpleBlock.prototype, "number", {
        /**
         * @returns the block number.
         * @example block.number // BigNumber
         */
        get: function () {
            return this._data.number;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(EvmSimpleBlock.prototype, "hash", {
        /**
         * @returns the block hash.
         * @example block.hash // "0x9b559aef7ea858608c2e554246fe4a24287e7aeeb976848df2b9a2531f4b9171"
         */
        get: function () {
            return this._data.hash;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(EvmSimpleBlock.prototype, "timestamp", {
        /**
         * @returns the block timestamp.
         * @example block.timestamp // Date
         */
        get: function () {
            return this._data.timestamp;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(EvmSimpleBlock.prototype, "chain", {
        /**
         * @returns the block chain.
         * @example block.chain // EvmChain
         */
        get: function () {
            return this._data.chain;
        },
        enumerable: false,
        configurable: true
    });
    EvmSimpleBlock.parse = function (data, core) { return ({
        timestamp: dateInputToDate(data.timestamp),
        number: BigNumber.create(data.number),
        chain: EvmChain.create(data.chain, core),
        hash: data.hash,
    }); };
    return EvmSimpleBlock;
}());

/**
 * The EvmBlock is a representation of a block.
 *
 * @category DataType
 */
var EvmBlock = /** @class */ (function () {
    function EvmBlock(data, core) {
        this._data = EvmBlock.parse(data, core);
    }
    /**
     * Create a new instance of EvmBlock from any valid transaction input
     * @param data - the EvmBlockish type
     * @example const transaction = EvmTransaction.create(data);
     */
    EvmBlock.create = function (data, core) {
        if (data instanceof EvmBlock) {
            return data;
        }
        var finalCore = core !== null && core !== void 0 ? core : CoreProvider.getDefault();
        return new EvmBlock(data, finalCore);
    };
    /**
     * Check the equality between two Evm blocks. It compares their hashes and blocks.
     * @param dataA - The first block to compare
     * @param dataB - The second block to compare
     * @example EvmTransaction.equals(dataA, dataB)
     */
    EvmBlock.equals = function (dataA, dataB) {
        var blockA = EvmSimpleBlock.create(dataA);
        var blockB = EvmSimpleBlock.create(dataB);
        if (!blockA.chain.equals(blockB.chain)) {
            return false;
        }
        if (blockA.hash !== blockB.hash) {
            return false;
        }
        return true;
    };
    /**
     * Checks the equality of the current block with another evm block
     * @param data - the block to compare with
     * @example
     * ```ts
     * block.equals(data)
     * ```
     */
    EvmBlock.prototype.equals = function (data) {
        return EvmBlock.equals(this, data);
    };
    /**
     * @returns a JSON represention of the block.
     * @example
     * ```
     * block.toJSON()
     * ```
     */
    EvmBlock.prototype.toJSON = function () {
        var data = this._data;
        return __assign(__assign({}, data), { number: data.number.toString(), difficulty: data.difficulty.toString(), totalDifficulty: data.totalDifficulty.toString(), size: data.size.toString(), gasLimit: data.gasLimit.toString(), gasUsed: data.gasUsed.toString(), chain: data.chain.format(), miner: data.miner.format(), transactions: data.transactions.map(function (transaction) { return transaction.toJSON(); }) });
    };
    /**
     * @returns a JSON represention of the block.
     * @example
     * ```
     * block.format()
     * ```
     */
    EvmBlock.prototype.format = function () {
        return this.toJSON();
    };
    Object.defineProperty(EvmBlock.prototype, "result", {
        /**
         * @returns all the data without casting it to JSON.
         * @example block.result
         */
        get: function () {
            return this._data;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(EvmBlock.prototype, "number", {
        /**
         * @returns the block number.
         * @example block.number // BigNumber
         */
        get: function () {
            return this._data.number;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(EvmBlock.prototype, "hash", {
        /**
         * @returns the block hash.
         * @example block.hash // "0x9b559aef7ea858608c2e554246fe4a24287e7aeeb976848df2b9a2531f4b9171"
         */
        get: function () {
            return this._data.hash;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(EvmBlock.prototype, "timestamp", {
        /**
         * @returns the block timestamp.
         * @example block.timestamp // Date
         */
        get: function () {
            return this._data.timestamp;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(EvmBlock.prototype, "miner", {
        /**
         * @returns the block miner.
         * @example block.miner // EvmAddress
         */
        get: function () {
            return this._data.miner;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(EvmBlock.prototype, "difficulty", {
        /**
         * @returns the block difficulty.
         * @example block.difficulty // BigNumber
         */
        get: function () {
            return this._data.difficulty;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(EvmBlock.prototype, "totalDifficulty", {
        /**
         * @returns the block total difficulty.
         * @example block.totalDifficulty // BigNumber
         */
        get: function () {
            return this._data.totalDifficulty;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(EvmBlock.prototype, "size", {
        /**
         * @returns the block size.
         * @example block.size // BigNumber
         */
        get: function () {
            return this._data.size;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(EvmBlock.prototype, "gasLimit", {
        /**
         * @returns the block gas limit.
         * @example block.gasLimit // BigNumber
         */
        get: function () {
            return this._data.gasLimit;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(EvmBlock.prototype, "gasUsed", {
        /**
         * @returns the block gas used.
         * @example block.gasUsed // BigNumber
         */
        get: function () {
            return this._data.gasUsed;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(EvmBlock.prototype, "transactions", {
        /**
         * @returns the block transactions.
         * @example block.transactions // EvmTransaction[]
         */
        get: function () {
            return this._data.transactions;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(EvmBlock.prototype, "chain", {
        /**
         * @returns the block chain.
         * @example block.chain // EvmChain
         */
        get: function () {
            return this._data.chain;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(EvmBlock.prototype, "transactionCount", {
        /**
         * @returns the block transaction count.
         * @example block.transactionCount // 252
         */
        get: function () {
            return this._data.transactionCount;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(EvmBlock.prototype, "transactionsRoot", {
        /**
         * @returns the block transactions root.
         * @example block.transactionsRoot // "0xe4c7bf3aff7ad07f9e80d57f7189f0252592fee6321c2a9bd9b09b6ce0690d27"
         */
        get: function () {
            return this._data.transactionsRoot;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(EvmBlock.prototype, "stateRoot", {
        /**
         * @returns the block state root.
         * @example block.stateRoot // "0x49e3bfe7b618e27fde8fa08884803a8458b502c6534af69873a3cc926a7c724b"
         */
        get: function () {
            return this._data.stateRoot;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(EvmBlock.prototype, "receiptsRoot", {
        /**
         * @returns the block receipts root.
         * @example block.receiptsRoot // "0x7cf43d7e837284f036cf92c56973f5e27bdd253ca46168fa195a6b07fa719f23"
         */
        get: function () {
            return this._data.receiptsRoot;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(EvmBlock.prototype, "logsBloom", {
        /**
         * @returns the block logs bloom.
         * @example block.logsBloom // "0xdde5fc46c5d8bcbd58207bc9f267bf43298e23791a326ff02661e99790da9996b3e0dd912c0b8202d389d282c56e4d11eb2dec4898a32b6b165f1f4cae6aa0079498eab50293f3b8defbf6af11bb75f0408a563ddfc26a3323d1ff5f9849e95d5f034d88a757ddea032c75c00708c9ff34d2207f997cc7d93fd1fa160a6bfaf62a54e31f9fe67ab95752106ba9d185bfdc9b6dc3e17427f844ee74e5c09b17b83ad6e8fc7360f5c7c3e4e1939e77a6374bee57d1fa6b2322b11ad56ad0398302de9b26d6fbfe414aa416bff141fad9d4af6aea19322e47595e342cd377403f417dfd396ab5f151095a5535f51cbc34a40ce9648927b7d1d72ab9daf253e31daf"
         */
        get: function () {
            return this._data.logsBloom;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(EvmBlock.prototype, "extraData", {
        /**
         * @returns the block extra data.
         * @example block.extraData // "0x65746865726d696e652d6575726f70652d7765737433"
         */
        get: function () {
            return this._data.extraData;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(EvmBlock.prototype, "parentHash", {
        /**
         * @returns the block parent hash.
         * @example block.parentHash // "0x011d1fc45839de975cc55d758943f9f1d204f80a90eb631f3bf064b80d53e045"
         */
        get: function () {
            return this._data.parentHash;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(EvmBlock.prototype, "sha3Uncles", {
        /**
         * @returns the block sha3Uncles.
         * @example block.sha3Uncles // "0x1dcc4de8dec75d7aab85b567b6ccd41ad312451b948a7413f0a142fd40d49347"
         */
        get: function () {
            return this._data.sha3Uncles;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(EvmBlock.prototype, "nonce", {
        /**
         * @returns the block nonce.
         * @example block.nonce // "0xedeb2d8fd2b2bdec"
         */
        get: function () {
            return this._data.nonce;
        },
        enumerable: false,
        configurable: true
    });
    EvmBlock.parse = function (data, core) { return (__assign(__assign({}, data), { miner: EvmAddress.create(data.miner, core), timestamp: dateInputToDate(data.timestamp), number: BigNumber.create(data.number), difficulty: BigNumber.create(data.difficulty), totalDifficulty: BigNumber.create(data.totalDifficulty), size: BigNumber.create(data.size), gasLimit: BigNumber.create(data.gasLimit), gasUsed: BigNumber.create(data.gasUsed), transactions: data.transactions.map(function (transaction) { return EvmTransaction.create(transaction, core); }), chain: EvmChain.create(data.chain, core), transactionCount: +data.transactionCount })); };
    return EvmBlock;
}());

var EvmBlockDate = /** @class */ (function () {
    function EvmBlockDate(data) {
        this.data = data;
    }
    /**
     * Create a new instance of EvmBlockDate.
     * @param data - the EvmBlockDateish type.
     */
    EvmBlockDate.create = function (data) {
        if (data instanceof EvmBlockDate) {
            return data;
        }
        return new EvmBlockDate(EvmBlockDate.parse(data));
    };
    EvmBlockDate.parse = function (input) {
        return {
            block: input.block,
            date: new Date(input.date),
            timestamp: input.timestamp,
            // TODO: the swagger currently has wrong type for `block_timestamp`, should be `string`.
            blockTimestamp: String(input.block_timestamp),
            hash: input.hash,
            parentHash: input.parent_hash,
        };
    };
    Object.defineProperty(EvmBlockDate.prototype, "block", {
        /**
         * @description The block number.
         * @example `9193266`
         */
        get: function () {
            return this.data.block;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(EvmBlockDate.prototype, "date", {
        /**
         * @description The date of the block.
         * @example `2020-01-01T00:00:00+00:00`
         */
        get: function () {
            return this.data.date;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(EvmBlockDate.prototype, "timestamp", {
        /**
         * @description The timestamp of the block
         * @example `1577836811`
         */
        get: function () {
            return this.data.timestamp;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(EvmBlockDate.prototype, "blockTimestamp", {
        /**
         * @description The timestamp of the block
         * @example `2022-01-03T22:59:39.000Z`
         */
        get: function () {
            return this.data.blockTimestamp;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(EvmBlockDate.prototype, "block_timestamp", {
        /**
         * @deprecated Use `blockTimestamp` instead.
         */
        get: function () {
            return this.data.blockTimestamp;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(EvmBlockDate.prototype, "hash", {
        /**
         * @description The block hash.
         * @example `0x9b559aef7ea858608c2e554246fe4a24287e7aeeb976848df2b9a2531f4b9171`
         */
        get: function () {
            return this.data.hash;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(EvmBlockDate.prototype, "block_hash", {
        /**
         * @deprecated Use `hash` instead.
         */
        get: function () {
            return this.data.hash;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(EvmBlockDate.prototype, "parentHash", {
        /**
         * @description The block hash of the parent block.
         * @example `0x011d1fc45839de975cc55d758943f9f1d204f80a90eb631f3bf064b80d53e045`
         */
        get: function () {
            return this.data.parentHash;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(EvmBlockDate.prototype, "parent_hash", {
        /**
         * @deprecated Use `parentHash` instead.
         */
        get: function () {
            return this.data.parentHash;
        },
        enumerable: false,
        configurable: true
    });
    return EvmBlockDate;
}());

/**
 * The EvmEvent is a representation of an event.
 *
 * Use this class any time you work with an event.
 *
 * @category DataType
 */
var EvmEvent = /** @class */ (function () {
    function EvmEvent(_data) {
        this._data = _data;
    }
    /**
     * Create a new instance of EvmEvent from any valid event input
     * @param data - the EvmEventish type
     * @example
     * ```
     * const event = EvmEventish.create(data);
     *```
     */
    EvmEvent.create = function (data, core) {
        if (data instanceof EvmEvent) {
            return data;
        }
        var finalCore = core !== null && core !== void 0 ? core : CoreProvider.getDefault();
        return new EvmEvent(EvmEvent.parse(data, finalCore));
    };
    /**
     * Check the equality between two Evm events. It checks if the chain, block number, address and data are equal.
     * @param dataA - The first event
     * @param dataB - The second event
     * @example
     * ```ts
     * EvmEvent.equals(dataA, dataB)
     * ```
     * @returns true if the events are equal, false otherwise
     */
    EvmEvent.equals = function (dataA, dataB) {
        var eventA = EvmEvent.create(dataA);
        var eventB = EvmEvent.create(dataB);
        if (!eventA._data.chain.equals(eventB._data.chain)) {
            return false;
        }
        if (!eventA._data.blockNumber.equals(eventB._data.blockNumber)) {
            return false;
        }
        if (!eventA._data.address.equals(eventB._data.address)) {
            return false;
        }
        if (eventA._data.data !== eventB._data.data) {
            return false;
        }
        return true;
    };
    /**
     * Checks the equality of the current event instance with another evm event
     * @param data - the event to compare with
     * @example
     * ```ts
     * event.equals(data)
     * ```
     * @returns true if the events are equal, false otherwise
     */
    EvmEvent.prototype.equals = function (data) {
        return EvmEvent.equals(this, data);
    };
    /**
     * @returns a JSON represention of the event.
     * @example
     * ```
     * event.toJSON()
     * ```
     */
    EvmEvent.prototype.toJSON = function () {
        var _a, _b, _c;
        var data = this._data;
        return __assign(__assign({}, data), { chain: data.chain.format(), address: data.address.format(), blockNumber: data.blockNumber.toString(), data: {
                from: (_a = data.data.from) === null || _a === void 0 ? void 0 : _a.format(),
                to: (_b = data.data.to) === null || _b === void 0 ? void 0 : _b.format(),
                value: (_c = data.data.value) === null || _c === void 0 ? void 0 : _c.format(),
            } });
    };
    /**
     * @returns a JSON represention of the event.
     * @example event.format()
     */
    EvmEvent.prototype.format = function () {
        return this.toJSON();
    };
    Object.defineProperty(EvmEvent.prototype, "result", {
        /**
         * @returns all the data without casting it to JSON.
         * @example event.result
         */
        get: function () {
            return this._data;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(EvmEvent.prototype, "chain", {
        /**
         * @returns the event chain
         * @example event.chain // EvmChain
         */
        get: function () {
            return this._data.chain;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(EvmEvent.prototype, "address", {
        /**
         * @returns the event address
         * @example event.address // EvmAddress
         */
        get: function () {
            return this._data.address;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(EvmEvent.prototype, "blockNumber", {
        /**
         * @returns the event block number
         * @example event.blockNumber // BigNumber
         */
        get: function () {
            return this._data.blockNumber;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(EvmEvent.prototype, "blockTimestamp", {
        /**
         * @returns the event block timestamp
         * @example event.blockTimestamp // Date
         */
        get: function () {
            return this._data.blockTimestamp;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(EvmEvent.prototype, "data", {
        /**
         * @returns the event data with from address, to address and value
         * @example event.data
         */
        get: function () {
            return this._data.data;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(EvmEvent.prototype, "transactionHash", {
        /**
         * @returns the event block trannsaciton hash
         * @example event.transactionHash // "0xc9f62f4f6ab505a96c1a84ec2899c6bfd86245ef1effaa689fc997798be763d5"
         */
        get: function () {
            return this._data.transactionHash;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(EvmEvent.prototype, "blockHash", {
        /**
         * @returns the event block hash
         * @example event.blockHash // "0xc9f62f4f6ab505a96c1a84ec2899c6bfd86245ef1effaa689fc997798be763d5"
         */
        get: function () {
            return this._data.blockHash;
        },
        enumerable: false,
        configurable: true
    });
    EvmEvent.parse = function (data, core) { return (__assign(__assign({}, data), { chain: EvmChain.create(data.chain, core), address: EvmAddress.create(data.address, core), blockNumber: BigNumber.create(data.blockNumber), blockTimestamp: dateInputToDate(data.blockTimestamp), data: {
            from: maybe(data.data.from, function (from) { return EvmAddress.create(from, core); }),
            to: maybe(data.data.to, function (to) { return EvmAddress.create(to, core); }),
            value: maybe(data.data.value, EvmNative.create),
        } })); };
    return EvmEvent;
}());

/**
 * The EvmNft class is a MoralisData that references to a the NFT of the type; Erc721 or Erc1155
 *
 * @category DataType
 */
var EvmNft = /** @class */ (function () {
    function EvmNft(data, core) {
        this._data = EvmNft.parse(data, core);
    }
    /**
     * Create a new instance of EvmNft from any valid address input
     *
     * @param data - the EvmNftish type
     * @param core - the Core instance
     * @example
     * ```ts
     * const nft = EvmNft.create(data);
     * ```
     * @returns an instance of EvmNft
     */
    EvmNft.create = function (data, core) {
        if (data instanceof EvmNft) {
            return data;
        }
        var finalCore = core !== null && core !== void 0 ? core : CoreProvider.getDefault();
        return new EvmNft(data, finalCore);
    };
    // TODO: refactor to reduce complexity
    /**
     * Compares two EvmNftish data. verifies that the chain, tokenAddress and owner of values are equal.
     * @param valueA - the first EvmNftish data to compare
     * @param valueB - the second EvmNftish data to compare
     * @returns true if the values are equal, false otherwise
     * @example
     * ```ts
     *  EvmNft.equals(valueA, valueB);
     * ```
     */
    // eslint-disable-next-line complexity
    EvmNft.equals = function (valueA, valueB) {
        var nftA = EvmNft.create(valueA);
        var nftB = EvmNft.create(valueB);
        if (!nftA._data.chain.equals(nftB._data.chain)) {
            return false;
        }
        if (!nftA._data.tokenAddress.equals(nftB._data.tokenAddress)) {
            return false;
        }
        // Owners are different between tokens
        if (nftA._data.ownerOf && nftB._data.ownerOf && !nftA._data.ownerOf.equals(nftB._data.ownerOf)) {
            return false;
        }
        // Owner is defined in only one token
        if ((nftA._data.ownerOf && !nftB._data.ownerOf) || (!nftA._data.ownerOf && nftB._data.ownerOf)) {
            return false;
        }
        return true;
    };
    /**
     * Compares an EvmNftish data to this EvmNft instance.
     * @param value - the value to compare
     * @returns true if the value is equal to the current instance, false otherwise
     * @example
     * ```ts
     * nft.equals(value);
     * ```
     */
    EvmNft.prototype.equals = function (value) {
        return EvmNft.equals(this, value);
    };
    /**
     * Converts the EvmNft instance to a JSON object.
     * @returns JSON object of the EvmNft instance
     * @example `nft.toJSON()`
     */
    EvmNft.prototype.toJSON = function () {
        var _b, _c, _d;
        var data = this._data;
        return __assign(__assign({}, data), { tokenAddress: data.tokenAddress.format(), chain: data.chain.format(), ownerOf: (_b = data.ownerOf) === null || _b === void 0 ? void 0 : _b.format(), blockNumberMinted: (_c = data.blockNumberMinted) === null || _c === void 0 ? void 0 : _c.toString(), blockNumber: (_d = data.blockNumber) === null || _d === void 0 ? void 0 : _d.toString() });
    };
    /**
     * Converts the EvmNft instance to a JSON object.
     * @returns JSON object of the EvmNft instance
     * @example `nft.format()`
     */
    EvmNft.prototype.format = function () {
        return this.toJSON();
    };
    Object.defineProperty(EvmNft.prototype, "result", {
        get: function () {
            return this._data;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(EvmNft.prototype, "chain", {
        /**
         * @returns the NFT chain
         * @example
         * ```
         * nft.chain // EvmChain
         * ```
         */
        get: function () {
            return this._data.chain;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(EvmNft.prototype, "contractType", {
        /**
         * @returns the NFT contract type
         * @example
         * ```
         * nft.contractType // "ERC721" | "ERC1155"
         * ```
         */
        get: function () {
            return this._data.contractType;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(EvmNft.prototype, "tokenAddress", {
        /**
         * @returns the NFT token address
         * @example
         * ```
         * nft.tokenAddress // EvmAddress
         * ```
         */
        get: function () {
            return this._data.tokenAddress;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(EvmNft.prototype, "metadata", {
        /**
         * @returns the NFT metadata
         * @example
         * ```ts
         * nft.metadata
         * // {
         * // name: 'Pancake',
         * // description: 'The dessert series 1',
         * // image: 'ipfs://QmNQFXCZ6LGzvpMW9Q5PWbCrEnLknQrPwr2r8pbQAgzQ9A/4863BD6B-6C92-4B96-BF80-8020B2F7C3A5.jpeg',
         * // }
         * ```
         */
        get: function () {
            return this._data.metadata;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(EvmNft.prototype, "tokenUri", {
        /**
         * @returns the NFT token URI
         * @example
         * ```
         * nft.tokenUri // "https://gateway.moralisipfs.com/ipfs/QmajSqgxY3cWBgBeRm38vasJAcTit1kp5EwqVHxszJYgUC/728.json"
         * ```
         */
        get: function () {
            return this._data.tokenUri;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(EvmNft.prototype, "tokenHash", {
        /**
         * @returns the NFT token hash
         * @example
         * ```
         * nft.tokenHash // "QmajSqgxY3cWBgBeRm38vasJAcTit1kp5EwqVHxszJYgUC"
         * ```
         */
        get: function () {
            return this._data.tokenHash;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(EvmNft.prototype, "name", {
        /**
         * @returns the NFT name
         * @example
         * ```
         * nft.name // "Tether USD"
         * ```
         */
        get: function () {
            return this._data.name;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(EvmNft.prototype, "symbol", {
        /**
         * @returns the NFT symbol
         * @example
         * ```
         * nft.symbol // "USDT"
         * ```
         */
        get: function () {
            return this._data.symbol;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(EvmNft.prototype, "ownerOf", {
        /**
         * @returns the NFT owner of address
         * @example
         * ```
         * nft.ownerOf // EvmAddress
         * ```
         */
        get: function () {
            return this._data.ownerOf;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(EvmNft.prototype, "blockNumberMinted", {
        /**
         * @returns the NFT block number minted from
         * @example
         * ```
         * nft.blockNumberMinted // BigNumber
         * ```
         */
        get: function () {
            return this._data.blockNumberMinted;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(EvmNft.prototype, "blockNumber", {
        /**
         * @returns the NFT block number
         * @example
         * ```
         * nft.blockNumber // BigNumber
         * ```
         */
        get: function () {
            return this._data.blockNumber;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(EvmNft.prototype, "lastMetadataSync", {
        /**
         * @returns the NFT latest metadata sync date
         * @example
         * ```
         * nft.latestMetadataSync // Date
         * ```
         */
        get: function () {
            return this._data.lastMetadataSync;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(EvmNft.prototype, "lastTokenUriSync", {
        /**
         * @returns the NFT latest token URI sync date
         * @example
         * ```
         * nft.latestTokenUriSync // Date
         * ```
         */
        get: function () {
            return this._data.lastTokenUriSync;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(EvmNft.prototype, "amount", {
        /**
         * @returns the NFT amount
         * @example
         * ```
         * nft.amount // 2
         * ```
         */
        get: function () {
            return this._data.amount;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(EvmNft.prototype, "tokenId", {
        /**
         * @returns the token id
         * @example
         * ```
         * nft.tokenId // '1234'
         * ```
         */
        get: function () {
            return this._data.tokenId;
        },
        enumerable: false,
        configurable: true
    });
    var _a;
    _a = EvmNft;
    EvmNft.parse = function (data, core) { return (__assign(__assign({}, data), { chain: EvmChain.create(data.chain, core), contractType: maybe(data.contractType), tokenAddress: EvmAddress.create(data.tokenAddress, core), metadata: maybe(data.metadata, _a.validateMetadata), tokenUri: maybe(data.tokenUri), tokenHash: maybe(data.tokenHash), name: maybe(data.name), symbol: maybe(data.symbol), ownerOf: maybe(data.ownerOf, function (ownerOf) { return EvmAddress.create(ownerOf, core); }), blockNumberMinted: maybe(data.blockNumberMinted, BigNumber.create), blockNumber: maybe(data.blockNumber, BigNumber.create), lastMetadataSync: maybe(data.lastMetadataSync, dateInputToDate), lastTokenUriSync: maybe(data.lastTokenUriSync, dateInputToDate), amount: maybe(data.amount, function (value) { return +value; }) })); };
    /**
     * This function confirms that the NFT metadata is a valid JSON string.
     *
     * @param value - the new value for the NFT metadata
     * @returns the parsed value of the JSON string
     * @throws {CoreError} if the value is not a valid JSON string
     */
    EvmNft.validateMetadata = function (value) {
        try {
            return JSON.parse(value);
        }
        catch (error) {
            throw new CoreError({
                code: CoreErrorCode.INVALID_ARGUMENT,
                message: 'Invalid metadata provided, cannot parse the value to JSON',
            });
        }
    };
    return EvmNft;
}());

/**
 * The EvmNftCollection is a representation of an nft collection.
 *
 * @category DataType
 */
var EvmNftCollection = /** @class */ (function () {
    function EvmNftCollection(data, core) {
        this._data = EvmNftCollection.parse(data, core);
    }
    /**
     * Create a new instance of EvmNftCollection from any valid transaction input
     * @param data - the EvmNftCollectionish type
     * @example const collection = EvmTransaction.create(data);
     */
    EvmNftCollection.create = function (data, core) {
        if (data instanceof EvmNftCollection) {
            return data;
        }
        var finalCore = core !== null && core !== void 0 ? core : CoreProvider.getDefault();
        return new EvmNftCollection(data, finalCore);
    };
    /**
     * Check the equality between two Evm collections. It compares their hashes and collections.
     * @param dataA - The first collection to compare
     * @param dataB - The second collection to compare
     * @example EvmNftCollection.equals(dataA, dataB)
     */
    EvmNftCollection.equals = function (dataA, dataB) {
        var collectionA = EvmNftCollection.create(dataA);
        var collectionB = EvmNftCollection.create(dataB);
        if (!collectionA.chain.equals(collectionB.chain)) {
            return false;
        }
        if (!collectionA.tokenAddress.equals(collectionB.tokenAddress)) {
            return false;
        }
        return true;
    };
    /**
     * Checks the equality of the current collection with another evm collection
     * @param data - the collection to compare with
     * @example
     * ```ts
     * collection.equals(data)
     * ```
     */
    EvmNftCollection.prototype.equals = function (data) {
        return EvmNftCollection.equals(this, data);
    };
    /**
     * @returns a JSON represention of the collection.
     * @example
     * ```
     * collection.toJSON()
     * ```
     */
    EvmNftCollection.prototype.toJSON = function () {
        var data = this._data;
        return __assign(__assign({}, data), { chain: data.chain.format(), tokenAddress: data.tokenAddress.format() });
    };
    /**
     * @returns a JSON represention of the collection.
     * @example
     * ```
     * collection.format()
     * ```
     */
    EvmNftCollection.prototype.format = function () {
        return this.toJSON();
    };
    Object.defineProperty(EvmNftCollection.prototype, "result", {
        /**
         * @returns all the data without casting it to JSON.
         * @example collection.result
         */
        get: function () {
            return this._data;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(EvmNftCollection.prototype, "chain", {
        /**
         * @returns the chain where the collection is deployed.
         * @example collection.chain // EvmChain
         */
        get: function () {
            return this._data.chain;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(EvmNftCollection.prototype, "tokenAddress", {
        /**
         * @returns the token address of collection.
         * @example collection.tokenAddress // EvmAddress
         */
        get: function () {
            return this._data.tokenAddress;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(EvmNftCollection.prototype, "contractType", {
        /**
         * @returns the token type of collection.
         * @example collection.tokenAddress // 'ERC721'
         */
        get: function () {
            return this._data.contractType;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(EvmNftCollection.prototype, "name", {
        /**
         * @returns the token name of collection.
         * @example collection.tokenAddress // 'Test NFT'
         */
        get: function () {
            return this._data.name;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(EvmNftCollection.prototype, "symbol", {
        /**
         * @returns the token symbol of collection.
         * @example collection.symbol // 'TEST'
         */
        get: function () {
            return this._data.symbol;
        },
        enumerable: false,
        configurable: true
    });
    EvmNftCollection.parse = function (data, core) { return (__assign(__assign({}, data), { tokenAddress: EvmAddress.create(data.tokenAddress, core), chain: EvmChain.create(data.chain, core), contractType: maybe(data.contractType) })); };
    return EvmNftCollection;
}());

/**
 * The EvmNftMetadata contains metadata of an NFT.
 *
 * @category DataType
 */
var EvmNftMetadata = /** @class */ (function () {
    function EvmNftMetadata(data) {
        this._data = EvmNftMetadata.parse(data);
    }
    /**
     *  Create a new instance of EvmNftMetadata from any valid EvmNftMetadata input
     *
     * @param data - the EvmNftMetadataish type
     * @example
     * ```ts
     * const token = EvmNftMetadataish.create(value);
     * ```
     */
    EvmNftMetadata.create = function (data) {
        if (data instanceof EvmNftMetadata) {
            return data;
        }
        return new EvmNftMetadata(data);
    };
    /**
     * Compares two EvmNftMetadata instances. This checks if the chain and tokenAddress of both meatdatas are equal.
     *
     * @param dataA - the first EvmNftMetadataish to compare
     * @param dataB - the second EvmNftMetadataish to compare
     * @returns true if the two EvmNftMetadataData are equal
     * @example
     * ```ts
     * EvmNftMetadata.equals(dataA, dataB);
     * ```
     */
    EvmNftMetadata.equals = function (dataA, dataB) {
        var metadataA = EvmNftMetadata.create(dataA);
        var metadataB = EvmNftMetadata.create(dataB);
        if (!metadataA._data.chain.equals(metadataB._data.chain)) {
            return false;
        }
        if (!metadataA._data.tokenAddress.equals(metadataB._data.tokenAddress)) {
            return false;
        }
        return true;
    };
    /**
     * Compares EvmNftMetadata instance to current instance
     *
     * @param data - the EvmNftMetadataish to compare
     * @returns true if the EvmNftMetadataish is equals given metadata
     * @example
     * ```ts
     * metadata.equals(data);
     * ```
     */
    EvmNftMetadata.prototype.equals = function (data) {
        return EvmNftMetadata.equals(this, data);
    };
    /**
     * @returns the data as JSON.
     * @example metadata.toJSON();
     */
    EvmNftMetadata.prototype.toJSON = function () {
        var data = this._data;
        return __assign(__assign({}, data), { chain: data.chain.format(), tokenAddress: data.tokenAddress.format() });
    };
    /**
     * @returns the data as JSON.
     * @example metadata.format();
     */
    EvmNftMetadata.prototype.format = function () {
        return this.toJSON();
    };
    Object.defineProperty(EvmNftMetadata.prototype, "result", {
        /**
         * @returns all the data without casting it to JSON.
         * @example metadata.result;
         */
        get: function () {
            return this._data;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(EvmNftMetadata.prototype, "name", {
        /**
         * @returns the name in the metadata.
         * @example metadata.name; // "Baby Ape Mutant Club"
         */
        get: function () {
            return this._data.name;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(EvmNftMetadata.prototype, "symbol", {
        /**
         * @returns the symbol in the metadata.
         * @example metadata.symbol; // "BAMC"
         */
        get: function () {
            return this._data.symbol;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(EvmNftMetadata.prototype, "contractType", {
        /**
         * @returns the contract type of the NFT.
         * @example metadata.contractType; // "ERC721"
         */
        get: function () {
            return this._data.contractType;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(EvmNftMetadata.prototype, "chain", {
        /**
         * @returns the chain in the metadata.
         * @example metadata.chain; // EvmChain
         */
        get: function () {
            return this._data.chain;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(EvmNftMetadata.prototype, "tokenAddress", {
        /**
         * @returns the token address in the metadata.
         * @example metadata.tokenAddress; // EvmAddress
         */
        get: function () {
            return this._data.tokenAddress;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(EvmNftMetadata.prototype, "syncedAt", {
        /**
         * @returns the date the metadata was synced.
         * @example metadata.syncedAt; // Date
         */
        get: function () {
            return this._data.syncedAt;
        },
        enumerable: false,
        configurable: true
    });
    EvmNftMetadata.parse = function (data) { return (__assign(__assign({}, data), { chain: EvmChain.create(data.chain), tokenAddress: EvmAddress.create(data.tokenAddress), syncedAt: maybe(data.syncedAt, dateInputToDate) })); };
    return EvmNftMetadata;
}());

/**
 * The EvmNftTrade is a representation of a published trade.
 *
 * Use this class any time you work with a transaction.
 *
 * @category DataType
 */
var EvmNftTrade = /** @class */ (function () {
    function EvmNftTrade(data) {
        this._data = EvmNftTrade.parse(data);
    }
    /**
     * Create a new instance of EvmNftTrade from any valid transaction input
     * @param data - the EvmNftTradeish type
     * @example
     * ```
     * const trade = EvmNftTrade.create(data);
     *```
     */
    EvmNftTrade.create = function (data) {
        if (data instanceof EvmNftTrade) {
            return data;
        }
        return new EvmNftTrade(data);
    };
    /**
     * Check the equality between two Evm trades. It compares the `chain`, `blockNumber`, `transactionIndex` and `transactionHash`
     * @param dataA - The first trade
     * @param dataB - The second trade
     * @example
     * ```ts
     * EvmNftTrade.equals(dataA, dataB)
     * ```
     * @returns true if the trades are equal, false otherwise
     */
    EvmNftTrade.equals = function (dataA, dataB) {
        var transactionA = EvmNftTrade.create(dataA);
        var transactionB = EvmNftTrade.create(dataB);
        if (!transactionA._data.chain.equals(transactionB._data.chain)) {
            return false;
        }
        if (!transactionA._data.blockNumber.equals(transactionB._data.blockNumber)) {
            return false;
        }
        if (transactionA._data.transactionHash !== transactionB._data.transactionHash) {
            return false;
        }
        if (transactionA._data.transactionIndex !== transactionB._data.transactionIndex) {
            return false;
        }
        return true;
    };
    /**
     * Checks the equality of the current trade instance with another evm trade
     * @param data - the trade to compare with
     * @example
     * ```ts
     * trade.equals(data)
     * ```
     * @returns true if the trades are equal, false otherwise
     */
    EvmNftTrade.prototype.equals = function (data) {
        return EvmNftTrade.equals(this, data);
    };
    /**
     * @returns a JSON represention of the trade.
     * @example
     * ```
     * trade.toJSON()
     * ```
     */
    EvmNftTrade.prototype.toJSON = function () {
        var data = this._data;
        return __assign(__assign({}, data), { chain: data.chain.format(), sellerAddress: data.sellerAddress.format(), buyerAddress: data.buyerAddress.format(), marketplaceAddress: data.marketplaceAddress.format(), tokenAddress: data.tokenAddress.format(), priceTokenAddress: data.priceTokenAddress ? data.priceTokenAddress.format() : undefined, blockNumber: data.blockNumber.toString(), price: data.price.toString(), blockTimestamp: data.blockTimestamp.toString() });
    };
    /**
     * @returns a JSON represention of the trade.
     * @example
     * ```
     * trade.format()
     * ```
     */
    EvmNftTrade.prototype.format = function () {
        return this.toJSON();
    };
    Object.defineProperty(EvmNftTrade.prototype, "result", {
        /**
         * @returns all the data without casting it to JSON.
         * @example trade.result
         */
        get: function () {
            return this._data;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(EvmNftTrade.prototype, "sellerAddress", {
        /**
         * @returns the trade seller address
         * @example trade.sellerAddress // EvmAddress
         */
        get: function () {
            return this._data.sellerAddress;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(EvmNftTrade.prototype, "buyerAddress", {
        /**
         * @returns the trade buyer address
         * @example trade.buyerAddress // EvmAddress
         */
        get: function () {
            return this._data.buyerAddress;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(EvmNftTrade.prototype, "marketplaceAddress", {
        /**
         * @returns the trade marketplace address
         * @example trade.marketplaceAddress // EvmAddress
         */
        get: function () {
            return this._data.marketplaceAddress;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(EvmNftTrade.prototype, "tokenAddress", {
        /**
         * @returns the trade token address
         * @example trade.tokenAddress // EvmAddress
         */
        get: function () {
            return this._data.tokenAddress;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(EvmNftTrade.prototype, "priceTokenAddress", {
        /**
         * @returns the trade price token address
         * @example trade.priceTokenAddress // EvmAddress
         */
        get: function () {
            return this._data.priceTokenAddress;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(EvmNftTrade.prototype, "price", {
        /**
         * @returns the trade price
         * @example trade.price // EvmNative
         */
        get: function () {
            return this._data.price;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(EvmNftTrade.prototype, "blockNumber", {
        /**
         * @returns the trade block number
         * @example trade.blockNumber // BigNumber
         */
        get: function () {
            return this._data.blockNumber;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(EvmNftTrade.prototype, "transactionIndex", {
        /**
         * @returns the trade transaction index
         * @example trade.transactionIndex // 164
         */
        get: function () {
            return this._data.transactionIndex;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(EvmNftTrade.prototype, "transactionHash", {
        /**
         * @returns the trade transaction hash
         * @example trade.transactionHash // "0x4de0bcef1450492bd5c2e7693cf644c40005868d0dcc8a7a50a80ef2efa88d1e"
         */
        get: function () {
            return this._data.transactionHash;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(EvmNftTrade.prototype, "chain", {
        /**
         * @returns the trade chain
         * @example trade.chain // EvmChain
         */
        get: function () {
            return this._data.chain;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(EvmNftTrade.prototype, "tokenIds", {
        /**
         * @returns the trade token Ids
         * @example trade.tokenIds // ["16404"]
         */
        get: function () {
            return this._data.tokenIds;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(EvmNftTrade.prototype, "blockHash", {
        /**
         * @returns the trade block hash
         * @example trade.blockHash // "0x4de0bcef1450492bd5c2e7693cf644c40005868d0dcc8a7a50a80ef2efa88d1e"
         */
        get: function () {
            return this._data.blockHash;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(EvmNftTrade.prototype, "blockTimestamp", {
        /**
         * @returns the trade block timestamp
         * @example trade.blockTimestamp // Date
         */
        get: function () {
            return this._data.blockTimestamp;
        },
        enumerable: false,
        configurable: true
    });
    EvmNftTrade.parse = function (data) { return (__assign(__assign({}, data), { chain: EvmChain.create(data.chain), sellerAddress: EvmAddress.create(data.sellerAddress), buyerAddress: EvmAddress.create(data.buyerAddress), marketplaceAddress: EvmAddress.create(data.marketplaceAddress), tokenAddress: EvmAddress.create(data.tokenAddress), priceTokenAddress: maybe(data.priceTokenAddress, EvmAddress.create), blockNumber: BigNumber.create(data.blockNumber), price: EvmNative.create(data.price), transactionIndex: +data.transactionIndex, blockTimestamp: dateInputToDate(data.blockTimestamp) })); };
    return EvmNftTrade;
}());

/**
 * The EvmNftTransfer is a representation of a completed NFT transfer.
 *
 * @category DataType
 */
var EvmNftTransfer = /** @class */ (function () {
    function EvmNftTransfer(data, core) {
        this._data = EvmNftTransfer.parse(data, core);
    }
    /**
     * Create a new instance of EvmNftTransfer from any valid transfer input
     * @param data - the EvmNftTransferish type
     * @example
     * ```
     * const transfer = EvmNftTransfer.create(data);
     *```
     */
    EvmNftTransfer.create = function (data, core) {
        if (data instanceof EvmNftTransfer) {
            return data;
        }
        var finalCore = core !== null && core !== void 0 ? core : CoreProvider.getDefault();
        return new EvmNftTransfer(data, finalCore);
    };
    /**
     * Check the equality between two NFT transfers. The compares the chain, blockHash, tokenId and logIndex.
     * @param dataA - The first transfer to compare
     * @param dataB - The second transfer to compare
     * @example EvmNftTransfer.equals(dataA, dataB)
     * @returns true if the transfers are equal, false otherwise
     */
    EvmNftTransfer.equals = function (dataA, dataB) {
        var transferA = EvmNftTransfer.create(dataA);
        var transferB = EvmNftTransfer.create(dataB);
        if (!transferA.chain.equals(transferB.chain)) {
            return false;
        }
        if (transferA.blockHash !== transferB.blockHash) {
            return false;
        }
        if (transferA.tokenId !== transferB.tokenId) {
            return false;
        }
        if (transferA.logIndex !== transferB.logIndex) {
            return false;
        }
        return true;
    };
    /**
     * Checks the equality of the current transfer instance with another nft transfer
     * @param data - the transfer to compare with
     * @example transaction.equals(data)
     * @returns true if the transfers are equal, false otherwise
     */
    EvmNftTransfer.prototype.equals = function (data) {
        return EvmNftTransfer.equals(this, data);
    };
    /**
     * @returns a JSON represention of the transfer.
     * @example
     * ```
     * transfer.toJSON()
     * ```
     */
    EvmNftTransfer.prototype.toJSON = function () {
        var data = this._data;
        return __assign(__assign({}, data), { chain: data.chain.format(), fromAddress: data.fromAddress ? data.fromAddress.format() : undefined, toAddress: data.toAddress.format(), tokenAddress: data.tokenAddress.format(), value: data.value ? data.value.format() : undefined, operator: data.operator ? data.operator.format() : undefined, blockNumber: data.blockNumber.toString() });
    };
    /**
     * @returns a JSON represention of the transfer.
     * @example
     * ```
     * transfer.format()
     * ```
     */
    EvmNftTransfer.prototype.format = function () {
        return this.toJSON();
    };
    Object.defineProperty(EvmNftTransfer.prototype, "result", {
        /**
         * @returns all the data without casting it to JSON.
         * @example transfer.result
         */
        get: function () {
            return this._data;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(EvmNftTransfer.prototype, "chain", {
        /**
         * @returns the chain of the transfer.
         * @example transfer.chain // EvmChain
         */
        get: function () {
            return this._data.chain;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(EvmNftTransfer.prototype, "blockHash", {
        /**
         * @returns the block hash of the transfer.
         * @example transfer.blockHash // "0x057Ec652A4F150f7FF94f089A38008f49a0DF88e"
         */
        get: function () {
            return this._data.blockHash;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(EvmNftTransfer.prototype, "blockNumber", {
        /**
         * @returns the block number of the transfer.
         * @example transfer.blockNumber // BigNumber
         */
        get: function () {
            return this._data.blockNumber;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(EvmNftTransfer.prototype, "blockTimestamp", {
        /**
         * @returns the block timestamp of the transfer.
         * @example transfer.blockTimestamp // Date
         */
        get: function () {
            return this._data.blockTimestamp;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(EvmNftTransfer.prototype, "fromAddress", {
        /**
         * @returns the from address of the transfer.
         * @example transfer.fromAddress // EvmAddress
         */
        get: function () {
            return this._data.fromAddress;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(EvmNftTransfer.prototype, "toAddress", {
        /**
         * @returns the to address of the transfer.
         * @example transfer.toAddress // EvmAddress
         */
        get: function () {
            return this._data.toAddress;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(EvmNftTransfer.prototype, "tokenAddress", {
        /**
         * @returns the token address of the transfer.
         * @example transfer.tokenAddress // EvmAddress
         */
        get: function () {
            return this._data.tokenAddress;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(EvmNftTransfer.prototype, "tokenId", {
        /**
         * @returns the token id of the transfer.
         * @example transfer.tokenId // "15"
         */
        get: function () {
            return this._data.tokenId;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(EvmNftTransfer.prototype, "amount", {
        /**
         * @returns the amount of the transfer.
         * @example transfer.amount // 1
         */
        get: function () {
            return this._data.amount;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(EvmNftTransfer.prototype, "value", {
        /**
         * @returns the value of the transfer.
         * @example transfer.value // EvmNative
         */
        get: function () {
            return this._data.value;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(EvmNftTransfer.prototype, "logIndex", {
        /**
         * @returns the log index of the transfer.
         * @example transfer.logIndex // 0
         */
        get: function () {
            return this._data.logIndex;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(EvmNftTransfer.prototype, "transactionHash", {
        /**
         * @returns the transaction hash of the transfer.
         * @example transfer.transactionHash // "0x057Ec652A4F150f7FF94f089A38008f49a0DF88e"
         */
        get: function () {
            return this._data.transactionHash;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(EvmNftTransfer.prototype, "transactionIndex", {
        /**
         * @returns the transaction index of the transfer.
         * @example transfer.transactionIndex // 123
         */
        get: function () {
            return this._data.transactionIndex;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(EvmNftTransfer.prototype, "transactionType", {
        /**
         * @returns the transaction type of the transfer.
         * @example transfer.transactionType // "1"
         */
        get: function () {
            return this._data.transactionType;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(EvmNftTransfer.prototype, "operator", {
        /**
         * @returns the operator of the transfer.
         * @example transfer.operator // EvmAddress
         */
        get: function () {
            return this._data.operator;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(EvmNftTransfer.prototype, "contractType", {
        /**
         * @returns the contract type of the transfer.
         * @example transfer.contractType // "ERC721"
         */
        get: function () {
            return this._data.contractType;
        },
        enumerable: false,
        configurable: true
    });
    EvmNftTransfer.parse = function (data, core) { return (__assign(__assign({}, data), { chain: EvmChain.create(data.chain, core), amount: maybe(data.amount, function (amount) { return +amount; }), blockNumber: BigNumber.create(data.blockNumber), blockTimestamp: dateInputToDate(data.blockTimestamp), transactionIndex: maybe(data.transactionIndex, function (index) { return +index; }), transactionType: maybe(data.transactionType), fromAddress: maybe(data.fromAddress, function (address) { return EvmAddress.create(address, core); }), toAddress: EvmAddress.create(data.toAddress, core), tokenAddress: EvmAddress.create(data.tokenAddress, core), value: maybe(data.value, EvmNative.create), operator: maybe(data.operator, function (operator) { return EvmAddress.create(operator, core); }), logIndex: +data.logIndex })); };
    return EvmNftTransfer;
}());

var CommonEvmUtilsConfigSetup = /** @class */ (function () {
    function CommonEvmUtilsConfigSetup() {
    }
    CommonEvmUtilsConfigSetup.register = function (config) {
        config.registerKey(CommonEvmUtilsConfig.formatEvmAddress);
        config.registerKey(CommonEvmUtilsConfig.formatEvmChainId);
    };
    return CommonEvmUtilsConfigSetup;
}());

var CommonEvmUtils = /** @class */ (function (_super) {
    __extends(CommonEvmUtils, _super);
    function CommonEvmUtils(core) {
        return _super.call(this, CommonEvmUtils.moduleName, core) || this;
    }
    CommonEvmUtils.create = function (core) {
        return new CommonEvmUtils(core !== null && core !== void 0 ? core : CoreProvider.getDefault());
    };
    CommonEvmUtils.prototype.setup = function () {
        CommonEvmUtilsConfigSetup.register(this.core.config);
    };
    CommonEvmUtils.prototype.start = function () {
        // Nothing
    };
    Object.defineProperty(CommonEvmUtils.prototype, "EvmAddress", {
        get: function () {
            return EvmAddress;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(CommonEvmUtils.prototype, "EvmChain", {
        get: function () {
            return EvmChain;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(CommonEvmUtils.prototype, "EvmNative", {
        get: function () {
            return EvmNative;
        },
        enumerable: false,
        configurable: true
    });
    CommonEvmUtils.moduleName = 'evmUtils';
    return CommonEvmUtils;
}(Module));

var EvmChainResolver = /** @class */ (function () {
    function EvmChainResolver() {
    }
    EvmChainResolver.resolve = function (chain, core) {
        if (chain) {
            return EvmChain.create(chain, core);
        }
        var defaultEvmChain = core.config.get(CommonEvmUtilsConfig.defaultEvmApiChain);
        return EvmChain.create(defaultEvmChain, core);
    };
    return EvmChainResolver;
}());

/** Get the native balance for a specific wallet address. */
var getNativeBalanceOperation = {
    method: 'GET',
    name: 'getNativeBalance',
    id: 'getNativeBalance',
    groupName: 'balance',
    urlPathPattern: '/{address}/balance',
    urlPathParamNames: ['address'],
    urlSearchParamNames: ['chain', 'toBlock'],
    getRequestUrlParams: getRequestUrlParams$F,
    serializeRequest: serializeRequest$F,
    deserializeRequest: deserializeRequest$F,
    deserializeResponse: deserializeResponse$F,
};
// Methods
function getRequestUrlParams$F(request, core) {
    return {
        chain: EvmChainResolver.resolve(request.chain, core).apiHex,
        to_block: maybe(request.toBlock, String),
        address: EvmAddress.create(request.address, core).checksum,
    };
}
function deserializeResponse$F(jsonResponse) {
    return {
        balance: EvmNative.create(jsonResponse.balance, 'wei'),
    };
}
function serializeRequest$F(request, core) {
    return {
        chain: EvmChainResolver.resolve(request.chain, core).apiHex,
        toBlock: request.toBlock,
        address: EvmAddress.create(request.address, core).lowercase,
    };
}
function deserializeRequest$F(jsonRequest, core) {
    return {
        chain: EvmChain.create(jsonRequest.chain, core),
        toBlock: jsonRequest.toBlock,
        address: EvmAddress.create(jsonRequest.address, core),
    };
}

/** Get the native balances for a set of specific addresses */
var getNativeBalancesForAddressesOperation = {
    method: 'GET',
    name: 'getNativeBalancesForAddresses',
    id: 'getNativeBalancesForAddresses',
    groupName: 'balance',
    urlPathPattern: '/wallets/balance',
    urlSearchParamNames: ['chain', 'providerUrl', 'toBlock', 'walletAddresses'],
    getRequestUrlParams: getRequestUrlParams$E,
    serializeRequest: serializeRequest$E,
    deserializeRequest: deserializeRequest$E,
    deserializeResponse: deserializeResponse$E,
};
// Methods
function getRequestUrlParams$E(request, core) {
    var _a;
    return {
        chain: EvmChainResolver.resolve(request.chain, core).apiHex,
        providerUrl: request.providerUrl,
        to_block: maybe(request.toBlock, String),
        wallet_addresses: (_a = request.walletAddresses) === null || _a === void 0 ? void 0 : _a.map(function (address) { return EvmAddress.create(address, core).checksum; }),
    };
}
function deserializeResponse$E(jsonResponse, request, core) {
    return (jsonResponse !== null && jsonResponse !== void 0 ? jsonResponse : []).map(function (chainBalances) { return ({
        chain: EvmChainResolver.resolve(request.chain, core),
        blockNumber: chainBalances.block_number,
        blockTimestamp: chainBalances.block_timestamp,
        totalBalance: EvmNative.create(chainBalances.total_balance, 'wei'),
        walletBalances: chainBalances.wallet_balances.map(function (walletBalance) { return ({
            address: EvmAddress.create(walletBalance.address, core),
            balance: EvmNative.create(walletBalance.balance, 'wei'),
        }); }),
    }); });
}
function serializeRequest$E(request, core) {
    var _a;
    return {
        chain: EvmChainResolver.resolve(request.chain, core).apiHex,
        providerUrl: request.providerUrl,
        toBlock: request.toBlock,
        walletAddresses: (_a = request.walletAddresses) === null || _a === void 0 ? void 0 : _a.map(function (address) { return EvmAddress.create(address, core).checksum; }),
    };
}
function deserializeRequest$E(jsonRequest, core) {
    var _a;
    return {
        chain: EvmChainResolver.resolve(jsonRequest.chain, core),
        providerUrl: jsonRequest.providerUrl,
        toBlock: jsonRequest.toBlock,
        walletAddresses: (_a = jsonRequest.walletAddresses) === null || _a === void 0 ? void 0 : _a.map(function (address) { return EvmAddress.create(address, core); }),
    };
}

/** Get the contents of a block given the block hash. */
var getBlockOperation = {
    method: 'GET',
    name: 'getBlock',
    id: 'getBlock',
    groupName: 'block',
    isNullable: true,
    urlPathPattern: '/block/{blockNumberOrHash}',
    urlPathParamNames: ['blockNumberOrHash'],
    urlSearchParamNames: ['chain'],
    getRequestUrlParams: getRequestUrlParams$D,
    serializeRequest: serializeRequest$D,
    deserializeRequest: deserializeRequest$D,
    deserializeResponse: deserializeResponse$D,
};
// Methods
function getRequestUrlParams$D(request, core) {
    return {
        chain: EvmChainResolver.resolve(request.chain, core).apiHex,
        blockNumberOrHash: request.blockNumberOrHash,
    };
}
function deserializeResponse$D(jsonResponse, request, core) {
    var _a;
    var data = toCamelCase(jsonResponse);
    var chain = EvmChainResolver.resolve(request.chain, core);
    // TODO: account for changes in api, now we have unknown types for addresses
    // OR fix the types correctly in api
    // I noticed that the docs comes with a type of "string | unknown" which automatically resolves to "unknown". I think we should fix this in the api, casting for now
    return EvmBlock.create(__assign(__assign({}, data), { chain: chain, transactions: ((_a = data.transactions) !== null && _a !== void 0 ? _a : []).map(function (transaction) {
            var _a;
            return EvmTransaction.create({
                cumulativeGasUsed: transaction.receiptCumulativeGasUsed,
                gasPrice: transaction.gasPrice,
                gasUsed: transaction.receiptGasUsed,
                index: transaction.transactionIndex,
                contractAddress: transaction.receiptContractAddress,
                receiptRoot: transaction.receiptRoot,
                receiptStatus: +transaction.receiptStatus,
                chain: chain,
                data: transaction.input,
                from: transaction.fromAddress,
                hash: transaction.hash,
                nonce: transaction.nonce,
                value: transaction.value,
                blockHash: transaction.blockHash,
                blockNumber: +transaction.blockNumber,
                blockTimestamp: new Date(transaction.blockTimestamp),
                gas: transaction.gas,
                to: transaction.toAddress,
                logs: ((_a = transaction.logs) !== null && _a !== void 0 ? _a : []).map(function (jsonLog) {
                    var log = toCamelCase(jsonLog);
                    return EvmTransactionLog.create({
                        chain: chain,
                        address: log.address,
                        blockHash: log.blockHash,
                        blockNumber: +log.blockNumber,
                        data: log.data,
                        topics: [log.topic0, log.topic1, log.topic2, log.topic3],
                        transactionHash: log.transactionHash,
                        blockTimestamp: log.blockTimestamp,
                        logIndex: +log.logIndex,
                        transactionIndex: +log.transactionIndex,
                    });
                }),
            }, core);
        }) }), core);
}
function serializeRequest$D(request, core) {
    return {
        chain: EvmChainResolver.resolve(request.chain, core).apiHex,
        blockNumberOrHash: request.blockNumberOrHash,
    };
}
function deserializeRequest$D(jsonRequest, core) {
    return {
        chain: EvmChain.create(jsonRequest.chain, core),
        blockNumberOrHash: jsonRequest.blockNumberOrHash,
    };
}

/** Get the closest block given the date. */
var getDateToBlockOperation = {
    method: 'GET',
    name: 'getDateToBlock',
    id: 'getDateToBlock',
    groupName: 'block',
    urlPathPattern: '/dateToBlock',
    urlSearchParamNames: ['chain', 'date'],
    getRequestUrlParams: getRequestUrlParams$C,
    serializeRequest: serializeRequest$C,
    deserializeRequest: deserializeRequest$C,
    deserializeResponse: deserializeResponse$C,
};
// Methods
function getRequestUrlParams$C(request, core) {
    return {
        chain: EvmChainResolver.resolve(request.chain, core).apiHex,
        date: new Date(request.date).toISOString(),
    };
}
function deserializeResponse$C(jsonResponse) {
    return EvmBlockDate.create(jsonResponse);
}
function serializeRequest$C(request, core) {
    return {
        chain: EvmChainResolver.resolve(request.chain, core).apiHex,
        date: new Date(request.date).toISOString(),
    };
}
function deserializeRequest$C(jsonRequest, core) {
    return {
        chain: EvmChain.create(jsonRequest.chain, core),
        date: new Date(jsonRequest.date),
    };
}

/**
 * Fetch the pair data of the provided token0+token1 combination.
 * The token0 and token1 options are interchangable (ie. there is no different outcome in "token0=WETH and token1=USDT" or "token0=USDT and token1=WETH")
 */
var getPairAddressOperation = {
    method: 'GET',
    name: 'getPairAddress',
    id: 'getPairAddress',
    groupName: 'defi',
    urlPathPattern: '/{token0Address}/{token1Address}/pairAddress',
    urlPathParamNames: ['token0Address', 'token1Address'],
    urlSearchParamNames: ['chain', 'toBlock', 'toDate', 'exchange'],
    getRequestUrlParams: getRequestUrlParams$B,
    serializeRequest: serializeRequest$B,
    deserializeRequest: deserializeRequest$B,
    deserializeResponse: deserializeResponse$B,
};
// Methods
function getRequestUrlParams$B(request, core) {
    return {
        chain: EvmChainResolver.resolve(request.chain, core).apiHex,
        to_block: request.toBlock,
        to_date: request.toDate ? new Date(request.toDate).toISOString() : undefined,
        exchange: request.exchange,
        token0Address: EvmAddress.create(request.token0Address, core).lowercase,
        token1Address: EvmAddress.create(request.token1Address, core).lowercase,
    };
}
function createErc20Token(token, core, chain) {
    var _a, _b, _c;
    return Erc20Token.create({
        contractAddress: (token === null || token === void 0 ? void 0 : token.address) ? EvmAddress.create(token === null || token === void 0 ? void 0 : token.address, core) : '',
        decimals: (_a = token === null || token === void 0 ? void 0 : token.decimals) !== null && _a !== void 0 ? _a : 0,
        name: (_b = token === null || token === void 0 ? void 0 : token.name) !== null && _b !== void 0 ? _b : '',
        symbol: (_c = token === null || token === void 0 ? void 0 : token.symbol) !== null && _c !== void 0 ? _c : '',
        logo: token === null || token === void 0 ? void 0 : token.logo,
        thumbnail: token === null || token === void 0 ? void 0 : token.thumbnail,
        chain: EvmChainResolver.resolve(chain, core),
    }, core);
}
function deserializeResponse$B(jsonResponse, request, core) {
    var _a, _b, _c, _d, _e, _f, _g, _h;
    return {
        //   ApiResult types generated all come as undefined which should not be the case TODO:
        token0: {
            token: createErc20Token(jsonResponse.token0, core, request.chain),
            blockNumber: (_a = jsonResponse.token0) === null || _a === void 0 ? void 0 : _a.block_number,
            validated: (_b = jsonResponse.token0) === null || _b === void 0 ? void 0 : _b.validated,
            createdAt: ((_c = jsonResponse.token0) === null || _c === void 0 ? void 0 : _c.created_at) ? new Date((_d = jsonResponse.token0) === null || _d === void 0 ? void 0 : _d.created_at) : undefined,
        },
        token1: {
            token: createErc20Token(jsonResponse.token1, core, request.chain),
            blockNumber: (_e = jsonResponse.token1) === null || _e === void 0 ? void 0 : _e.block_number,
            validated: (_f = jsonResponse.token1) === null || _f === void 0 ? void 0 : _f.validated,
            createdAt: ((_g = jsonResponse.token1) === null || _g === void 0 ? void 0 : _g.created_at) ? new Date((_h = jsonResponse.token1) === null || _h === void 0 ? void 0 : _h.created_at) : undefined,
        },
        pairAddress: jsonResponse.pairAddress ? EvmAddress.create(jsonResponse.pairAddress, core) : undefined,
    };
}
function serializeRequest$B(request, core) {
    return {
        chain: EvmChainResolver.resolve(request.chain, core).apiHex,
        toBlock: request.toBlock,
        toDate: request.toDate ? new Date(request.toDate).toISOString() : undefined,
        exchange: request.exchange,
        token0Address: EvmAddress.create(request.token0Address, core).lowercase,
        token1Address: EvmAddress.create(request.token1Address, core).lowercase,
    };
}
function deserializeRequest$B(jsonRequest, core) {
    return {
        chain: EvmChain.create(jsonRequest.chain, core),
        toBlock: jsonRequest.toBlock,
        toDate: jsonRequest.toDate ? new Date(jsonRequest.toDate) : undefined,
        exchange: jsonRequest.exchange,
        token0Address: EvmAddress.create(jsonRequest.token0Address, core),
        token1Address: EvmAddress.create(jsonRequest.token1Address, core),
    };
}

/** Get the liquidity reserves for a given pair address. Only Uniswap V2 based exchanges supported at the moment. */
var getPairReservesOperation = {
    method: 'GET',
    name: 'getPairReserves',
    id: 'getPairReserves',
    groupName: 'defi',
    urlPathPattern: '/{pairAddress}/reserves',
    urlPathParamNames: ['pairAddress'],
    urlSearchParamNames: ['chain', 'toBlock', 'toDate'],
    getRequestUrlParams: getRequestUrlParams$A,
    serializeRequest: serializeRequest$A,
    deserializeRequest: deserializeRequest$A,
    deserializeResponse: deserializeResponse$A,
};
// Methods
function getRequestUrlParams$A(request, core) {
    return {
        chain: EvmChainResolver.resolve(request.chain, core).apiHex,
        pairAddress: EvmAddress.create(request.pairAddress, core).lowercase,
        to_block: request.toBlock,
        to_date: request.toDate ? new Date(request.toDate).toISOString() : undefined,
    };
}
function serializeRequest$A(request, core) {
    return {
        chain: EvmChainResolver.resolve(request.chain, core).apiHex,
        toBlock: request.toBlock,
        toDate: request.toDate ? new Date(request.toDate).toISOString() : undefined,
        pairAddress: EvmAddress.create(request.pairAddress, core).lowercase,
    };
}
function deserializeRequest$A(jsonRequest, core) {
    return {
        chain: EvmChain.create(jsonRequest.chain, core),
        toBlock: jsonRequest.toBlock,
        toDate: jsonRequest.toDate ? new Date(jsonRequest.toDate) : undefined,
        pairAddress: EvmAddress.create(jsonRequest.pairAddress, core),
    };
}
function deserializeResponse$A(jsonResponse) {
    return jsonResponse;
}

/** Get events for a contract ordered by block number in descending order. */
var getContractEventsOperation = {
    method: 'POST',
    name: 'getContractEvents',
    id: 'getContractEvents',
    groupName: 'events',
    urlPathPattern: '/{address}/events',
    urlPathParamNames: ['address'],
    urlSearchParamNames: [
        'chain',
        'fromBlock',
        'toBlock',
        'fromDate',
        'toDate',
        'topic',
        'offset',
        'limit',
        'disableTotal',
    ],
    bodyParamNames: ['abi'],
    bodyType: 'raw',
    firstPageIndex: 0,
    getRequestUrlParams: getRequestUrlParams$z,
    getRequestBody: getRequestBody$3,
    serializeRequest: serializeRequest$z,
    deserializeRequest: deserializeRequest$z,
    deserializeResponse: deserializeResponse$z,
};
// Methods
function getRequestUrlParams$z(request, core) {
    return {
        chain: EvmChainResolver.resolve(request.chain, core).apiHex,
        from_block: maybe(request.fromBlock, String),
        to_block: maybe(request.toBlock, String),
        from_date: request.fromDate ? new Date(request.fromDate).toISOString() : undefined,
        to_date: request.toDate ? new Date(request.toDate).toISOString() : undefined,
        topic: request.topic,
        offset: maybe(request.offset, String),
        limit: maybe(request.limit, String),
        address: EvmAddress.create(request.address, core).lowercase,
        disable_total: request.disableTotal,
    };
}
function getRequestBody$3(request) {
    return request.abi;
}
function deserializeResponse$z(jsonResponse, request, core) {
    var _a, _b;
    return (_b = ((_a = jsonResponse.result) !== null && _a !== void 0 ? _a : [])) === null || _b === void 0 ? void 0 : _b.map(function (event) {
        return EvmEvent.create({
            chain: EvmChainResolver.resolve(request.chain, core),
            address: request.address,
            blockHash: event.block_hash,
            blockNumber: event.block_number,
            blockTimestamp: event.block_timestamp,
            transactionHash: event.transaction_hash,
            data: {
                to: event.data.to,
                from: event.data.from,
                value: event.data.value,
            },
        }, core);
    });
}
function serializeRequest$z(request, core) {
    return {
        chain: EvmChainResolver.resolve(request.chain, core).apiHex,
        fromBlock: request.fromBlock,
        toBlock: request.toBlock,
        fromDate: request.fromDate ? new Date(request.fromDate).toISOString() : undefined,
        toDate: request.toDate ? new Date(request.toDate).toISOString() : undefined,
        topic: request.topic,
        offset: request.offset,
        limit: request.limit,
        address: EvmAddress.create(request.address, core).lowercase,
        abi: request.abi,
        disableTotal: request.disableTotal,
    };
}
function deserializeRequest$z(jsonRequest, core) {
    return {
        chain: EvmChain.create(jsonRequest.chain, core),
        fromBlock: jsonRequest.fromBlock,
        toBlock: jsonRequest.toBlock,
        fromDate: jsonRequest.fromDate ? new Date(jsonRequest.fromDate) : undefined,
        toDate: jsonRequest.toDate ? new Date(jsonRequest.toDate) : undefined,
        topic: jsonRequest.topic,
        offset: jsonRequest.offset,
        limit: jsonRequest.limit,
        address: EvmAddress.create(jsonRequest.address, core),
        abi: jsonRequest.abi,
        disableTotal: jsonRequest.disableTotal,
    };
}

/** Get the logs for a contract. */
var getContractLogsOperation = {
    method: 'GET',
    name: 'getContractLogs',
    id: 'getContractLogs',
    groupName: 'events',
    urlPathPattern: '/{address}/logs',
    urlPathParamNames: ['address'],
    urlSearchParamNames: [
        'chain',
        'blockNumber',
        'fromBlock',
        'toBlock',
        'fromDate',
        'toDate',
        'topic0',
        'topic1',
        'topic2',
        'topic3',
        'limit',
        'cursor',
        'disableTotal',
    ],
    firstPageIndex: 0,
    getRequestUrlParams: getRequestUrlParams$y,
    serializeRequest: serializeRequest$y,
    deserializeRequest: deserializeRequest$y,
    deserializeResponse: deserializeResponse$y,
};
// Methods
function getRequestUrlParams$y(request, core) {
    return {
        chain: EvmChainResolver.resolve(request.chain, core).apiHex,
        block_number: request.blockNumber,
        from_block: request.fromBlock,
        to_block: request.toBlock,
        from_date: request.fromDate ? new Date(request.fromDate).toISOString() : undefined,
        to_date: request.toDate ? new Date(request.toDate).toISOString() : undefined,
        topic0: request.topic0,
        topic1: request.topic1,
        topic2: request.topic2,
        topic3: request.topic3,
        limit: maybe(request.limit, String),
        cursor: request.cursor,
        address: EvmAddress.create(request.address, core).lowercase,
        disable_total: request.disableTotal,
    };
}
function serializeRequest$y(request, core) {
    return {
        chain: EvmChainResolver.resolve(request.chain, core).apiHex,
        blockNumber: request.blockNumber,
        fromBlock: request.fromBlock,
        toBlock: request.toBlock,
        fromDate: request.fromDate ? new Date(request.fromDate).toISOString() : undefined,
        toDate: request.toDate ? new Date(request.toDate).toISOString() : undefined,
        topic0: request.topic0,
        topic1: request.topic1,
        topic2: request.topic2,
        topic3: request.topic3,
        limit: request.limit,
        cursor: request.cursor,
        address: EvmAddress.create(request.address, core).lowercase,
        disableTotal: request.disableTotal,
    };
}
function deserializeRequest$y(jsonRequest, core) {
    return {
        chain: EvmChain.create(jsonRequest.chain, core),
        blockNumber: jsonRequest.blockNumber,
        fromBlock: jsonRequest.fromBlock,
        toBlock: jsonRequest.toBlock,
        fromDate: jsonRequest.fromDate ? new Date(jsonRequest.fromDate) : undefined,
        toDate: jsonRequest.toDate ? new Date(jsonRequest.toDate) : undefined,
        topic0: jsonRequest.topic0,
        topic1: jsonRequest.topic1,
        topic2: jsonRequest.topic2,
        topic3: jsonRequest.topic3,
        limit: jsonRequest.limit,
        cursor: jsonRequest.cursor,
        address: EvmAddress.create(jsonRequest.address, core),
        disableTotal: jsonRequest.disableTotal,
    };
}
function deserializeResponse$y(jsonResponse, request, core) {
    var _a, _b;
    return (_b = ((_a = jsonResponse.result) !== null && _a !== void 0 ? _a : [])) === null || _b === void 0 ? void 0 : _b.map(function (log) {
        return EvmTransactionLog.create(__assign(__assign({}, toCamelCase(log)), { topics: [log.topic0, log.topic1, log.topic2, log.topic3], blockNumber: Number(log.block_number), chain: EvmChainResolver.resolve(request.chain, core) }), core);
    });
}

/** Upload multiple files to IPFS and place them in a folder directory. */
var uploadFolderOperation = {
    method: 'POST',
    name: 'uploadFolder',
    id: 'uploadFolder',
    groupName: 'ipfs',
    urlPathPattern: '/ipfs/uploadFolder',
    bodyType: 'raw',
    bodyParamNames: ['abi'],
    getRequestUrlParams: getRequestUrlParams$x,
    serializeRequest: serializeRequest$x,
    deserializeRequest: deserializeRequest$x,
    deserializeResponse: deserializeResponse$x,
    getRequestBody: getRequestBody$2,
};
// Methods
function getRequestUrlParams$x(_) {
    return {};
}
function getRequestBody$2(request) {
    return request.abi;
}
function deserializeResponse$x(jsonResponse) {
    return jsonResponse;
}
function serializeRequest$x(request) {
    return {
        abi: JSON.stringify(request.abi),
    };
}
function deserializeRequest$x(jsonRequest) {
    return {
        abi: JSON.parse(jsonRequest.abi),
    };
}

/**
 * Get NFTs for a given contract address, including metadata for all NFTs (where available).
 * * Results are limited to 100 per page by default
 * * Requests for contract addresses not yet indexed will automatically start the indexing process for that NFT collection.
 */
var getContractNFTsOperation = {
    method: 'GET',
    name: 'getContractNFTs',
    id: 'getContractNFTs',
    groupName: 'nft',
    urlPathPattern: '/nft/{address}',
    urlPathParamNames: ['address'],
    urlSearchParamNames: [
        'chain',
        'format',
        'limit',
        'totalRanges',
        'range',
        'cursor',
        'normalizeMetadata',
        'disableTotal',
    ],
    firstPageIndex: 0,
    getRequestUrlParams: getRequestUrlParams$w,
    serializeRequest: serializeRequest$w,
    deserializeRequest: deserializeRequest$w,
    deserializeResponse: deserializeResponse$w,
};
// Methods
function getRequestUrlParams$w(request, core) {
    return {
        chain: EvmChainResolver.resolve(request.chain, core).apiHex,
        address: EvmAddress.create(request.address, core).lowercase,
        format: request.format,
        limit: maybe(request.limit, String),
        totalRanges: maybe(request.totalRanges, String),
        range: maybe(request.range, String),
        cursor: request.cursor,
        normalizeMetadata: request.normalizeMetadata,
        disable_total: request.disableTotal,
    };
}
function deserializeResponse$w(jsonResponse, request, core) {
    var _a;
    return ((_a = jsonResponse.result) !== null && _a !== void 0 ? _a : []).map(function (nft) {
        return EvmNft.create(__assign(__assign({}, toCamelCase(nft)), { chain: EvmChainResolver.resolve(request.chain, core), ownerOf: nft.owner_of ? EvmAddress.create(nft.owner_of, core) : undefined, lastMetadataSync: nft.last_metadata_sync ? new Date(nft.last_metadata_sync) : undefined, lastTokenUriSync: nft.last_token_uri_sync ? new Date(nft.last_token_uri_sync) : undefined }), core);
    });
}
function serializeRequest$w(request, core) {
    return {
        chain: EvmChainResolver.resolve(request.chain, core).apiHex,
        format: request.format,
        limit: request.limit,
        totalRanges: request.totalRanges,
        range: request.range,
        cursor: request.cursor,
        address: EvmAddress.create(request.address, core).checksum,
        normalizeMetadata: request.normalizeMetadata,
        disableTotal: request.disableTotal,
    };
}
function deserializeRequest$w(jsonRequest, core) {
    return {
        chain: EvmChain.create(jsonRequest.chain, core),
        format: jsonRequest.format,
        limit: jsonRequest.limit,
        totalRanges: jsonRequest.totalRanges,
        range: jsonRequest.range,
        cursor: jsonRequest.cursor,
        address: EvmAddress.create(jsonRequest.address, core),
        normalizeMetadata: jsonRequest.normalizeMetadata,
        disableTotal: jsonRequest.disableTotal,
    };
}

/**
 * Get NFTs for a given contract address, including metadata for all NFTs (where available).
 * * Results are limited to 100 per page by default
 * * Requests for contract addresses not yet indexed will automatically start the indexing process for that NFT collection.
 */
var getMultipleNFTsOperation = {
    method: 'POST',
    name: 'getMultipleNFTs',
    id: 'getMultipleNFTs',
    groupName: 'nft',
    urlPathPattern: '/nft/getMultipleNFTs',
    urlSearchParamNames: ['chain'],
    bodyType: 'properties',
    bodyParamNames: ['tokens', 'normalizeMetadata'],
    getRequestUrlParams: getRequestUrlParams$v,
    getRequestBody: getRequestBody$1,
    serializeRequest: serializeRequest$v,
    deserializeRequest: deserializeRequest$v,
    deserializeResponse: deserializeResponse$v,
};
// Methods
function getRequestUrlParams$v(request, core) {
    return {
        chain: EvmChainResolver.resolve(request.chain, core).apiHex,
    };
}
function getRequestBody$1(request, core) {
    return {
        tokens: request.tokens.map(function (token) { return ({
            token_address: EvmAddress.create(token.tokenAddress, core).lowercase,
            token_id: token.tokenId,
        }); }),
        normalizeMetadata: request.normalizeMetadata,
    };
}
function deserializeResponse$v(jsonResponse, request, core) {
    return (jsonResponse !== null && jsonResponse !== void 0 ? jsonResponse : []).map(function (nft) {
        if (nft === null) {
            return null;
        }
        return EvmNft.create(__assign(__assign({}, toCamelCase(nft)), { chain: EvmChainResolver.resolve(request.chain, core), amount: nft.amount ? parseInt(nft.amount, 10) : undefined, ownerOf: EvmAddress.create(nft.owner_of, core), lastMetadataSync: dateInputToDate(nft.last_metadata_sync), lastTokenUriSync: dateInputToDate(nft.last_token_uri_sync) }), core);
    });
}
function serializeRequest$v(request, core) {
    return {
        chain: EvmChainResolver.resolve(request.chain, core).apiHex,
        normalizeMetadata: request.normalizeMetadata,
        tokens: request.tokens.map(function (token) { return ({
            tokenAddress: EvmAddress.create(token.tokenAddress, core).lowercase,
            tokenId: token.tokenId,
        }); }),
    };
}
function deserializeRequest$v(jsonRequest, core) {
    return {
        chain: EvmChain.create(jsonRequest.chain, core),
        normalizeMetadata: jsonRequest.normalizeMetadata,
        tokens: jsonRequest.tokens.map(function (token) { return ({
            tokenAddress: EvmAddress.create(token.tokenAddress, core),
            tokenId: token.tokenId,
        }); }),
    };
}

/**
 * Get the collection / contract level metadata for a given contract (name, symbol, base token uri).
 * * Requests for contract addresses not yet indexed will automatically start the indexing process for that NFT collection
 */
var getNFTContractMetadataOperation = {
    method: 'GET',
    name: 'getNFTContractMetadata',
    id: 'getNFTContractMetadata',
    groupName: 'nft',
    isNullable: true,
    urlPathPattern: '/nft/{address}/metadata',
    urlPathParamNames: ['address'],
    urlSearchParamNames: ['chain'],
    getRequestUrlParams: getRequestUrlParams$u,
    serializeRequest: serializeRequest$u,
    deserializeRequest: deserializeRequest$u,
    deserializeResponse: deserializeResponse$u,
};
// Methods
function getRequestUrlParams$u(request, core) {
    return {
        chain: EvmChainResolver.resolve(request.chain, core).apiHex,
        address: EvmAddress.create(request.address, core).lowercase,
    };
}
function deserializeResponse$u(jsonResponse, request, core) {
    return EvmNftMetadata.create(__assign(__assign({}, toCamelCase(jsonResponse)), { chain: EvmChainResolver.resolve(request.chain, core), tokenAddress: EvmAddress.create(jsonResponse.token_address, core), syncedAt: jsonResponse.synced_at ? new Date(jsonResponse.synced_at) : null, contractType: maybe(jsonResponse.contract_type) }));
}
function serializeRequest$u(request, core) {
    return {
        chain: EvmChainResolver.resolve(request.chain, core).apiHex,
        address: EvmAddress.create(request.address, core).checksum,
    };
}
function deserializeRequest$u(jsonRequest, core) {
    return {
        chain: EvmChain.create(jsonRequest.chain, core),
        address: EvmAddress.create(jsonRequest.address, core),
    };
}

/** Get transfers of NFTs for a given contract and other parameters. */
var getNFTContractTransfersOperation = {
    method: 'GET',
    name: 'getNFTContractTransfers',
    id: 'getNFTContractTransfers',
    groupName: 'nft',
    urlPathPattern: '/nft/{address}/transfers',
    urlPathParamNames: ['address'],
    urlSearchParamNames: [
        'chain',
        'format',
        'limit',
        'cursor',
        'fromBlock',
        'fromDate',
        'toBlock',
        'toDate',
        'disableTotal',
    ],
    firstPageIndex: 0,
    getRequestUrlParams: getRequestUrlParams$t,
    serializeRequest: serializeRequest$t,
    deserializeRequest: deserializeRequest$t,
    deserializeResponse: deserializeResponse$t,
};
// Methods
function getRequestUrlParams$t(request, core) {
    return {
        chain: EvmChainResolver.resolve(request.chain, core).apiHex,
        address: EvmAddress.create(request.address, core).lowercase,
        format: request.format,
        limit: maybe(request.limit, String),
        from_block: maybe(request.fromBlock, String),
        from_date: request.fromDate ? new Date(request.fromDate).toISOString() : undefined,
        to_block: maybe(request.toBlock, String),
        to_date: request.toDate ? new Date(request.toDate).toISOString() : undefined,
        cursor: request.cursor,
        disable_total: request.disableTotal,
    };
}
function deserializeResponse$t(jsonResponse, request, core) {
    var _a;
    return ((_a = jsonResponse.result) !== null && _a !== void 0 ? _a : []).map(function (transfer) {
        return EvmNftTransfer.create(__assign(__assign({}, toCamelCase(transfer)), { chain: EvmChainResolver.resolve(request.chain, core), tokenAddress: EvmAddress.create(transfer.to_address, core), toAddress: EvmAddress.create(transfer.to_address, core), operator: transfer.operator ? EvmAddress.create(transfer.operator, core) : null, fromAddress: transfer.from_address ? EvmAddress.create(transfer.from_address, core) : null, value: transfer.value ? EvmNative.create(transfer.value) : null, blockTimestamp: new Date(transfer.block_timestamp) }), core);
    });
}
function serializeRequest$t(request, core) {
    return {
        chain: EvmChainResolver.resolve(request.chain, core).apiHex,
        format: request.format,
        limit: request.limit,
        cursor: request.cursor,
        address: EvmAddress.create(request.address, core).checksum,
        fromBlock: request.fromBlock,
        toBlock: request.toBlock,
        fromDate: request.fromDate ? new Date(request.fromDate).toISOString() : undefined,
        toDate: request.toDate ? new Date(request.toDate).toISOString() : undefined,
        disableTotal: request.disableTotal,
    };
}
function deserializeRequest$t(jsonRequest, core) {
    return {
        chain: EvmChain.create(jsonRequest.chain, core),
        format: jsonRequest.format,
        limit: jsonRequest.limit,
        cursor: jsonRequest.cursor,
        address: EvmAddress.create(jsonRequest.address, core),
        fromBlock: jsonRequest.fromBlock,
        toBlock: jsonRequest.toBlock,
        fromDate: jsonRequest.fromDate ? new Date(jsonRequest.fromDate) : undefined,
        toDate: jsonRequest.toDate ? new Date(jsonRequest.toDate) : undefined,
        disableTotal: jsonRequest.disableTotal,
    };
}

/** Get the lowest executed price for an NFT contract for the last x days (only trades paid in ETH). */
var getNFTLowestPriceOperation = {
    method: 'GET',
    name: 'getNFTLowestPrice',
    id: 'getNFTLowestPrice',
    groupName: 'nft',
    isNullable: true,
    urlPathPattern: '/nft/{address}/lowestprice',
    urlPathParamNames: ['address'],
    urlSearchParamNames: ['chain', 'days', 'marketplace'],
    getRequestUrlParams: getRequestUrlParams$s,
    serializeRequest: serializeRequest$s,
    deserializeRequest: deserializeRequest$s,
    deserializeResponse: deserializeResponse$s,
};
// Methods
function getRequestUrlParams$s(request, core) {
    return {
        chain: EvmChainResolver.resolve(request.chain, core).apiHex,
        address: EvmAddress.create(request.address, core).lowercase,
        days: maybe(request.days, String),
        marketplace: request.marketplace,
    };
}
function deserializeResponse$s(jsonResponse, request, core) {
    return EvmNftTrade.create(__assign(__assign({}, toCamelCase(jsonResponse)), { chain: EvmChainResolver.resolve(request.chain, core), sellerAddress: EvmAddress.create(jsonResponse.seller_address, core), buyerAddress: EvmAddress.create(jsonResponse.buyer_address, core), marketplaceAddress: EvmAddress.create(jsonResponse.marketplace_address, core), tokenAddress: EvmAddress.create(jsonResponse.token_address, core), price: EvmNative.create(jsonResponse.price, 'wei'), blockTimestamp: new Date(jsonResponse.block_timestamp), tokenIds: jsonResponse.token_ids }));
}
function serializeRequest$s(request, core) {
    return {
        chain: EvmChainResolver.resolve(request.chain, core).apiHex,
        days: request.days,
        marketplace: request.marketplace,
        address: EvmAddress.create(request.address, core).checksum,
    };
}
function deserializeRequest$s(jsonRequest, core) {
    return {
        chain: EvmChain.create(jsonRequest.chain, core),
        days: jsonRequest.days,
        marketplace: jsonRequest.marketplace,
        address: EvmAddress.create(jsonRequest.address, core),
    };
}

/**
 * Get NFT data, including metadata (where available), for the given NFT token ID and contract address.
 * * Requests for contract addresses not yet indexed will automatically start the indexing process for that NFT collection
 */
var getNFTMetadataOperation = {
    method: 'GET',
    name: 'getNFTMetadata',
    id: 'getNFTMetadata',
    groupName: 'nft',
    isNullable: true,
    urlPathPattern: '/nft/{address}/{tokenId}',
    urlPathParamNames: ['address', 'tokenId'],
    urlSearchParamNames: ['chain', 'format', 'normalizeMetadata'],
    getRequestUrlParams: getRequestUrlParams$r,
    serializeRequest: serializeRequest$r,
    deserializeRequest: deserializeRequest$r,
    deserializeResponse: deserializeResponse$r,
};
// Methods
function getRequestUrlParams$r(request, core) {
    return {
        chain: EvmChainResolver.resolve(request.chain, core).apiHex,
        address: EvmAddress.create(request.address, core).lowercase,
        tokenId: request.tokenId,
        format: request.format,
        normalizeMetadata: request.normalizeMetadata,
    };
}
function deserializeResponse$r(jsonResponse, request, core) {
    return EvmNft.create(__assign(__assign({}, toCamelCase(jsonResponse)), { chain: EvmChainResolver.resolve(request.chain, core), ownerOf: jsonResponse.owner_of ? EvmAddress.create(jsonResponse.owner_of, core) : undefined, lastMetadataSync: jsonResponse.last_metadata_sync ? new Date(jsonResponse.last_metadata_sync) : undefined, lastTokenUriSync: jsonResponse.last_token_uri_sync ? new Date(jsonResponse.last_token_uri_sync) : undefined }), core);
}
function serializeRequest$r(request, core) {
    return {
        chain: EvmChainResolver.resolve(request.chain, core).apiHex,
        format: request.format,
        address: EvmAddress.create(request.address, core).checksum,
        tokenId: request.tokenId,
        normalizeMetadata: request.normalizeMetadata,
    };
}
function deserializeRequest$r(jsonRequest, core) {
    return {
        chain: EvmChain.create(jsonRequest.chain, core),
        format: jsonRequest.format,
        address: EvmAddress.create(jsonRequest.address, core),
        tokenId: jsonRequest.tokenId,
        normalizeMetadata: jsonRequest.normalizeMetadata,
    };
}

/**
 * Get owners of NFTs for a given contract.
 * * Requests for contract addresses not yet indexed will automatically start the indexing process for that NFT collection.
 */
var getNFTOwnersOperation = {
    method: 'GET',
    name: 'getNFTOwners',
    id: 'getNFTOwners',
    groupName: 'nft',
    urlPathPattern: '/nft/{address}/owners',
    urlPathParamNames: ['address'],
    urlSearchParamNames: ['chain', 'format', 'limit', 'cursor', 'normalizeMetadata', 'disableTotal'],
    firstPageIndex: 1,
    getRequestUrlParams: getRequestUrlParams$q,
    serializeRequest: serializeRequest$q,
    deserializeRequest: deserializeRequest$q,
    deserializeResponse: deserializeResponse$q,
};
// Methods
function getRequestUrlParams$q(request, core) {
    return {
        chain: EvmChainResolver.resolve(request.chain, core).apiHex,
        address: EvmAddress.create(request.address, core).lowercase,
        format: request.format,
        limit: maybe(request.limit, String),
        cursor: request.cursor,
        normalizeMetadata: request.normalizeMetadata,
        disable_total: request.disableTotal,
    };
}
function deserializeResponse$q(jsonResponse, request, core) {
    var _a;
    return ((_a = jsonResponse.result) !== null && _a !== void 0 ? _a : []).map(function (nft) {
        return EvmNft.create(__assign(__assign({}, toCamelCase(nft)), { chain: EvmChainResolver.resolve(request.chain, core), ownerOf: EvmAddress.create(nft.owner_of, core), lastMetadataSync: new Date(nft.last_metadata_sync), lastTokenUriSync: new Date(nft.last_token_uri_sync) }), core);
    });
}
function serializeRequest$q(request, core) {
    return {
        chain: EvmChainResolver.resolve(request.chain, core).apiHex,
        format: request.format,
        limit: request.limit,
        cursor: request.cursor,
        address: EvmAddress.create(request.address, core).checksum,
        normalizeMetadata: request.normalizeMetadata,
        disableTotal: request.disableTotal,
    };
}
function deserializeRequest$q(jsonRequest, core) {
    return {
        chain: EvmChain.create(jsonRequest.chain, core),
        format: jsonRequest.format,
        limit: jsonRequest.limit,
        cursor: jsonRequest.cursor,
        address: EvmAddress.create(jsonRequest.address, core),
        normalizeMetadata: jsonRequest.normalizeMetadata,
        disableTotal: jsonRequest.disableTotal,
    };
}

/**
 * Get owners of a specific NFT given the contract address and token ID.
 * * Requests for contract addresses not yet indexed will automatically start the indexing process for that NFT collection
 */
var getNFTTokenIdOwnersOperation = {
    method: 'GET',
    name: 'getNFTTokenIdOwners',
    id: 'getNFTTokenIdOwners',
    groupName: 'nft',
    urlPathPattern: '/nft/{address}/{tokenId}/owners',
    urlPathParamNames: ['address', 'tokenId'],
    urlSearchParamNames: ['chain', 'format', 'limit', 'cursor', 'normalizeMetadata', 'disableTotal'],
    firstPageIndex: 1,
    getRequestUrlParams: getRequestUrlParams$p,
    serializeRequest: serializeRequest$p,
    deserializeRequest: deserializeRequest$p,
    deserializeResponse: deserializeResponse$p,
};
// Methods
function getRequestUrlParams$p(request, core) {
    return {
        chain: EvmChainResolver.resolve(request.chain, core).apiHex,
        address: EvmAddress.create(request.address, core).lowercase,
        format: request.format,
        limit: maybe(request.limit, String),
        cursor: request.cursor,
        tokenId: request.tokenId,
        normalizeMetadata: request.normalizeMetadata,
        disable_total: request.disableTotal,
    };
}
function deserializeResponse$p(jsonResponse, request, core) {
    var _a;
    return ((_a = jsonResponse.result) !== null && _a !== void 0 ? _a : []).map(function (nft) {
        return EvmNft.create(__assign(__assign({}, toCamelCase(nft)), { chain: EvmChainResolver.resolve(request.chain, core), ownerOf: EvmAddress.create(nft.owner_of, core), lastMetadataSync: new Date(nft.last_metadata_sync), lastTokenUriSync: new Date(nft.last_token_uri_sync) }));
    });
}
function serializeRequest$p(request, core) {
    return {
        chain: EvmChainResolver.resolve(request.chain, core).apiHex,
        format: request.format,
        limit: request.limit,
        cursor: request.cursor,
        address: EvmAddress.create(request.address, core).checksum,
        tokenId: request.tokenId,
        normalizeMetadata: request.normalizeMetadata,
        disableTotal: request.disableTotal,
    };
}
function deserializeRequest$p(jsonRequest, core) {
    return {
        chain: EvmChain.create(jsonRequest.chain, core),
        format: jsonRequest.format,
        limit: jsonRequest.limit,
        cursor: jsonRequest.cursor,
        address: EvmAddress.create(jsonRequest.address, core),
        tokenId: jsonRequest.tokenId,
        normalizeMetadata: jsonRequest.normalizeMetadata,
        disableTotal: jsonRequest.disableTotal,
    };
}

/** Get trades of NFTs for a given contract and marketplace. */
var getNFTTradesOperation = {
    method: 'GET',
    name: 'getNFTTrades',
    id: 'getNFTTrades',
    groupName: 'nft',
    urlPathPattern: '/nft/{address}/trades',
    urlPathParamNames: ['address'],
    urlSearchParamNames: [
        'chain',
        'fromBlock',
        'toBlock',
        'fromDate',
        'toDate',
        'marketplace',
        'cursor',
        'limit',
        'disableTotal',
    ],
    firstPageIndex: 0,
    getRequestUrlParams: getRequestUrlParams$o,
    serializeRequest: serializeRequest$o,
    deserializeRequest: deserializeRequest$o,
    deserializeResponse: deserializeResponse$o,
};
// Methods
function getRequestUrlParams$o(request, core) {
    return {
        chain: EvmChainResolver.resolve(request.chain, core).apiHex,
        address: EvmAddress.create(request.address, core).lowercase,
        from_block: maybe(request.fromBlock, String),
        to_block: maybe(request.toBlock, String),
        from_date: request.fromDate ? new Date(request.fromDate).toISOString() : undefined,
        to_date: request.toDate ? new Date(request.toDate).toISOString() : undefined,
        marketplace: request.marketplace,
        cursor: request.cursor,
        limit: maybe(request.limit, String),
        disable_total: request.disableTotal,
    };
}
function deserializeResponse$o(jsonResponse, request, core) {
    var _a;
    return ((_a = jsonResponse.result) !== null && _a !== void 0 ? _a : []).map(function (trade) {
        return EvmNftTrade.create(__assign(__assign({}, toCamelCase(trade)), { chain: EvmChainResolver.resolve(request.chain, core), sellerAddress: EvmAddress.create(trade.seller_address, core), buyerAddress: EvmAddress.create(trade.buyer_address, core), marketplaceAddress: EvmAddress.create(trade.marketplace_address, core), tokenAddress: EvmAddress.create(trade.token_address, core), price: EvmNative.create(trade.price, 'wei'), blockTimestamp: new Date(trade.block_timestamp), tokenIds: trade.token_ids }));
    });
}
function serializeRequest$o(request, core) {
    return {
        chain: EvmChainResolver.resolve(request.chain, core).apiHex,
        fromBlock: request.fromBlock,
        toBlock: request.toBlock,
        fromDate: request.fromDate,
        toDate: request.toDate,
        marketplace: request.marketplace,
        cursor: request.cursor,
        limit: request.limit,
        address: EvmAddress.create(request.address, core).checksum,
        disableTotal: request.disableTotal,
    };
}
function deserializeRequest$o(jsonRequest, core) {
    return {
        chain: EvmChain.create(jsonRequest.chain, core),
        fromBlock: jsonRequest.fromBlock,
        toBlock: jsonRequest.toBlock,
        fromDate: jsonRequest.fromDate,
        toDate: jsonRequest.toDate,
        marketplace: jsonRequest.marketplace,
        cursor: jsonRequest.cursor,
        limit: jsonRequest.limit,
        address: EvmAddress.create(jsonRequest.address, core),
        disableTotal: jsonRequest.disableTotal,
    };
}

/** Get transfers of NFTs given a block number or block hash. */
var getNFTTransfersByBlockOperation = {
    method: 'GET',
    name: 'getNFTTransfersByBlock',
    id: 'getNFTTransfersByBlock',
    groupName: 'nft',
    urlPathPattern: '/block/{blockNumberOrHash}/nft/transfers',
    urlPathParamNames: ['blockNumberOrHash'],
    urlSearchParamNames: ['chain', 'limit', 'cursor', 'disableTotal'],
    firstPageIndex: 0,
    getRequestUrlParams: getRequestUrlParams$n,
    serializeRequest: serializeRequest$n,
    deserializeRequest: deserializeRequest$n,
    deserializeResponse: deserializeResponse$n,
};
// Methods
function getRequestUrlParams$n(request, core) {
    return {
        chain: EvmChainResolver.resolve(request.chain, core).apiHex,
        limit: maybe(request.limit, String),
        cursor: request.cursor,
        blockNumberOrHash: request.blockNumberOrHash,
        disable_total: request.disableTotal,
    };
}
function deserializeResponse$n(jsonResponse, request, core) {
    var _a;
    return ((_a = jsonResponse.result) !== null && _a !== void 0 ? _a : []).map(function (transfer) {
        return EvmNftTransfer.create(__assign(__assign({}, toCamelCase(transfer)), { chain: EvmChainResolver.resolve(request.chain, core), tokenAddress: EvmAddress.create(transfer.token_address, core), toAddress: EvmAddress.create(transfer.to_address, core), operator: transfer.operator ? EvmAddress.create(transfer.operator, core) : null, fromAddress: transfer.from_address ? EvmAddress.create(transfer.from_address, core) : null, value: transfer.value ? EvmNative.create(transfer.value, 'wei') : null, blockTimestamp: new Date(transfer.block_timestamp) }), core);
    });
}
function serializeRequest$n(request, core) {
    return {
        chain: EvmChainResolver.resolve(request.chain, core).apiHex,
        limit: request.limit,
        cursor: request.cursor,
        blockNumberOrHash: request.blockNumberOrHash,
        disableTotal: request.disableTotal,
    };
}
function deserializeRequest$n(jsonRequest, core) {
    return {
        chain: EvmChain.create(jsonRequest.chain, core),
        limit: jsonRequest.limit,
        cursor: jsonRequest.cursor,
        blockNumberOrHash: jsonRequest.blockNumberOrHash,
        disableTotal: jsonRequest.disableTotal,
    };
}

/** Get transfers of NFTs from a block number to a block number. */
var getNFTTransfersFromToBlockOperation = {
    method: 'GET',
    name: 'getNFTTransfersFromToBlock',
    id: 'getNFTTransfersFromToBlock',
    groupName: 'nft',
    urlPathPattern: '/nft/transfers',
    urlSearchParamNames: [
        'chain',
        'fromBlock',
        'toBlock',
        'fromDate',
        'toDate',
        'format',
        'limit',
        'cursor',
        'disableTotal',
    ],
    firstPageIndex: 0,
    getRequestUrlParams: getRequestUrlParams$m,
    serializeRequest: serializeRequest$m,
    deserializeRequest: deserializeRequest$m,
    deserializeResponse: deserializeResponse$m,
};
// Methods
function getRequestUrlParams$m(request, core) {
    return {
        chain: EvmChainResolver.resolve(request.chain, core).apiHex,
        from_block: maybe(request.fromBlock, String),
        to_block: maybe(request.toBlock, String),
        from_date: request.fromDate ? new Date(request.fromDate).toISOString() : undefined,
        to_date: request.toDate ? new Date(request.toDate).toISOString() : undefined,
        format: request.format,
        limit: maybe(request.limit, String),
        cursor: request.cursor,
        disable_total: request.disableTotal,
    };
}
function deserializeResponse$m(jsonResponse, request, core) {
    var _a;
    return ((_a = jsonResponse.result) !== null && _a !== void 0 ? _a : []).map(function (transfer) {
        return EvmNftTransfer.create(__assign(__assign({}, toCamelCase(transfer)), { chain: EvmChainResolver.resolve(request.chain, core), tokenAddress: EvmAddress.create(transfer.to_address, core), toAddress: EvmAddress.create(transfer.to_address, core), operator: transfer.operator ? EvmAddress.create(transfer.operator, core) : null, fromAddress: transfer.from_address ? EvmAddress.create(transfer.from_address, core) : null, value: transfer.value ? EvmNative.create(transfer.value) : null, blockTimestamp: new Date(transfer.block_timestamp) }));
    });
}
function serializeRequest$m(request, core) {
    return {
        chain: EvmChainResolver.resolve(request.chain, core).apiHex,
        fromBlock: request.fromBlock,
        toBlock: request.toBlock,
        fromDate: request.fromDate,
        toDate: request.toDate,
        format: request.format,
        limit: request.limit,
        cursor: request.cursor,
        disableTotal: request.disableTotal,
    };
}
function deserializeRequest$m(jsonRequest, core) {
    return {
        chain: EvmChain.create(jsonRequest.chain, core),
        fromBlock: jsonRequest.fromBlock,
        toBlock: jsonRequest.toBlock,
        fromDate: jsonRequest.fromDate,
        toDate: jsonRequest.toDate,
        format: jsonRequest.format,
        limit: jsonRequest.limit,
        cursor: jsonRequest.cursor,
        disableTotal: jsonRequest.disableTotal,
    };
}

/** Get transfers of an NFT given a contract address and token ID. */
var getNFTTransfersOperation = {
    method: 'GET',
    name: 'getNFTTransfers',
    id: 'getNFTTransfers',
    groupName: 'nft',
    urlPathPattern: '/nft/{address}/{tokenId}/transfers',
    urlPathParamNames: ['address', 'tokenId'],
    urlSearchParamNames: ['chain', 'format', 'limit', 'cursor', 'disableTotal'],
    firstPageIndex: 0,
    getRequestUrlParams: getRequestUrlParams$l,
    serializeRequest: serializeRequest$l,
    deserializeRequest: deserializeRequest$l,
    deserializeResponse: deserializeResponse$l,
};
// Methods
function getRequestUrlParams$l(request, core) {
    return {
        chain: EvmChainResolver.resolve(request.chain, core).apiHex,
        address: EvmAddress.create(request.address, core).lowercase,
        format: request.format,
        limit: maybe(request.limit, String),
        cursor: request.cursor,
        tokenId: request.tokenId,
        disable_total: request.disableTotal,
    };
}
function deserializeResponse$l(jsonResponse, request, core) {
    var _a;
    return ((_a = jsonResponse.result) !== null && _a !== void 0 ? _a : []).map(function (transfer) {
        return EvmNftTransfer.create(__assign(__assign({}, toCamelCase(transfer)), { chain: EvmChainResolver.resolve(request.chain, core), tokenAddress: EvmAddress.create(transfer.to_address, core), toAddress: EvmAddress.create(transfer.to_address, core), operator: transfer.operator ? EvmAddress.create(transfer.operator, core) : null, fromAddress: transfer.from_address ? EvmAddress.create(transfer.from_address, core) : null, value: transfer.value ? EvmNative.create(transfer.value) : null, blockTimestamp: new Date(transfer.block_timestamp) }));
    });
}
function serializeRequest$l(request, core) {
    return {
        chain: EvmChainResolver.resolve(request.chain, core).apiHex,
        format: request.format,
        limit: request.limit,
        cursor: request.cursor,
        address: EvmAddress.create(request.address, core).checksum,
        tokenId: request.tokenId,
        disableTotal: request.disableTotal,
    };
}
function deserializeRequest$l(jsonRequest, core) {
    return {
        chain: EvmChain.create(jsonRequest.chain, core),
        format: jsonRequest.format,
        limit: jsonRequest.limit,
        cursor: jsonRequest.cursor,
        address: EvmAddress.create(jsonRequest.address, core),
        tokenId: jsonRequest.tokenId,
        disableTotal: jsonRequest.disableTotal,
    };
}

/** Get NFT collections owned by a given wallet address. */
var getWalletNFTCollectionsOperation = {
    method: 'GET',
    name: 'getWalletNFTCollections',
    id: 'getWalletNFTCollections',
    groupName: 'nft',
    urlPathPattern: '/{address}/nft/collections',
    urlPathParamNames: ['address'],
    urlSearchParamNames: ['chain', 'limit', 'cursor', 'disableTotal'],
    firstPageIndex: 1,
    getRequestUrlParams: getRequestUrlParams$k,
    serializeRequest: serializeRequest$k,
    deserializeRequest: deserializeRequest$k,
    deserializeResponse: deserializeResponse$k,
};
// Methods
function getRequestUrlParams$k(request, core) {
    return {
        chain: EvmChainResolver.resolve(request.chain, core).apiHex,
        address: EvmAddress.create(request.address, core).lowercase,
        limit: maybe(request.limit, String),
        cursor: request.cursor,
        disable_total: request.disableTotal,
    };
}
function deserializeResponse$k(jsonResponse, request, core) {
    var _a;
    return ((_a = jsonResponse.result) !== null && _a !== void 0 ? _a : []).map(function (collection) {
        return EvmNftCollection.create(__assign(__assign({}, toCamelCase(collection)), { chain: EvmChainResolver.resolve(request.chain, core), tokenAddress: EvmAddress.create(collection.token_address, core) }), core);
    });
}
function serializeRequest$k(request, core) {
    return {
        chain: EvmChainResolver.resolve(request.chain, core).apiHex,
        limit: request.limit,
        cursor: request.cursor,
        address: EvmAddress.create(request.address, core).checksum,
        disableTotal: request.disableTotal,
    };
}
function deserializeRequest$k(jsonRequest, core) {
    return {
        chain: EvmChain.create(jsonRequest.chain, core),
        limit: jsonRequest.limit,
        cursor: jsonRequest.cursor,
        address: EvmAddress.create(jsonRequest.address, core),
        disableTotal: jsonRequest.disableTotal,
    };
}

/**
 * Get NFTs owned by a given address.
 * * The response will include status [SYNCED/SYNCING] based on the contracts being indexed.
 * * Use the token_address param to get results for a specific contract only
 * * Note results will include all indexed NFTs
 * * Any request which includes the token_address param will start the indexing process for that NFT collection the very first time it is requested.
 */
var getWalletNFTsOperation = {
    method: 'GET',
    name: 'getWalletNFTs',
    id: 'getWalletNFTs',
    groupName: 'nft',
    firstPageIndex: 1,
    urlPathPattern: '/{address}/nft',
    urlPathParamNames: ['address'],
    urlSearchParamNames: ['chain', 'format', 'limit', 'tokenAddresses', 'cursor', 'normalizeMetadata', 'disableTotal'],
    getRequestUrlParams: getRequestUrlParams$j,
    serializeRequest: serializeRequest$j,
    deserializeRequest: deserializeRequest$j,
    deserializeResponse: deserializeResponse$j,
};
// Methods
function getRequestUrlParams$j(request, core) {
    var _a;
    return {
        chain: EvmChainResolver.resolve(request.chain, core).apiHex,
        address: EvmAddress.create(request.address, core).lowercase,
        format: request.format,
        limit: maybe(request.limit, String),
        token_addresses: (_a = request.tokenAddresses) === null || _a === void 0 ? void 0 : _a.map(function (address) { return EvmAddress.create(address, core).lowercase; }),
        cursor: request.cursor,
        normalizeMetadata: request.normalizeMetadata,
        disable_total: request.disableTotal,
    };
}
function deserializeResponse$j(jsonResponse, request, core) {
    var _a;
    return ((_a = jsonResponse.result) !== null && _a !== void 0 ? _a : []).map(function (nft) {
        return EvmNft.create({
            chain: EvmChainResolver.resolve(request.chain, core),
            contractType: nft.contract_type,
            tokenAddress: nft.token_address,
            tokenId: nft.token_id,
            tokenUri: nft.token_uri,
            metadata: nft.metadata,
            name: nft.name,
            symbol: nft.symbol,
            amount: nft.amount ? parseInt(nft.amount, 10) : undefined,
            blockNumberMinted: nft.block_number_minted,
            blockNumber: nft.block_number,
            ownerOf: EvmAddress.create(nft.owner_of, core),
            tokenHash: nft.token_hash,
            lastMetadataSync: dateInputToDate(nft.last_metadata_sync),
            lastTokenUriSync: dateInputToDate(nft.last_token_uri_sync),
        });
    });
}
function serializeRequest$j(request, core) {
    var _a;
    return {
        chain: EvmChainResolver.resolve(request.chain, core).apiHex,
        format: request.format,
        limit: request.limit,
        tokenAddresses: (_a = request.tokenAddresses) === null || _a === void 0 ? void 0 : _a.map(function (address) { return EvmAddress.create(address, core).checksum; }),
        cursor: request.cursor,
        address: EvmAddress.create(request.address, core).checksum,
        normalizeMetadata: request.normalizeMetadata,
        disableTotal: request.disableTotal,
    };
}
function deserializeRequest$j(jsonRequest, core) {
    return {
        chain: EvmChain.create(jsonRequest.chain, core),
        format: jsonRequest.format,
        limit: jsonRequest.limit,
        tokenAddresses: maybe(jsonRequest.tokenAddresses, function (addresses) {
            return addresses.map(function (address) { return EvmAddress.create(address, core); });
        }),
        cursor: jsonRequest.cursor,
        address: EvmAddress.create(jsonRequest.address, core),
        normalizeMetadata: jsonRequest.normalizeMetadata,
        disableTotal: jsonRequest.disableTotal,
    };
}

/** Get transfers of NFTs given the wallet and other parameters. */
var getWalletNFTTransfersOperation = {
    method: 'GET',
    name: 'getWalletNFTTransfers',
    id: 'getWalletNFTTransfers',
    groupName: 'nft',
    urlPathPattern: '/{address}/nft/transfers',
    urlPathParamNames: ['address'],
    urlSearchParamNames: ['chain', 'format', 'direction', 'fromBlock', 'toBlock', 'limit', 'cursor', 'disableTotal'],
    firstPageIndex: 0,
    getRequestUrlParams: getRequestUrlParams$i,
    serializeRequest: serializeRequest$i,
    deserializeRequest: deserializeRequest$i,
    deserializeResponse: deserializeResponse$i,
};
// Methods
function getRequestUrlParams$i(request, core) {
    return {
        chain: EvmChainResolver.resolve(request.chain, core).apiHex,
        address: EvmAddress.create(request.address, core).lowercase,
        format: request.format,
        direction: request.direction,
        from_block: maybe(request.fromBlock, String),
        to_block: request.toBlock,
        limit: maybe(request.limit, String),
        cursor: request.cursor,
        disable_total: request.disableTotal,
    };
}
function deserializeResponse$i(jsonResponse, request, core) {
    var _a;
    return ((_a = jsonResponse.result) !== null && _a !== void 0 ? _a : []).map(function (transfer) {
        return EvmNftTransfer.create(__assign(__assign({}, toCamelCase(transfer)), { chain: EvmChainResolver.resolve(request.chain, core), tokenAddress: EvmAddress.create(transfer.token_address, core), toAddress: EvmAddress.create(transfer.to_address, core), operator: transfer.operator ? EvmAddress.create(transfer.operator, core) : null, fromAddress: transfer.from_address ? EvmAddress.create(transfer.from_address, core) : null, value: transfer.value ? EvmNative.create(transfer.value, 'wei') : null, blockTimestamp: new Date(transfer.block_timestamp) }), core);
    });
}
function serializeRequest$i(request, core) {
    return {
        chain: EvmChainResolver.resolve(request.chain, core).apiHex,
        format: request.format,
        direction: request.direction,
        fromBlock: request.fromBlock,
        toBlock: request.toBlock,
        limit: request.limit,
        cursor: request.cursor,
        address: EvmAddress.create(request.address, core).checksum,
        disableTotal: request.disableTotal,
    };
}
function deserializeRequest$i(jsonRequest, core) {
    return {
        chain: EvmChain.create(jsonRequest.chain, core),
        format: jsonRequest.format,
        direction: jsonRequest.direction,
        fromBlock: jsonRequest.fromBlock,
        toBlock: jsonRequest.toBlock,
        limit: jsonRequest.limit,
        cursor: jsonRequest.cursor,
        address: EvmAddress.create(jsonRequest.address, core),
        disableTotal: jsonRequest.disableTotal,
    };
}

/**
 * ReSync the metadata for an NFT
 * * The metadata flag will request a the NFT's metadata from the already existing token_uri
 * * The uri(default) flag will fetch the latest token_uri from the given NFT address. In sync mode the metadata will also be fetched
 * * The sync mode will make the endpoint synchronous so it will wait for the task to be completed before responding
 * * The async mode(default) will make the endpoint asynchronous so we will wait for the task to be completed before responding
 */
var reSyncMetadataOperation = {
    method: 'GET',
    name: 'reSyncMetadata',
    id: 'reSyncMetadata',
    groupName: 'nft',
    urlPathPattern: '/nft/{address}/{tokenId}/metadata/resync',
    urlPathParamNames: ['address', 'tokenId'],
    urlSearchParamNames: ['chain', 'flag', 'mode'],
    getRequestUrlParams: getRequestUrlParams$h,
    serializeRequest: serializeRequest$h,
    deserializeRequest: deserializeRequest$h,
    deserializeResponse: deserializeResponse$h,
};
// Methods
function getRequestUrlParams$h(request, core) {
    return {
        chain: EvmChainResolver.resolve(request.chain, core).apiHex,
        address: EvmAddress.create(request.address, core).lowercase,
        flag: request.flag,
        mode: request.mode,
        tokenId: request.tokenId,
    };
}
function serializeRequest$h(request, core) {
    return {
        chain: EvmChainResolver.resolve(request.chain, core).apiHex,
        flag: request.flag,
        mode: request.mode,
        address: EvmAddress.create(request.address, core).checksum,
        tokenId: request.tokenId,
    };
}
function deserializeRequest$h(jsonRequest, core) {
    return {
        chain: EvmChain.create(jsonRequest.chain, core),
        flag: jsonRequest.flag,
        mode: jsonRequest.mode,
        address: EvmAddress.create(jsonRequest.address, core),
        tokenId: jsonRequest.tokenId,
    };
}
function deserializeResponse$h(jsonResponse) {
    return jsonResponse;
}

/** Get NFTs that match a given metadata search query. */
var searchNFTsOperation = {
    method: 'GET',
    name: 'searchNFTs',
    id: 'searchNFTs',
    groupName: 'nft',
    urlPathPattern: '/nft/search',
    urlSearchParamNames: [
        'chain',
        'format',
        'q',
        'filter',
        'fromBlock',
        'toBlock',
        'fromDate',
        'toDate',
        'addresses',
        'cursor',
        'limit',
        'disableTotal',
    ],
    firstPageIndex: 0,
    getRequestUrlParams: getRequestUrlParams$g,
    serializeRequest: serializeRequest$g,
    deserializeRequest: deserializeRequest$g,
    deserializeResponse: deserializeResponse$g,
};
// Methods
function getRequestUrlParams$g(request, core) {
    var _a;
    return {
        chain: EvmChainResolver.resolve(request.chain, core).apiHex,
        format: request.format,
        q: request.q,
        filter: request.filter,
        from_block: maybe(request.fromBlock, String),
        to_block: maybe(request.toBlock, String),
        from_date: request.fromDate ? new Date(request.fromDate).toISOString() : undefined,
        to_date: request.toDate ? new Date(request.toDate).toISOString() : undefined,
        addresses: (_a = request.addresses) === null || _a === void 0 ? void 0 : _a.map(function (address) { return EvmAddress.create(address, core).lowercase; }),
        cursor: request.cursor,
        limit: maybe(request.limit, String),
        disable_total: request.disableTotal,
    };
}
function deserializeResponse$g(jsonResponse, request, core) {
    var _a;
    return ((_a = jsonResponse.result) !== null && _a !== void 0 ? _a : []).map(function (nft) { return ({
        token: EvmNft.create({
            chain: EvmChainResolver.resolve(request.chain, core),
            contractType: nft.contract_type,
            tokenAddress: nft.token_address,
            tokenId: nft.token_id,
            tokenUri: nft.token_uri,
            metadata: nft.metadata,
            tokenHash: nft.token_hash,
        }, core),
        tokenHash: nft.token_hash,
        blockNumberMinted: nft.block_number_minted,
        lastMetadataSync: nft.last_metadata_sync ? new Date(nft.last_metadata_sync) : undefined,
        lastTokenUriSync: nft.last_token_uri_sync ? new Date(nft.last_token_uri_sync) : undefined,
        batchId: nft.batch_id,
        frozen: nft.frozen,
        frozenLogIndex: nft.frozen_log_index,
        imported: nft.imported,
        isValid: nft.is_valid,
        openseaLookup: nft.opensea_lookup,
        resyncing: nft.resyncing,
        syncing: nft.syncing,
        updatedAt: new Date(nft.updatedAt),
    }); });
}
function serializeRequest$g(request, core) {
    var _a;
    return {
        chain: EvmChainResolver.resolve(request.chain, core).apiHex,
        format: request.format,
        q: request.q,
        filter: request.filter,
        fromBlock: request.fromBlock,
        toBlock: request.toBlock,
        fromDate: request.fromDate,
        toDate: request.toDate,
        addresses: (_a = request.addresses) === null || _a === void 0 ? void 0 : _a.map(function (address) { return EvmAddress.create(address, core).checksum; }),
        cursor: request.cursor,
        limit: request.limit,
        disableTotal: request.disableTotal,
    };
}
function deserializeRequest$g(jsonRequest, core) {
    return {
        chain: EvmChain.create(jsonRequest.chain, core),
        format: jsonRequest.format,
        q: jsonRequest.q,
        filter: jsonRequest.filter,
        fromBlock: jsonRequest.fromBlock,
        toBlock: jsonRequest.toBlock,
        fromDate: jsonRequest.fromDate,
        toDate: jsonRequest.toDate,
        addresses: maybe(jsonRequest.addresses, function (addresses) {
            return addresses.map(function (address) { return EvmAddress.create(address, core); });
        }),
        cursor: jsonRequest.cursor,
        limit: jsonRequest.limit,
        disableTotal: jsonRequest.disableTotal,
    };
}

/** Initiates a sync of a previously non synced Contract. */
var syncNFTContractOperation = {
    method: 'PUT',
    name: 'syncNFTContract',
    id: 'syncNFTContract',
    groupName: 'nft',
    urlPathPattern: '/nft/{address}/sync',
    urlPathParamNames: ['address'],
    urlSearchParamNames: ['chain'],
    getRequestUrlParams: getRequestUrlParams$f,
    serializeRequest: serializeRequest$f,
    deserializeRequest: deserializeRequest$f,
    deserializeResponse: deserializeResponse$f,
};
// Methods
function getRequestUrlParams$f(request, core) {
    return {
        chain: EvmChainResolver.resolve(request.chain, core).apiHex,
        address: EvmAddress.create(request.address, core).lowercase,
    };
}
function deserializeResponse$f() {
    return {
        success: true,
    };
}
function serializeRequest$f(request, core) {
    return {
        chain: EvmChainResolver.resolve(request.chain, core).apiHex,
        address: EvmAddress.create(request.address, core).checksum,
    };
}
function deserializeRequest$f(jsonRequest, core) {
    return {
        chain: EvmChain.create(jsonRequest.chain, core),
        address: EvmAddress.create(jsonRequest.address, core),
    };
}

/** Resolve an ETH address and find the ENS name. */
var resolveAddressOperation = {
    method: 'GET',
    name: 'resolveAddress',
    id: 'resolveAddress',
    groupName: 'resolve',
    isNullable: true,
    urlPathPattern: '/resolve/{address}/reverse',
    urlPathParamNames: ['address'],
    getRequestUrlParams: getRequestUrlParams$e,
    serializeRequest: serializeRequest$e,
    deserializeRequest: deserializeRequest$e,
    deserializeResponse: deserializeResponse$e,
};
// Methods
function getRequestUrlParams$e(request, core) {
    return {
        address: maybe(request.address, function (address) { return EvmAddress.create(address, core).checksum; }),
    };
}
function deserializeResponse$e(jsonResponse) {
    return jsonResponse;
}
function serializeRequest$e(request, core) {
    return {
        address: maybe(request.address, function (address) { return EvmAddress.create(address, core).checksum; }),
    };
}
function deserializeRequest$e(jsonRequest, core) {
    return {
        address: maybe(jsonRequest.address, function (address) { return EvmAddress.create(address, core); }),
    };
}

/** Resolve an Unstoppable domain and get the address. */
var resolveDomainOperation = {
    method: 'GET',
    name: 'resolveDomain',
    id: 'resolveDomain',
    groupName: 'resolve',
    isNullable: true,
    urlPathPattern: '/resolve/{domain}',
    urlPathParamNames: ['domain'],
    urlSearchParamNames: ['currency'],
    getRequestUrlParams: getRequestUrlParams$d,
    serializeRequest: serializeRequest$d,
    deserializeRequest: deserializeRequest$d,
    deserializeResponse: deserializeResponse$d,
};
// Methods
function getRequestUrlParams$d(request) {
    return {
        currency: request.currency,
        domain: request.domain,
    };
}
function serializeRequest$d(request) {
    return {
        currency: request.currency,
        domain: request.domain,
    };
}
function deserializeRequest$d(jsonRequest) {
    return {
        currency: jsonRequest.currency,
        domain: jsonRequest.domain,
    };
}
function deserializeResponse$d(jsonResponse, request, core) {
    return {
        address: EvmAddress.create(jsonResponse.address, core),
    };
}

/** Get the amount which the spender is allowed to withdraw on behalf of the owner. */
var getTokenAllowanceOperation = {
    method: 'GET',
    name: 'getTokenAllowance',
    id: 'getTokenAllowance',
    groupName: 'token',
    urlPathPattern: '/erc20/{address}/allowance',
    urlPathParamNames: ['address'],
    urlSearchParamNames: ['chain', 'ownerAddress', 'spenderAddress'],
    getRequestUrlParams: getRequestUrlParams$c,
    serializeRequest: serializeRequest$c,
    deserializeRequest: deserializeRequest$c,
    deserializeResponse: deserializeResponse$c,
};
// Methods
function getRequestUrlParams$c(request, core) {
    return {
        chain: EvmChainResolver.resolve(request.chain, core).apiHex,
        owner_address: EvmAddress.create(request.ownerAddress, core).lowercase,
        spender_address: EvmAddress.create(request.spenderAddress, core).lowercase,
        address: EvmAddress.create(request.address, core).lowercase,
    };
}
function deserializeResponse$c(jsonResponse) {
    return {
        allowance: BigNumber.create(jsonResponse.allowance),
    };
}
function serializeRequest$c(request, core) {
    return {
        chain: EvmChainResolver.resolve(request.chain, core).apiHex,
        ownerAddress: EvmAddress.create(request.ownerAddress, core).checksum,
        spenderAddress: EvmAddress.create(request.spenderAddress, core).checksum,
        address: EvmAddress.create(request.address, core).checksum,
    };
}
function deserializeRequest$c(jsonRequest, core) {
    return {
        chain: EvmChain.create(jsonRequest.chain, core),
        ownerAddress: EvmAddress.create(jsonRequest.ownerAddress, core),
        spenderAddress: EvmAddress.create(jsonRequest.spenderAddress, core),
        address: EvmAddress.create(jsonRequest.address, core),
    };
}

/** Get the metadata for a given token contract address (name, symbol, decimals, logo). */
var getTokenMetadataOperation = {
    method: 'GET',
    name: 'getTokenMetadata',
    id: 'getTokenMetadata',
    groupName: 'token',
    urlPathPattern: '/erc20/metadata',
    urlSearchParamNames: ['chain', 'addresses'],
    getRequestUrlParams: getRequestUrlParams$b,
    serializeRequest: serializeRequest$b,
    deserializeRequest: deserializeRequest$b,
    deserializeResponse: deserializeResponse$b,
};
// Methods
function getRequestUrlParams$b(request, core) {
    return {
        chain: EvmChainResolver.resolve(request.chain, core).apiHex,
        addresses: request.addresses.map(function (address) { return EvmAddress.create(address, core).lowercase; }),
    };
}
function deserializeResponse$b(jsonResponse, request, core) {
    return (jsonResponse !== null && jsonResponse !== void 0 ? jsonResponse : []).map(function (token) {
        return {
            token: Erc20Token.create(__assign(__assign({}, toCamelCase(token)), { contractAddress: token.address, chain: EvmChainResolver.resolve(request.chain, core) }), core),
            blockNumber: token.block_number,
            validated: token.validated,
        };
    });
}
function serializeRequest$b(request, core) {
    return {
        chain: EvmChainResolver.resolve(request.chain, core).apiHex,
        addresses: request.addresses.map(function (address) { return EvmAddress.create(address, core).checksum; }),
    };
}
function deserializeRequest$b(jsonRequest, core) {
    return {
        chain: EvmChain.create(jsonRequest.chain, core),
        addresses: jsonRequest.addresses.map(function (address) { return EvmAddress.create(address, core); }),
    };
}

/** Get metadata for a list of token symbols (name, symbol, decimals, logo). */
var getTokenMetadataBySymbolOperation = {
    method: 'GET',
    name: 'getTokenMetadataBySymbol',
    id: 'getTokenMetadataBySymbol',
    groupName: 'token',
    urlPathPattern: '/erc20/metadata/symbols',
    urlSearchParamNames: ['chain', 'symbols'],
    getRequestUrlParams: getRequestUrlParams$a,
    serializeRequest: serializeRequest$a,
    deserializeRequest: deserializeRequest$a,
    deserializeResponse: deserializeResponse$a,
};
// Methods
function getRequestUrlParams$a(request, core) {
    return {
        chain: EvmChainResolver.resolve(request.chain, core).apiHex,
        symbols: request.symbols,
    };
}
function deserializeResponse$a(jsonResponse, request, core) {
    return (jsonResponse !== null && jsonResponse !== void 0 ? jsonResponse : []).map(function (token) {
        return {
            token: Erc20Token.create(__assign(__assign({}, toCamelCase(token)), { contractAddress: token.address, chain: EvmChainResolver.resolve(request.chain, core) }), core),
            blockNumber: token.block_number,
            validated: token.validated,
        };
    });
}
function serializeRequest$a(request, core) {
    return {
        chain: EvmChainResolver.resolve(request.chain, core).apiHex,
        symbols: request.symbols,
    };
}
function deserializeRequest$a(jsonRequest, core) {
    return {
        chain: EvmChain.create(jsonRequest.chain, core),
        symbols: jsonRequest.symbols,
    };
}

/** Get the token price denominated in the blockchains native token and USD. */
var getTokenPriceOperation = {
    method: 'GET',
    name: 'getTokenPrice',
    id: 'getTokenPrice',
    groupName: 'token',
    urlPathPattern: '/erc20/{address}/price',
    urlPathParamNames: ['address'],
    urlSearchParamNames: ['chain', 'exchange', 'toBlock'],
    getRequestUrlParams: getRequestUrlParams$9,
    serializeRequest: serializeRequest$9,
    deserializeRequest: deserializeRequest$9,
    deserializeResponse: deserializeResponse$9,
};
// Methods
function getRequestUrlParams$9(request, core) {
    return {
        chain: EvmChainResolver.resolve(request.chain, core).apiHex,
        exchange: request.exchange,
        to_block: maybe(request.toBlock, String),
        address: EvmAddress.create(request.address, core).lowercase,
    };
}
function deserializeResponse$9(jsonResponse, request, core) {
    var _a, _b, _c;
    return __assign(__assign({}, toCamelCase(jsonResponse)), { nativePrice: ((_a = jsonResponse.nativePrice) === null || _a === void 0 ? void 0 : _a.value)
            ? EvmNative.create((_b = jsonResponse.nativePrice) === null || _b === void 0 ? void 0 : _b.value, (_c = jsonResponse.nativePrice) === null || _c === void 0 ? void 0 : _c.decimals)
            : null, exchangeAddress: jsonResponse.exchangeAddress ? EvmAddress.create(jsonResponse.exchangeAddress, core) : null });
}
function serializeRequest$9(request, core) {
    return {
        chain: EvmChainResolver.resolve(request.chain, core).apiHex,
        exchange: request.exchange,
        toBlock: request.toBlock,
        address: EvmAddress.create(request.address, core).checksum,
    };
}
function deserializeRequest$9(jsonRequest, core) {
    return {
        chain: EvmChain.create(jsonRequest.chain, core),
        exchange: jsonRequest.exchange,
        toBlock: jsonRequest.toBlock,
        address: EvmAddress.create(jsonRequest.address, core),
    };
}

/** Get ERC20 token transactions from a contract ordered by block number in descending order. */
var getTokenTransfersOperation = {
    method: 'GET',
    name: 'getTokenTransfers',
    id: 'getTokenTransfers',
    groupName: 'token',
    urlPathPattern: '/erc20/{address}/transfers',
    urlPathParamNames: ['address'],
    urlSearchParamNames: ['chain', 'fromBlock', 'toBlock', 'fromDate', 'toDate', 'limit', 'cursor', 'disableTotal'],
    firstPageIndex: 0,
    getRequestUrlParams: getRequestUrlParams$8,
    serializeRequest: serializeRequest$8,
    deserializeRequest: deserializeRequest$8,
    deserializeResponse: deserializeResponse$8,
};
// Methods
function getRequestUrlParams$8(request, core) {
    return {
        chain: EvmChainResolver.resolve(request.chain, core).apiHex,
        from_block: maybe(request.fromBlock, String),
        to_block: maybe(request.toBlock, String),
        from_date: request.fromDate ? new Date(request.fromDate).toISOString() : undefined,
        to_date: request.toDate ? new Date(request.toDate).toISOString() : undefined,
        limit: maybe(request.limit, String),
        address: EvmAddress.create(request.address, core).lowercase,
        cursor: request.cursor,
        disable_total: request.disableTotal,
    };
}
function deserializeResponse$8(jsonResponse, request, core) {
    var _a;
    return ((_a = jsonResponse.result) !== null && _a !== void 0 ? _a : []).map(function (transfer) {
        return Erc20Transfer.create(__assign(__assign({}, toCamelCase(transfer)), { chain: EvmChainResolver.resolve(request.chain, core), address: EvmAddress.create(transfer.address, core), toAddress: EvmAddress.create(transfer.to_address, core), fromAddress: EvmAddress.create(transfer.from_address, core), value: BigNumber.create(transfer.value), blockTimestamp: new Date(transfer.block_timestamp) }));
    });
}
function serializeRequest$8(request, core) {
    return {
        chain: EvmChainResolver.resolve(request.chain, core).apiHex,
        fromBlock: request.fromBlock,
        toBlock: request.toBlock,
        fromDate: request.fromDate,
        toDate: request.toDate,
        limit: request.limit,
        address: EvmAddress.create(request.address, core).checksum,
        cursor: request.cursor,
        disableTotal: request.disableTotal,
    };
}
function deserializeRequest$8(jsonRequest, core) {
    return {
        chain: EvmChain.create(jsonRequest.chain, core),
        fromBlock: jsonRequest.fromBlock,
        toBlock: jsonRequest.toBlock,
        fromDate: jsonRequest.fromDate,
        toDate: jsonRequest.toDate,
        limit: jsonRequest.limit,
        address: EvmAddress.create(jsonRequest.address, core),
        cursor: jsonRequest.cursor,
        disableTotal: jsonRequest.disableTotal,
    };
}

/** Get token balances for a specific wallet address. */
var getWalletTokenBalancesOperation = {
    method: 'GET',
    name: 'getWalletTokenBalances',
    id: 'getWalletTokenBalances',
    groupName: 'token',
    urlPathPattern: '/{address}/erc20',
    urlPathParamNames: ['address'],
    urlSearchParamNames: ['chain', 'toBlock', 'tokenAddresses'],
    getRequestUrlParams: getRequestUrlParams$7,
    serializeRequest: serializeRequest$7,
    deserializeRequest: deserializeRequest$7,
    deserializeResponse: deserializeResponse$7,
};
// Methods
function getRequestUrlParams$7(request, core) {
    return {
        chain: EvmChainResolver.resolve(request.chain, core).apiHex,
        to_block: maybe(request.toBlock, String),
        token_addresses: maybe(request.tokenAddresses, function (addresses) {
            return addresses.map(function (address) { return EvmAddress.create(address, core).lowercase; });
        }),
        address: EvmAddress.create(request.address, core).lowercase,
    };
}
function deserializeResponse$7(jsonResponse, request, core) {
    return (jsonResponse !== null && jsonResponse !== void 0 ? jsonResponse : []).map(function (token) {
        return Erc20Value.create(token.balance, {
            decimals: token.decimals,
            token: {
                decimals: token.decimals,
                name: token.name,
                symbol: token.symbol,
                contractAddress: token.token_address,
                logo: token.logo,
                thumbnail: token.thumbnail,
                chain: EvmChainResolver.resolve(request.chain, core),
            },
        }, core);
    });
}
function serializeRequest$7(request, core) {
    return {
        chain: EvmChainResolver.resolve(request.chain, core).apiHex,
        tokenAddresses: maybe(request.tokenAddresses, function (addresses) {
            return addresses.map(function (address) { return EvmAddress.create(address, core).checksum; });
        }),
        address: EvmAddress.create(request.address).checksum,
        toBlock: request.toBlock,
    };
}
function deserializeRequest$7(jsonRequest, core) {
    return {
        chain: EvmChain.create(jsonRequest.chain, core),
        tokenAddresses: maybe(jsonRequest.tokenAddresses, function (addresses) {
            return addresses.map(function (address) { return EvmAddress.create(address, core); });
        }),
        address: EvmAddress.create(jsonRequest.address, core),
        toBlock: jsonRequest.toBlock,
    };
}

/** Get ERC20 token transactions ordered by block number in descending order. */
var getWalletTokenTransfersOperation = {
    method: 'GET',
    name: 'getWalletTokenTransfers',
    id: 'getWalletTokenTransfers',
    groupName: 'token',
    urlPathPattern: '/{address}/erc20/transfers',
    urlPathParamNames: ['address'],
    urlSearchParamNames: ['chain', 'fromBlock', 'toBlock', 'fromDate', 'toDate', 'limit', 'cursor', 'disableTotal'],
    firstPageIndex: 0,
    getRequestUrlParams: getRequestUrlParams$6,
    serializeRequest: serializeRequest$6,
    deserializeRequest: deserializeRequest$6,
    deserializeResponse: deserializeResponse$6,
};
// Methods
function getRequestUrlParams$6(request, core) {
    return {
        chain: EvmChainResolver.resolve(request.chain, core).apiHex,
        address: EvmAddress.create(request.address, core).lowercase,
        from_block: maybe(request.fromBlock, String),
        to_block: maybe(request.toBlock, String),
        from_date: request.fromDate ? new Date(request.fromDate).toISOString() : undefined,
        to_date: request.toDate ? new Date(request.toDate).toISOString() : undefined,
        limit: maybe(request.limit, String),
        cursor: request.cursor,
        disable_total: request.disableTotal,
    };
}
function deserializeResponse$6(jsonResponse, request, core) {
    var _a;
    return ((_a = jsonResponse.result) !== null && _a !== void 0 ? _a : []).map(function (transfer) {
        return Erc20Transfer.create(__assign(__assign({}, toCamelCase(transfer)), { chain: EvmChainResolver.resolve(request.chain, core), address: EvmAddress.create(transfer.address, core), toAddress: EvmAddress.create(transfer.to_address, core), fromAddress: EvmAddress.create(transfer.from_address, core), value: BigNumber.create(transfer.value), blockTimestamp: new Date(transfer.block_timestamp) }));
    });
}
function serializeRequest$6(request, core) {
    return {
        chain: EvmChainResolver.resolve(request.chain, core).apiHex,
        address: EvmAddress.create(request.address, core).checksum,
        fromBlock: request.fromBlock,
        toBlock: request.toBlock,
        fromDate: request.fromDate,
        toDate: request.toDate,
        limit: request.limit,
        cursor: request.cursor,
        disableTotal: request.disableTotal,
    };
}
function deserializeRequest$6(jsonRequest, core) {
    return {
        chain: EvmChain.create(jsonRequest.chain, core),
        address: EvmAddress.create(jsonRequest.address, core),
        fromBlock: jsonRequest.fromBlock,
        toBlock: jsonRequest.toBlock,
        fromDate: jsonRequest.fromDate,
        toDate: jsonRequest.toDate,
        limit: jsonRequest.limit,
        cursor: jsonRequest.cursor,
        disableTotal: jsonRequest.disableTotal,
    };
}

/** Get the contents of a transaction by the given transaction hash. */
var getTransactionOperation = {
    method: 'GET',
    name: 'getTransaction',
    id: 'getTransaction',
    groupName: 'transaction',
    isNullable: true,
    urlPathPattern: '/transaction/{transactionHash}',
    urlPathParamNames: ['transactionHash'],
    urlSearchParamNames: ['chain'],
    getRequestUrlParams: getRequestUrlParams$5,
    serializeRequest: serializeRequest$5,
    deserializeRequest: deserializeRequest$5,
    deserializeResponse: deserializeResponse$5,
};
function getRequestUrlParams$5(request, core) {
    return {
        chain: EvmChainResolver.resolve(request.chain, core).apiHex,
        transactionHash: request.transactionHash,
    };
}
function serializeRequest$5(request, core) {
    return {
        chain: EvmChainResolver.resolve(request.chain, core).apiHex,
        transactionHash: request.transactionHash,
    };
}
function deserializeRequest$5(jsonRequest, core) {
    return {
        chain: EvmChain.create(jsonRequest.chain, core),
        transactionHash: jsonRequest.transactionHash,
    };
}
//TODO: I noticed that the docs comes with a type of "string | unknown" which automatically resolves to "unknown". I think we should fix this in the api, casting for now
function deserializeResponse$5(jsonResponse, request, core) {
    var _a;
    return EvmTransaction.create({
        from: jsonResponse.from_address,
        to: jsonResponse.to_address,
        value: jsonResponse.value,
        gasPrice: jsonResponse.gas_price,
        gasUsed: jsonResponse.receipt_gas_used,
        data: jsonResponse.input,
        nonce: jsonResponse.nonce,
        blockHash: jsonResponse.block_hash,
        blockNumber: jsonResponse.block_number,
        blockTimestamp: jsonResponse.block_timestamp,
        index: jsonResponse.transaction_index,
        chain: EvmChainResolver.resolve(request.chain, core),
        hash: jsonResponse.hash,
        gas: jsonResponse.gas,
        cumulativeGasUsed: jsonResponse.receipt_cumulative_gas_used,
        contractAddress: jsonResponse.receipt_contract_address,
        logs: ((_a = jsonResponse.logs) !== null && _a !== void 0 ? _a : []).map(function (log) {
            return EvmTransactionLog.create({
                address: log.address,
                blockHash: log.block_hash,
                blockNumber: +log.block_number,
                data: log.data,
                // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
                topics: [log.topic0, log.topic1, log.topic2, log.topic3],
                transactionHash: log.transaction_hash,
                blockTimestamp: log.block_timestamp,
                logIndex: +log.log_index,
                transactionIndex: +log.transaction_index,
                chain: EvmChainResolver.resolve(request.chain, core),
            }, core);
        }),
        receiptRoot: jsonResponse.receipt_root,
        receiptStatus: jsonResponse.receipt_status,
    }, core);
}

/** Get native transactions ordered by block number in descending order. */
var getWalletTransactionsOperation = {
    method: 'GET',
    name: 'getWalletTransactions',
    id: 'getWalletTransactions',
    groupName: 'transaction',
    urlPathPattern: '/{address}',
    urlPathParamNames: ['address'],
    urlSearchParamNames: ['chain', 'fromBlock', 'toBlock', 'fromDate', 'toDate', 'cursor', 'limit', 'disableTotal'],
    firstPageIndex: 0,
    getRequestUrlParams: getRequestUrlParams$4,
    serializeRequest: serializeRequest$4,
    deserializeRequest: deserializeRequest$4,
    deserializeResponse: deserializeResponse$4,
};
// Methods
function getRequestUrlParams$4(request, core) {
    return {
        chain: EvmChainResolver.resolve(request.chain, core).apiHex,
        from_block: maybe(request.fromBlock, String),
        to_block: maybe(request.toBlock, String),
        from_date: request.fromDate ? new Date(request.fromDate).toISOString() : undefined,
        to_date: request.toDate ? new Date(request.toDate).toISOString() : undefined,
        cursor: request.cursor,
        limit: maybe(request.limit, String),
        address: EvmAddress.create(request.address, core).lowercase,
        disable_total: request.disableTotal,
    };
}
function serializeRequest$4(request, core) {
    return {
        chain: EvmChainResolver.resolve(request.chain, core).apiHex,
        fromBlock: request.fromBlock,
        toBlock: request.toBlock,
        fromDate: request.fromDate,
        toDate: request.toDate,
        cursor: request.cursor,
        limit: request.limit,
        address: EvmAddress.create(request.address, core).checksum,
        disableTotal: request.disableTotal,
    };
}
function deserializeRequest$4(jsonRequest, core) {
    return {
        chain: EvmChain.create(jsonRequest.chain, core),
        fromBlock: jsonRequest.fromBlock,
        toBlock: jsonRequest.toBlock,
        fromDate: jsonRequest.fromDate,
        toDate: jsonRequest.toDate,
        cursor: jsonRequest.cursor,
        limit: jsonRequest.limit,
        address: EvmAddress.create(jsonRequest.address, core),
        disableTotal: jsonRequest.disableTotal,
    };
}
function deserializeResponse$4(jsonResponse, request, core) {
    var _a;
    return ((_a = jsonResponse.result) !== null && _a !== void 0 ? _a : []).map(function (transfer) {
        return EvmTransaction.create({
            cumulativeGasUsed: transfer.receipt_cumulative_gas_used,
            gasPrice: transfer.gas_price,
            gasUsed: transfer.receipt_gas_used,
            index: +transfer.transaction_index,
            contractAddress: transfer.receipt_contract_address,
            receiptRoot: transfer.receipt_root,
            receiptStatus: +transfer.receipt_status,
            chain: EvmChainResolver.resolve(request.chain, core),
            data: transfer.input,
            from: transfer.from_address,
            hash: transfer.hash,
            nonce: transfer.nonce,
            value: transfer.value,
            blockHash: transfer.block_hash,
            blockNumber: +transfer.block_number,
            blockTimestamp: new Date(transfer.block_timestamp),
            gas: transfer.gas ? BigNumber.create(transfer.gas) : null,
            to: transfer.to_address ? transfer.to_address : null,
        }, core);
    });
}

/** Get native transactions ordered by block number in descending order. */
var getWalletTransactionsVerboseOperation = {
    method: 'GET',
    name: 'getWalletTransactionsVerbose',
    id: 'getWalletTransactionsVerbose',
    groupName: 'transaction',
    urlPathPattern: '/{address}/verbose',
    urlPathParamNames: ['address'],
    urlSearchParamNames: ['chain', 'fromBlock', 'toBlock', 'fromDate', 'toDate', 'cursor', 'limit', 'disableTotal'],
    firstPageIndex: 0,
    getRequestUrlParams: getRequestUrlParams$3,
    serializeRequest: serializeRequest$3,
    deserializeRequest: deserializeRequest$3,
    deserializeResponse: deserializeResponse$3,
};
// Methods
function getRequestUrlParams$3(request, core) {
    return {
        chain: EvmChainResolver.resolve(request.chain, core).apiHex,
        from_block: maybe(request.fromBlock, String),
        to_block: maybe(request.toBlock, String),
        from_date: request.fromDate ? new Date(request.fromDate).toISOString() : undefined,
        to_date: request.toDate ? new Date(request.toDate).toISOString() : undefined,
        cursor: request.cursor,
        limit: maybe(request.limit, String),
        address: EvmAddress.create(request.address, core).lowercase,
        disable_total: request.disableTotal,
    };
}
function serializeRequest$3(request, core) {
    return {
        chain: EvmChainResolver.resolve(request.chain, core).apiHex,
        fromBlock: request.fromBlock,
        toBlock: request.toBlock,
        fromDate: request.fromDate,
        toDate: request.toDate,
        cursor: request.cursor,
        limit: request.limit,
        address: EvmAddress.create(request.address, core).checksum,
        disableTotal: request.disableTotal,
    };
}
function deserializeRequest$3(jsonRequest, core) {
    return {
        chain: EvmChain.create(jsonRequest.chain, core),
        fromBlock: jsonRequest.fromBlock,
        toBlock: jsonRequest.toBlock,
        fromDate: jsonRequest.fromDate,
        toDate: jsonRequest.toDate,
        cursor: jsonRequest.cursor,
        limit: jsonRequest.limit,
        address: EvmAddress.create(jsonRequest.address, core),
        disableTotal: jsonRequest.disableTotal,
    };
}
function deserializeResponse$3(jsonResponse, request, core) {
    var _a;
    return ((_a = jsonResponse.result) !== null && _a !== void 0 ? _a : []).map(function (transfer) {
        var _a;
        return EvmTransaction.create({
            cumulativeGasUsed: transfer.receipt_cumulative_gas_used,
            gasPrice: transfer.gas_price,
            gasUsed: transfer.receipt_gas_used,
            index: +transfer.transaction_index,
            contractAddress: transfer.receipt_contract_address,
            receiptRoot: transfer.receipt_root,
            receiptStatus: +transfer.receipt_status,
            chain: EvmChainResolver.resolve(request.chain, core),
            data: transfer.input,
            from: EvmAddress.create(transfer.from_address, core),
            hash: transfer.hash,
            nonce: transfer.nonce,
            value: transfer.value,
            blockHash: transfer.block_hash,
            blockNumber: +transfer.block_number,
            blockTimestamp: new Date(transfer.block_timestamp),
            gas: BigNumber.create(transfer.gas),
            to: EvmAddress.create(transfer.to_address, core),
            logs: ((_a = transfer.logs) !== null && _a !== void 0 ? _a : []).map(function (log) {
                return EvmTransactionLog.create({
                    logIndex: +log.log_index,
                    transactionHash: log.transaction_hash,
                    transactionIndex: +log.transaction_index,
                    address: log.address,
                    data: log.data,
                    topics: [log.topic0, log.topic1, log.topic2, log.topic3],
                    blockHash: log.block_hash,
                    blockNumber: +log.block_number,
                    blockTimestamp: transfer.block_timestamp,
                    chain: EvmChainResolver.resolve(request.chain, core),
                }, core);
            }),
        }, core);
    });
}

/** Run a given function of a contract ABI and retrieve readonly data. */
var runContractFunctionOperation = {
    method: 'POST',
    name: 'runContractFunction',
    id: 'runContractFunction',
    groupName: 'utils',
    urlPathParamNames: ['address'],
    urlSearchParamNames: ['chain', 'functionName'],
    urlPathPattern: '/{address}/function',
    bodyType: 'properties',
    bodyParamNames: ['abi', 'params'],
    getRequestUrlParams: getRequestUrlParams$2,
    getRequestBody: getRequestBody,
    deserializeResponse: deserializeResponse$2,
    serializeRequest: serializeRequest$2,
    deserializeRequest: deserializeRequest$2,
};
// Methods
function getRequestUrlParams$2(request, core) {
    return {
        address: EvmAddress.create(request.address, core).lowercase,
        chain: EvmChainResolver.resolve(request.chain, core).apiHex,
        function_name: request.functionName,
    };
}
function getRequestBody(request) {
    return {
        abi: request.abi,
        params: request.params,
    };
}
function deserializeResponse$2(jsonResponse) {
    return jsonResponse;
}
function serializeRequest$2(request, core) {
    return {
        address: EvmAddress.create(request.address, core).checksum,
        chain: EvmChainResolver.resolve(request.chain, core).apiHex,
        functionName: request.functionName,
        abi: request.abi,
        params: request.params,
    };
}
function deserializeRequest$2(jsonRequest, core) {
    return {
        address: EvmAddress.create(jsonRequest.address, core),
        chain: EvmChain.create(jsonRequest.chain, core),
        functionName: jsonRequest.functionName,
        abi: jsonRequest.abi,
        params: jsonRequest.params,
    };
}

/** Get the endpoint price list for rate limits and cost. */
var endpointWeightsOperation = {
    method: 'GET',
    name: 'endpointWeights',
    id: 'endpointWeights',
    groupName: 'utils',
    urlPathPattern: '/info/endpointWeights',
    getRequestUrlParams: getRequestUrlParams$1,
    deserializeRequest: deserializeRequest$1,
    serializeRequest: serializeRequest$1,
    deserializeResponse: deserializeResponse$1,
};
// Methods
function getRequestUrlParams$1() {
    return {};
}
function serializeRequest$1() {
    return undefined;
}
function deserializeRequest$1() {
    return {};
}
function deserializeResponse$1(jsonResponse) {
    return jsonResponse;
}

/** Get the current version of the Moralis Web3 API. */
var web3ApiVersionOperation = {
    method: 'GET',
    name: 'web3ApiVersion',
    id: 'web3ApiVersion',
    groupName: 'utils',
    urlPathPattern: '/web3/version',
    deserializeRequest: deserializeRequest,
    serializeRequest: serializeRequest,
    getRequestUrlParams: getRequestUrlParams,
    deserializeResponse: deserializeResponse,
};
// Methods
function getRequestUrlParams() {
    return {};
}
function serializeRequest() {
    return undefined;
}
function deserializeRequest() {
    return {};
}
function deserializeResponse(jsonResponse) {
    return jsonResponse;
}

var operations = [
    endpointWeightsOperation,
    getBlockOperation,
    getContractEventsOperation,
    getContractLogsOperation,
    getContractNFTsOperation,
    getDateToBlockOperation,
    getMultipleNFTsOperation,
    getNativeBalanceOperation,
    getNativeBalancesForAddressesOperation,
    getNFTContractMetadataOperation,
    getNFTContractTransfersOperation,
    getNFTLowestPriceOperation,
    getNFTMetadataOperation,
    getNFTOwnersOperation,
    getNFTTokenIdOwnersOperation,
    getNFTTradesOperation,
    getNFTTransfersByBlockOperation,
    getNFTTransfersFromToBlockOperation,
    getNFTTransfersOperation,
    getPairAddressOperation,
    getPairReservesOperation,
    getTokenAllowanceOperation,
    getTokenMetadataBySymbolOperation,
    getTokenMetadataOperation,
    getTokenPriceOperation,
    getTokenTransfersOperation,
    getTransactionOperation,
    getWalletNFTCollectionsOperation,
    getWalletNFTsOperation,
    getWalletNFTTransfersOperation,
    getWalletTokenBalancesOperation,
    getWalletTokenTransfersOperation,
    getWalletTransactionsOperation,
    getWalletTransactionsVerboseOperation,
    resolveAddressOperation,
    resolveDomainOperation,
    reSyncMetadataOperation,
    runContractFunctionOperation,
    searchNFTsOperation,
    syncNFTContractOperation,
    uploadFolderOperation,
    web3ApiVersionOperation,
];

export { CommonEvmUtils, CommonEvmUtilsConfig, CommonEvmUtilsConfigSetup, Erc20Token, Erc20Transfer, Erc20Value, EvmAddress, EvmBlock, EvmBlockDate, EvmChain, EvmChainParser, EvmChainResolver, EvmEvent, EvmNative, EvmNft, EvmNftCollection, EvmNftMetadata, EvmNftTrade, EvmNftTransfer, EvmSignature, EvmSimpleBlock, EvmTransaction, EvmTransactionLog, endpointWeightsOperation, getBlockOperation, getContractEventsOperation, getContractLogsOperation, getContractNFTsOperation, getDateToBlockOperation, getMultipleNFTsOperation, getNFTContractMetadataOperation, getNFTContractTransfersOperation, getNFTLowestPriceOperation, getNFTMetadataOperation, getNFTOwnersOperation, getNFTTokenIdOwnersOperation, getNFTTradesOperation, getNFTTransfersByBlockOperation, getNFTTransfersFromToBlockOperation, getNFTTransfersOperation, getNativeBalanceOperation, getNativeBalancesForAddressesOperation, getPairAddressOperation, getPairReservesOperation, getTokenAllowanceOperation, getTokenMetadataBySymbolOperation, getTokenMetadataOperation, getTokenPriceOperation, getTokenTransfersOperation, getTransactionOperation, getWalletNFTCollectionsOperation, getWalletNFTTransfersOperation, getWalletNFTsOperation, getWalletTokenBalancesOperation, getWalletTokenTransfersOperation, getWalletTransactionsOperation, getWalletTransactionsVerboseOperation, operations, reSyncMetadataOperation, resolveAddressOperation, resolveDomainOperation, runContractFunctionOperation, searchNFTsOperation, syncNFTContractOperation, uploadFolderOperation, web3ApiVersionOperation };
