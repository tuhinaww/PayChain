import * as _moralisweb3_common_core from '@moralisweb3/common-core';
import _moralisweb3_common_core__default, { MoralisData, Core, Config, EvmAddressFormat, EvmChainable, EvmChainIdFormat, MoralisDataObject, DateInput, BigNumberish, BigNumber, MoralisDataObjectValue, Module, Camelize, ResponseAdapter, Operation, PaginatedResponseAdapter, PaginatedOperation, ConfigKey } from '@moralisweb3/common-core';
import { Signature } from '@ethersproject/bytes';

/**
 * Moralis representation of a native chain currency.
 */
interface EvmNativeCurrency {
    name: string;
    symbol: string;
    decimals: number;
}
interface EvmChainListDataEntry {
    name: string;
    title?: string;
    chain: string;
    icon?: string;
    rpc: string[];
    faucets: string[];
    nativeCurrency: EvmNativeCurrency;
    infoURL: string;
    shortName: string;
    chainId: number;
    network?: string;
    networkId: number;
    slip44?: number;
    ens?: {
        registry: string;
    };
    explorers?: {
        name: string;
        url: string;
        standard: 'EIP3091' | 'none';
        icon?: string;
    }[];
    parent?: {
        type: 'L2' | 'shard';
        chain: 'eip155-3' | 'eip155-4' | 'eip155-5' | 'eip155-90' | 'eip155-100' | 'eip155-1' | 'eip155-100' | 'eip155-250' | 'eip155-248' | 'eip155-43114' | 'eip155-900' | 'eip155-43113' | 'eip155-100000' | 'eip155-110000' | 'eip155-2099156' | 'eip155-16658437';
        bridges?: {
            url: string;
        }[];
    };
    status?: 'deprecated' | 'incubating' | 'active';
    features?: EvmChainFeature[];
    redFlags?: string[];
}
interface EvmChainFeature {
    name: string;
}

/**
 * This can be any valid EVM address, formatted as lowercase or checksum.
 * @example "0xfb6916095ca1df60bb79ce92ce3ea74c37c5d359"
 * @example "0xfB6916095ca1df60bB79Ce92cE3Ea74c37c5d359"
 */
type EvmAddressInput = string;
/**
 * Valid input for a new EvmAddress instance.
 * This can be an existing EvmAddress or a valid address string as lowercase, or checksum format.
 */
type EvmAddressish = EvmAddress | EvmAddressInput;
/**
 * A representation of an address on the EVM network.
 *
 * Use this class any time you work with an address, as it will provide utilities to validate the address,
 * and format it to lowercase and checksum format.
 *
 * @category DataType
 */
declare class EvmAddress implements MoralisData {
    private readonly config;
    /**
     * @returns EvmAddress instance of the zero address: "0x0000000000000000000000000000000000000000"
     * @example `EvmAddress.ZERO_ADDRESS`
     */
    static get ZERO_ADDRESS(): EvmAddress;
    /**
     * Create a new instance of EvmAddress from any valid address input
     *
     * @example
     * ```
     * const address = EvmAddress.create("0xfb6916095ca1df60bb79ce92ce3ea74c37c5d359")
     * const address = EvmAddress.create("0xfB6916095ca1df60bB79Ce92cE3Ea74c37c5d359")
     * const address = EvmAddress.ZERO_ADDRESS
     * ```
     */
    static create(address: EvmAddressish, core?: Core): EvmAddress;
    /**
     * Internal reference of the address in checksum format
     */
    private _value;
    constructor(address: EvmAddressInput, config: Config);
    private static parse;
    /**
     * Check the equality between two Evm addresses
     * @example `EvmAddress.equals("0xfB6916095ca1df60bB79Ce92cE3Ea74c37c5d359", "0xfb6916095ca1df60bb79ce92ce3ea74c37c5d359")`
     */
    static equals(addressA: EvmAddressish, addressB: EvmAddressish): boolean;
    /**
     * Checks the equality of the current address with another evm address
     * @example `address.equals("0xfb6916095ca1df60bb79ce92ce3ea74c37c5d359")`
     */
    equals(address: EvmAddressish): boolean;
    /**
     * Formats the address to a specific format.
     * If no formatStyle is provided as argument, it will use the `formatEvmAddress` set in the config.
     * @example `address.format() // "0xfB6916095ca1df60bB79Ce92cE3Ea74c37c5d359"`
     */
    format(style?: EvmAddressFormat): string;
    /**
     * @returns the address value in checksum (EIP-55) format (see https://eips.ethereum.org/EIPS/eip-55)
     * @example `address.checksum // "0xfB6916095ca1df60bB79Ce92cE3Ea74c37c5d359"`
     */
    get checksum(): string;
    /**
     * @returns the address value in lowercase format
     * @example `address.lowercase // "0xfb6916095ca1df60bb79ce92ce3ea74c37c5d359"`
     */
    get lowercase(): string;
}

/**
 * This can be an hex-string, ChainName or a number
 */
type InputChainId = string | number;
/**
 * This can be any valid {@link EvmChain} or {@link InputChainId}.
 */
type EvmChainish = EvmChain | InputChainId;

/**
 * The EvmChain class is a MoralisData that references to a EVM chain
 * @category DataType
 */
declare class EvmChain implements MoralisData, EvmChainable {
    private readonly config;
    /**
     * Returns ETHEREUM chain
     *
     * @example EvmChain.ETHEREUM
     */
    static get ETHEREUM(): EvmChain;
    /**
     * Returns GOERLI chain
     *
     * @example EvmChain.GOERLI
     */
    static get GOERLI(): EvmChain;
    /**
     * Returns SEPOLIA chain
     *
     * @example EvmChain.SEPOLIA
     */
    static get SEPOLIA(): EvmChain;
    /**
     * Returns POLYGON chain
     *
     * @example EvmChain.POLYGON
     */
    static get POLYGON(): EvmChain;
    /**
     * Returns MUMBAI chain
     *
     * @example EvmChain.MUMBAI
     */
    static get MUMBAI(): EvmChain;
    /**
     * Returns BSC chain
     *
     * @example EvmChain.BSC
     */
    static get BSC(): EvmChain;
    /**
     * Returns BSC_TESTNET chain
     *
     * @example EvmChain.BSC_TESTNET
     */
    static get BSC_TESTNET(): EvmChain;
    /**
     * Returns AVALANCHE chain
     *
     * @example EvmChain.AVALANCHE
     */
    static get AVALANCHE(): EvmChain;
    /**
     * Returns FUJI chain
     *
     * @example EvmChain.FUJI
     */
    static get FUJI(): EvmChain;
    /**
     * Returns FANTOM chain
     *
     * @example EvmChain.FANTOM
     */
    static get FANTOM(): EvmChain;
    /**
     * Returns CRONOS chain
     *
     * @example EvmChain.CRONOS
     */
    static get CRONOS(): EvmChain;
    /**
     * Returns CRONOS_TESTNET chain
     *
     * @example EvmChain.CRONOS_TESTNET
     */
    static get CRONOS_TESTNET(): EvmChain;
    /**
     * Returns PALM chain
     *
     * @example EvmChain.PALM
     */
    static get PALM(): EvmChain;
    /**
     * Returns ARBITRUM chain
     *
     * @example EvmChain.ARBITRUM
     */
    static get ARBITRUM(): EvmChain;
    /**
     * Create a new instance of EvmChain from any valid address input.
     *
     * @example
     * ```ts
     * const chain = EvmChain.create(1)
     * const chain = EvmChain.create("0x3")
     * ```
     */
    static create(chain: EvmChainish, core?: Core): EvmChain;
    private _value;
    private _chainlistData;
    private constructor();
    private _getChainlistData;
    /**
     * Compares if 2 chains are equal, based on the chainId
     *
     * @param chainA - The first chain to compare
     * @param chainB - The second chain to compare
     *
     * @returns true if the chains are equal, false otherwise
     * @example
     * ```ts
     * EvmChain.equals("1", "0x1")
     * ```
     */
    static equals(chainA: EvmChainish, chainB: EvmChainish): boolean;
    /**
     * Compares if the current chain is equal to the provided chain, based on the chainId
     * @param chain - The chain to compare to
     * @returns true if the chains are equal, false otherwise
     * @example
     * ```ts
     * chain.equals(EvmChain.ETHEREUM)
     * ```
     */
    equals(chain: EvmChainish): boolean;
    /**
     * Formats the chain to the given output; in decimal value or as hex-string.
     * The default formatting can be set in MoralisConfig
     * @param _formatStyle - The output format to use
     * @example chain.format() // 1
     * @example chain.format('hex') // "0x1"
     * @example chain.format('decimal') // 1
     *
     * @returns The formatted chain
     */
    format(_formatStyle?: EvmChainIdFormat): string | number;
    /**
     * Displays the chain hex-string representation of the chain and also the chain name if not null
     *
     * @example chain.display() // "Ethereum (0x1)" | "0x1"
     */
    display(): string;
    /**
     * This function returns the explorer url of a block, transaction, account or token.
     *
     * @param value - An object containing the `block`, `transaction`, `account` or `erc20` to get the explorer url for.
     *
     * @example chain.getExplorerUrl({ block: 'block_here' }) // "https://etherscan.io/block/block_here"
     * @example chain.getExplorerUrl({ transaction: 'some_transaction' }) // "https://etherscan.io/tx/some_transaction"
     * @example chain.getExplorerUrl({ account: 'accoun_here' }) // "https://etherscan.io/address/accoun_here"
     * @example chain.getExplorerUrl({ erc20: 'token_here' }) // "https://etherscan.io/token/token_here"
     */
    getExplorerPath(value: {
        block: string;
    } | {
        transaction: string;
    } | {
        account: string;
    } | {
        erc20: string;
    }): string | null;
    /**
     * Returns the decimal representation of the chain
     * @example chain.decimal // 1
     */
    get decimal(): number;
    /**
     * Returns the hex-string representation of the chain
     * @example chain.hex // "0x1"
     */
    get hex(): string;
    /**
     * Validate and cast to api compatible hex
     *
     * @example chain.apiHex // "0x1"
     */
    get apiHex(): "0x1" | "0x5" | "0xaa36a7" | "0x89" | "0x13881" | "0x38" | "0x61" | "0xa86a" | "0xa869" | "0xfa" | "0x19" | "0x152" | "0x2a15c308d" | "0xa4B1";
    /**
     * Returns the name of the chain
     * @example chain.name // "Ethereum"
     */
    get name(): string | undefined;
    /**
     * Returns the currency of the chain
     * @returns The cuurrency of the chain or undefined if not found
     *
     * @example chain.currency // EvmNativeCurrency
     */
    get currency(): EvmNativeCurrency | undefined;
    /**
     * Returns the rpc Urls of the chain
     *
     * @example chain.rpcUrls // ["https://mainnet.infura.io/v3/<infura-key>"]
     */
    get rpcUrls(): string[] | undefined;
    /**
     * Returns the explorer Urls of the chain
     *
     * @example chain.explorerUrls // ["https://etherscan.io/"]
     */
    get explorer(): {
        name: string;
        url: string;
        standard: "EIP3091" | "none";
        icon?: string | undefined;
    } | null;
}

declare class EvmChainParser {
    static parse(chain: InputChainId): string;
}

/**
 * Valid ERC20 token input
 *
 * @example
 * ```ts
 * const input = {
 * contractAddress: "0x0a385f86059e0b2a048171d78afd1f38558121f3",
 * name: "USD Coin on BSC",
 * symbol: "USDC",
 * logo: null,
 * logoHash: null,
 * thumbnail: null,
 * decimals: "6",
 * chain: 1,
 * }
 * ```
 */
interface Erc20Input {
    decimals: number | string;
    name: string;
    symbol: string;
    contractAddress: EvmAddressish;
    chain: EvmChainish;
    logo?: string | null;
    logoHash?: string | null;
    thumbnail?: string | null;
}
/**
 * This is the return type of the processed ERC20 token
 */
interface Erc20Data {
    decimals: number;
    name: string;
    symbol: string;
    contractAddress: EvmAddress;
    chain: EvmChain;
    logo?: string | null;
    logoHash?: string | null;
    thumbnail?: string | null;
}

/**
 * This can be any valid {@link Erc20Input} or {@link Erc20Token}.
 */
type Erc20Tokenish = Erc20Input | Erc20Token;
/**
 * The Erc20Token class is a MoralisData that references to a Erc20 Token
 * It holds data about the data and metadata of an Erc20 token
 *
 * @category DataType
 */
declare class Erc20Token implements MoralisDataObject {
    /**
     *  Create a new instance of Erc20Token from any valid Erc20Token input
     *
     * @param value - the Erc20Tokenish type
     * @param core - The MoralisCore instance
     * @example
     * ```ts
     * const token = Erc20Token.create(value);
     * ```
     */
    static create(value: Erc20Tokenish, core?: _moralisweb3_common_core__default): Erc20Token;
    private readonly _value;
    private constructor();
    static parse: (value: Erc20Input, core: _moralisweb3_common_core__default) => Erc20Data;
    /**
     * Compares two Erc20Token instances. This checks if the chain and contractAddress of both tokens are equal.
     *
     * @param valueA - the first Erc20Token to compare
     * @param valueB - the second Erc20Token to compare
     * @returns true if the two Erc20Tokens are equal
     * @example
     * ```ts
     * Erc20Token.equals(valueA, valueB);
     * ```
     */
    static equals(valueA: Erc20Tokenish, valueB: Erc20Tokenish): boolean;
    /**
     * Compares Erc20Token instance to current instance
     *
     * @param value - the Erc20Tokenish to compare
     * @returns true if the Erc20Token is equals given token
     * @example
     * ```ts
     * token.equals(value);
     * ```
     */
    equals(value: Erc20Tokenish): boolean;
    /**
     * Returns the token as JSON
     *
     * @returns the Erc20Token as a JSON object
     * @example
     * ```ts
     * token.toJSON();
     * ```
     */
    toJSON(): {
        contractAddress: string;
        chain: string | number;
        decimals: number;
        name: string;
        symbol: string;
        logo?: string | null | undefined;
        logoHash?: string | null | undefined;
        thumbnail?: string | null | undefined;
    };
    /**
     * Returns the token as JSON
     *
     * @returns the Erc20Token as a JSON object
     * @example
     * ```ts
     * token.format();
     * ```
     */
    format(): {
        contractAddress: string;
        chain: string | number;
        decimals: number;
        name: string;
        symbol: string;
        logo?: string | null | undefined;
        logoHash?: string | null | undefined;
        thumbnail?: string | null | undefined;
    };
    /**
     * Returns the processed Erc20Token.
     *
     * @returns the Erc20Token value
     * @example
     * ```ts
     * token.result;
     *  ```
     */
    get result(): Erc20Data;
    /**
     * @returns the decimals of the token.
     *
     * @example
     * ```ts
     * token.decimals;
     * ```
     */
    get decimals(): number;
    /**
     * @returns The name of the token.
     *
     * @example
     * ```ts
     * token.name;
     * ```
     */
    get name(): string;
    /**
     * @returns The symbol of the token.
     *
     * @example
     * ```ts
     * token.symbol;
     * ```
     */
    get symbol(): string;
    /**
     * @returns The contract address of the token.
     *
     * @example
     * ```ts
     * token.contractAddress;
     * ```
     */
    get contractAddress(): EvmAddress;
    /**
     * @returns The chain of the token.
     *
     * @example
     * ```ts
     * token.chain;
     * ```
     */
    get chain(): EvmChain;
    /**
     * @returns The logo of the token.
     *
     * @example
     * ```ts
     * token.logo;
     * ```
     */
    get logo(): string | null | undefined;
    /**
     * @returns The logo hash of the token.
     *
     * @example
     * ```ts
     * token.logoHash;
     * ```
     */
    get logoHash(): string | null | undefined;
    /**
     * @returns The thumbnail of the token.
     *
     * @example
     * ```ts
     * token.thumbnail;
     * ```
     */
    get thumbnail(): string | null | undefined;
}

/**
 * This can be any object with valid erc20 transfer data.
 * @example
 * ```
 * const input = {
 *  chain: 1,
 *  address: "0x057Ec652A4F150f7FF94f089A38008f49a0DF88e",
 *  toAddress: "0x62AED87d21Ad0F3cdE4D147Fdcc9245401Af0044",
 *  fromAddress: "0xd4a3BebD824189481FC45363602b83C9c7e9cbDf",
 *  value: "650000000000000000",
 *  blockTimestamp: "2021-04-02T10:07:54.000Z",
 *  blockHash: "0x0372c302e3c52e8f2e15d155e2c545e6d802e479236564af052759253b20fd86",
 *  blockNumber: "12526958",
 *  transactionHash: "0x2d30ca6f024dbc1307ac8a1a44ca27de6f797ec22ef20627a1307243b0ab7d09"
 *  transactionIndex: 3;
 *  logIndex: 2
 * }
 * ```
 */
interface Erc20TransferInput {
    chain: EvmChainish;
    transactionHash: string;
    address: EvmAddressish;
    blockTimestamp: DateInput;
    blockNumber: BigNumberish;
    blockHash: string;
    toAddress: EvmAddressish;
    fromAddress: EvmAddressish;
    value: BigNumberish;
    transactionIndex: number;
    logIndex: number;
}
/**
 * This is the return type of Erc20Transfer
 */
interface Erc20TransferData {
    chain: EvmChain;
    transactionHash: string;
    address: EvmAddress;
    blockTimestamp: DateInput;
    blockNumber: BigNumberish;
    blockHash: string;
    toAddress: EvmAddress;
    fromAddress: EvmAddress;
    value: BigNumber;
    transactionIndex: number;
    logIndex: number;
}

/**
 * Valid input for a new Erc20Transfer instance.
 * This can be an existing {@link Erc20Transfer} or a valid {@link Erc20TransferInput} object
 */
type Erc20Transferish = Erc20TransferInput | Erc20Transfer;
/**
 * The Erc20Transfer is a representation of an Erc20 token transfer.
 *
 * @category DataType
 */
declare class Erc20Transfer implements MoralisDataObject {
    /**
     * Create a new instance of Erc20Transfer from any valid input
     * @param data - the Erc20Transferish type
     * @example
     * ```
     * const transfer = Erc20Transfer.create(data);
     *```
     */
    static create(data: Erc20Transferish): Erc20Transfer;
    private _data;
    constructor(data: Erc20TransferInput);
    static parse: (data: Erc20TransferInput) => Erc20TransferData;
    /**
     * Check the equality between two Erc20 transfers
     * @param dataA - The first transfer to compare
     * @param dataB - The second transfer to compare
     * @example Erc20Transfer.equals(dataA, dataB)
     * @returns true if the transfers are equal, false otherwise
     */
    static equals(dataA: Erc20Transferish, dataB: Erc20Transferish): boolean;
    /**
     * Checks the equality of the current trnasfer with another erc20 trnasfer
     * @param data - the transfer to compare with
     * @example transfer.equals(data)
     * @returns true if the transfers are equal, false otherwise
     */
    equals(data: Erc20Transferish): boolean;
    /**
     * @returns a JSON represention of the transfer.
     * @example transfer.toJSON()
     */
    toJSON(): {
        chain: string | number;
        address: string;
        blockNumber: string;
        toAddress: string;
        fromAddress: string;
        value: string;
        transactionHash: string;
        blockTimestamp: _moralisweb3_common_core.DateInput;
        blockHash: string;
        transactionIndex: number;
        logIndex: number;
    };
    /**
     * @returns a JSON represention of the transfer.
     * @example transfer.format()
     */
    format(): {
        chain: string | number;
        address: string;
        blockNumber: string;
        toAddress: string;
        fromAddress: string;
        value: string;
        transactionHash: string;
        blockTimestamp: _moralisweb3_common_core.DateInput;
        blockHash: string;
        transactionIndex: number;
        logIndex: number;
    };
    /**
     * @returns all the data without casting it to JSON.
     * @example transfer.result
     */
    get result(): Erc20TransferData;
    /**
     * @returns the address of the tranfer
     * @example transfer.address // EvmAddress
     */
    get address(): EvmAddress;
    /**
     * @returns the block hash of the tranfer
     * @example transfer.blockHash // "0x0372c302e3c52e8f2e15d155e2c545e6d802e479236564af052759253b20fd86"
     */
    get blockHash(): string;
    /**
     * @returns the block number of the tranfer
     * @example transfer.blockNumber // BigNumber
     */
    get blockNumber(): _moralisweb3_common_core.BigNumberish;
    /**
     * @returns the block timestamp of the tranfer
     * @example transfer.blockTimestamp // Date
     */
    get blockTimestamp(): _moralisweb3_common_core.DateInput;
    /**
     * @returns the chain of the tranfer
     * @example transfer.chain // EvmChain
     */
    get chain(): EvmChain;
    /**
     * @returns the from address of the tranfer
     * @example transfer.fromAddress // EvmAddress
     */
    get fromAddress(): EvmAddress;
    /**
     * @returns the to address of the tranfer
     * @example transfer.toAddress // EvmAddress
     */
    get toAddress(): EvmAddress;
    /**
     * @returns the transaction hash of the tranfer
     * @example transfer.transactionHash // "0x0372c302e3c52e8f2e15d155e2c545e6d802e479236564af052759253b20fd86"
     */
    get transactionHash(): string;
    /**
     * @returns the value of the tranfer
     * @example transfer.value // BigNumber
     */
    get value(): BigNumber;
    /**
     * @returns the transactionIndex of the tranfer
     * @example transfer.transactionIndex // 3
     */
    get transactionIndex(): number;
    /**
     * @returns the logIndex of the tranfer
     * @example transfer.logIndex // 2
     */
    get logIndex(): number;
}

/**
 * {@link @moralisweb3/common-core!BigNumberish} type for the amount of tokens
 */
type Erc20ValueInputAmount = BigNumberish;
/**
 * This is a number or a string that represents the decimals of tokens
 */
type Erc20ValueInputDecimals = number | string;
/**
 * Valid input for a new Erc20Value instance.
 * This can be an existing {@link Erc20Value} or a valid {@link Erc20ValueInputAmount} object
 */
type Erc20Valueish = Erc20ValueInputAmount | Erc20Value;
/**
 * This is the return type of the processed Erc20Value
 */
type Erc20ValueData = {
    amount: BigNumber;
    decimals: number;
};
/**
 * The options for the Erc20Value class
 */
type Erc20Options = {
    decimals?: Erc20ValueInputDecimals;
    token?: Erc20Tokenish;
};
/**
 * The Erc20Value class is a MoralisData that references to a the value of an Erc20Token
 * It holds data about the data about the amount of tokens and the number of decimals.
 *
 * @category DataType
 */
declare class Erc20Value implements MoralisData {
    /**
     * Create a new instance of Erc20Value from any valid input
     * @param value - The value to create
     * @param options - The options for the token
     * @param core - The MoralisCore instance
     * @example Erc20Value.create(1000, { decimals: 3 });
     * @returns The created value
     * @throws CoreError if the value is invalid
     */
    static create(value: Erc20Valueish, options?: Erc20Options, core?: _moralisweb3_common_core__default): Erc20Value;
    private _value;
    private _token?;
    constructor(amount: Erc20ValueInputAmount, options?: Erc20Options, core?: _moralisweb3_common_core__default);
    static parse: ({ amount, decimals, token, }: {
        amount: Erc20ValueInputAmount;
        decimals: Erc20ValueInputDecimals;
        token?: Erc20Tokenish | undefined;
    }) => Erc20ValueData;
    /**
     * Compares two Erc20Valueish instances.
     * @param valueA - The first value to compare
     * @param valueB - The second value to compare
     * @returns True if the values are equal
     * @example
     * ```ts
     * const valueA = Erc20Value.create(1000, { decimals: 3 });
     * const valueB = Erc20Value.create(10000, { decimals: 4 });
     * Erc20Value.equals(valueA, valueB); // true
     * ```
     */
    static equals(valueA: Erc20Valueish, valueB: Erc20Valueish): boolean;
    /**
     * Compares Erc20Value with current instance.
     * @param value - The value to compare
     * @returns True if the values are equal
     * @example value.equals(valueA);
     */
    equals(value: Erc20Valueish): boolean;
    /**
     * Convert the value to a number
     * @returns the value in number format
     * @example value.toNumber();
     */
    toNumber(): number;
    /**
     * Convert the value to a string
     * @returns the value in string format
     * @example value.toString();
     */
    toString(): string;
    /**
     * Displays the token in text format
     * @returns the value and also the token symbol if available
     * @example value.display();
     */
    display: () => string;
    /**
     * Convert the value to a string
     * @returns the value in string format
     * @example value.format();
     */
    format(): string;
    /**
     * Displays the token in JSON format
     * @returns the value and also the token if available
     * @example value.toJSON();
     */
    toJSON(): {
        value: string;
        token: {
            contractAddress: string;
            chain: string | number;
            decimals: number;
            name: string;
            symbol: string;
            logo?: string | null | undefined;
            logoHash?: string | null | undefined;
            thumbnail?: string | null | undefined;
        };
    } | {
        value: string;
        token?: undefined;
    };
    /**
     * @returns the token decimals
     * @example value.decimals; // 15
     */
    get decimals(): number;
    /**
     * @returns the token amount
     * @example value.amount; // BigNumber
     */
    get amount(): BigNumber;
    /**
     * @returns the token value
     * @example value.value; // "1000"
     */
    get value(): string;
    /**
     * @returns the token
     * @example value.token; // Erc20Token
     */
    get token(): Erc20Token | null;
}

/**
 * Type containing valid EVM native units
 */
type EvmNativeUnit = 'ether' | 'finney' | 'szabo' | 'gwei' | 'mwei' | 'kwei' | 'wei';
/**
 * A valid {@link EvmNativeUnit} or a number type
 */
type UnitOrDecimals = EvmNativeUnit | number;
/**
 * This is any valid {@link @moralisweb3/common-core!BigNumberish} value
 */
type InputEvmNative = BigNumberish;
/**
 * Valid input for a new EvmNative instance.
 * This can be an existing {@link EvmNative} or a valid {@link InputEvmNative} type
 */
type EvmNativeish = InputEvmNative | EvmNative;
/**
 * The EvmNative class is a MoralisData that references to the value of an EVM native currency (like ETH, BNB etc.)
 *
 * @category DataType
 */
declare class EvmNative implements MoralisData {
    private readonly rawValue;
    /**
     * Returns value of one ether.
     *
     * @example EvmNative.ONE_ETH
     */
    static get ONE_ETH(): EvmNative;
    /**
     * Returns value of one gwei.
     *
     * @example EvmNative.ONE_GWEI
     */
    static get ONE_GWEI(): EvmNative;
    /**
     * Returns value of one wei.
     *
     * @example EvmNative.ONE_WEI
     */
    static get ONE_WEI(): EvmNative;
    /**
     * Create a new instance of EvmNative from any valid {@link EvmNativeish} value.
     * @param native - the value to create the EvmNative from
     * @param unit - the unit of the value (optional), defaults to `ether`
     * @returns a new instance of EvmNative
     * @example
     * ```ts
     * const native = EvmNative.create(2, 'gwei');
     * const native = EvmNative.create(2);
     * const native = EvmNative.create(2, 'wei');
     *```
     */
    static create(native: EvmNativeish, unit?: UnitOrDecimals): EvmNative;
    private constructor();
    private static parse;
    /**
     * Compares two EvmNative values.
     * @param valueA - the first value to compare
     * @param valueB - the second value to compare
     * @returns true if the values are equal
     * @example
     * ```ts
     * EvmNative.equals(EvmNative.create(1, 'ether'), EvmNative.create(1, 'ether')); // true
     * ```
     */
    static equals(valueA: EvmNativeish, valueB: EvmNativeish): boolean;
    /**
     * Compares EvmNative with current instance.
     * @param value - the value to compare with
     * @returns true if the values are equal
     * @example
     * ```ts
     * const native = EvmNative.create(1, 'gwei');
     * native.equals(EvmNative.create(1, 'ether')); // false
     * ```
     */
    equals(value: EvmNative): boolean;
    /**
     * Converts the EvmNative to a string.
     * @returns the value of the EvmNative as a string
     * @example `native.toString()`
     */
    toString(): string;
    /**
     * Converts the EvmNative to a string.
     * @returns the value of the EvmNative as a string
     * @example `native.format()`
     */
    format(): string;
    /**
     * @returns the value of the EvmNative as a BigNumber
     * @example `native.value`
     */
    get value(): BigNumber;
    /**
     * Converts the EvmNative to a string representation of the value in wei.
     * @returns the value of the EvmNative as a string
     * @example `native.wei`
     */
    get wei(): string;
    /**
     * Converts the EvmNative to a string representation of the value in gwei.
     * @returns the value of the EvmNative as a string
     * @example `native.gwei`
     */
    get gwei(): string;
    /**
     * Converts the EvmNative to a string representation of the value in ether.
     * @returns the value of the EvmNative as a string
     * @example `native.ether`
     */
    get ether(): string;
}

/**
 * Valid EvmTransactionLog input.
 *
 * @example
 * ```ts
 * const input = {
 *  address: "0x3105d328c66d8d55092358cf595d54608178e9b5",
 *  data: "0x00000000000000000000000000000000000000000000000de05239bccd4d537400000000000000000000000000024dbc80a9f80e3d5fc0a0ee30e2693781a443",
 *  topics: ["0x2caecd17d02f56fa897705dcc740da2d237c373f70686f4e0d9bd3bf0400ea7a", "0x000000000000000000000000031002d15b0d0cd7c9129d6f644446368deae391", null, null],
 *  transactionHash: "0xdd9006489e46670e0e85d1fb88823099e7f596b08aeaac023e9da0851f26fdd5",
 *  logIndex: "273",
 *  transactionIndex: "204",\
 *  blockHash: "0x9b559aef7ea858608c2e554246fe4a24287e7aeeb976848df2b9a2531f4b9171",
 *  blockNumber: "12386788",
 *  blockTimestamp: "2021-05-07T11:08:35.000Z",
 *  transactionIndex: "204",
 *  chain: "1"
 * }
 * ```
 */
interface EvmTransactionLogInput {
    logIndex?: string | number;
    transactionHash: string;
    transactionIndex?: number;
    address: EvmAddressish;
    data: string;
    topics: (string | null)[];
    blockHash: string;
    blockNumber: number;
    blockTimestamp?: string;
    chain: EvmChainish;
}
/**
 * Represents a processed transaction log.
 */
interface EvmTransactionLogData {
    logIndex?: number;
    transactionHash: string;
    transactionIndex?: number;
    address: EvmAddress;
    data: string;
    topics: (string | null)[];
    blockHash: string;
    blockNumber: number;
    blockTimestamp?: string;
    chain: EvmChain;
}

/**
 * This can be any valid {@link EvmTransactionLogInput} or {@link EvmTransactionLog}.
 */
type EvmTransactionLogish = EvmTransactionLogInput | EvmTransactionLog;
type LogTopic = string | null;
/**
 * The EvmTransactionLog class is a MoralisData that references an EVM transaction log.
 *
 * @category DataType
 */
declare class EvmTransactionLog implements MoralisDataObject {
    /**
     * Create a new instance of EvmTransactionLog from any valid address input
     *
     * @example
     * ```
     * const log = EvmTransactionLog.create(value, core);
     * ```
     * @param value - A valid EvmTransactionLogish
     * @param core - The Core instance
     */
    static create(value: EvmTransactionLogish, core?: _moralisweb3_common_core__default): EvmTransactionLog;
    private _value;
    constructor(value: EvmTransactionLogInput, core: _moralisweb3_common_core__default);
    static parse(value: EvmTransactionLogInput, core: _moralisweb3_common_core__default): EvmTransactionLogData;
    /**
     * Compares the log to another log for equality.
     *
     * @param value - The value to compare with
     * @returns true if the logs are equal, otherwise false
     * @example
     * ```ts
     * log.equals(log);
     * ```
     */
    equals(value: this): boolean;
    /**
     * Converts the log to a JSON object.
     *
     * @returns the EvmTransactionLog as a JSON object
     * @example
     * ```ts
     * log.toJSON();
     * ```
     */
    toJSON(): {
        address: string;
        chain: string | number;
        logIndex?: number | undefined;
        transactionHash: string;
        transactionIndex?: number | undefined;
        data: string;
        topics: (string | null)[];
        blockHash: string;
        blockNumber: number;
        blockTimestamp?: string | undefined;
    };
    /**
     * Converts the log to a JSON object.
     *
     * @returns the EvmTransactionLog as a JSON object
     * @example
     * ```ts
     * log.format();
     * ```
     */
    format(): {
        address: string;
        chain: string | number;
        logIndex?: number | undefined;
        transactionHash: string;
        transactionIndex?: number | undefined;
        data: string;
        topics: (string | null)[];
        blockHash: string;
        blockNumber: number;
        blockTimestamp?: string | undefined;
    };
    /**
     * Returns the processed Erc20Token.
     *
     * @returns the EvmTransactionLog value
     * @example
     * ```ts
     * log.result;
     *  ```
     */
    get result(): EvmTransactionLogData;
    /**
     * @returns the transaction hash of the log.
     *
     * @example
     * ```ts
     * log.transactionHash; // "0xdd9006489e46670e0e85d1fb88823099e7f596b08aeaac023e9da0851f26fdd5"
     * ```
     */
    get transactionHash(): string;
    /**
     * Returns the address of the log.
     *
     * @example
     * ```ts
     * log.address; // EvmAddress
     * ```
     */
    get address(): EvmAddress;
    /**
     * Returns the chain of the log.
     *
     * @example
     * ```ts
     * log.chain; // EvmChain
     * ```
     */
    get chain(): EvmChain;
    /**
     * @returns the log index of the log.
     *
     * @example
     * ```ts
     * log.logIndex; // 273
     * ```
     */
    get logIndex(): number | undefined;
    /**
     * @returns the data of the log.
     *
     * @example
     * ```ts
     * log.data; // "0x00000000000000000000000000000000000000000000000de05239bccd4d537400000000000000000000000000024dbc80a9f80e3d5fc0a0ee30e2693781a443"
     * ```
     */
    get data(): string;
    /**
     * @returns the topics of the log.
     *
     * @example
     * ```ts
     * log.topic0; // ["0x0000000000000000000000000000000000000000000000000000000000000001", "0x0000000000000000000000000000000000000000000000000000000000000002"]
     * ```
     */
    get topics(): (string | null)[];
    /**
     * @returns the block hash of the log.
     *
     * @example
     * ```ts
     * log.blockHash; // "0x9b559aef7ea858608c2e554246fe4a24287e7aeeb976848df2b9a2531f4b9171"
     * ```
     */
    get blockHash(): string;
    /**
     * @returns the block number of the log.
     *
     * @example
     * ```ts
     * log.blockNumber; // 12386788
     * ```
     */
    get blockNumber(): number;
    /**
     * @returns the block timestamp of the log.
     *
     * @example
     * ```ts
     * log.blockTimestamp; // "2021-05-07T11:08:35.000Z"
     * ```
     */
    get blockTimestamp(): string | undefined;
}

type EvmSignatureInputRSV = {
    r: string;
    s: string;
    v: number | string;
};
type EvmSignatureInput = EvmSignatureInputRSV | string;

type EvmSignatureData = Signature;
type EvmSignatureish = EvmSignatureInput | EvmSignature;
/**
 * Represents of a signed EVM signature
 * Can be created with a valid r,s,v signature or a hex string
 */
declare class EvmSignature implements MoralisDataObject {
    static create(data: EvmSignatureish): EvmSignature;
    private _data;
    constructor(data: EvmSignatureInput);
    static parse: (data: EvmSignatureInput) => EvmSignatureData;
    static equals(dataA: EvmSignatureish, dataB: EvmSignatureish): boolean;
    /**
     * Checks the equality of the current transfer instance with another nft transfer
     * @param data - the transfer to compare with
     * @example transaction.equals(data)
     * @returns true if the transfers are equal, false otherwise
     */
    equals(data: EvmSignatureish): boolean;
    get r(): string;
    get s(): string;
    get v(): number;
    get serialized(): string;
    toJSON(): MoralisDataObjectValue;
    format(): string;
}

/**
 * This can be any object with valid transaction data.
 * @example
 * ```
 * const transactionInput = {
          cumulativeGasUsed: "1340925",
          gasPrice: "20000000000",
          gasUsed: "1340925",
          index: "25",
          contractAddress: "0x1d6a4cf64b52f6c73f201839aded7379ce58059c",
          receiptRoot: "string",
          receiptStatus: "1",
          chain: "1",
          data: "0x000000000000000000000000000000000000000000000000000000000000002",
          from: "0xd4a3BebD824189481FC45363602b83C9c7e9cbDf",
          hash: "0x057Ec652A4F150f7FF94f089A38008f49a0DF88e",
          nonce: "326595425",
          value: "650000000000000000",
          blockHash: "0x0372c302e3c52e8f2e15d155e2c545e6d802e479236564af052759253b20fd86",
          blockNumber: "12526958",
          blockTimestamp: new Date("2021-04-02T10:07:54.000Z"),
          gas: "6721975",
          to: "0xa71db868318f0a0bae9411347cd4a6fa23d8d4ef",
          signature: {
            v: 28,
            r: "0xda4429a9e8e6b54cb101b2df002039f2879ab4ca0e8fae64134942cb81f3e581",
            s: "0x3b90a37dc078a82dfc418695b1d4473661aa4d24dd874ac68678894ff44a6b27",
          }
        }
 * ```
 */
interface EvmTransactionInput {
    chain: EvmChainish;
    from: EvmAddressish;
    to?: null | EvmAddressish;
    nonce?: null | BigNumberish;
    data?: null | string;
    value?: null | EvmNativeish;
    hash: string;
    type?: null | number | string;
    gas?: null | BigNumberish;
    gasPrice: BigNumberish;
    index: number | string;
    blockNumber: BigNumberish;
    blockHash: string;
    blockTimestamp: DateInput;
    cumulativeGasUsed: BigNumberish;
    gasUsed: BigNumberish;
    contractAddress?: null | EvmAddressish;
    receiptRoot?: null | string;
    receiptStatus?: null | string | number;
    logs?: EvmTransactionLogish[];
    signature?: EvmSignatureish;
}
/**
 * This is the return type of the processed EVM transaction
 */
interface EvmTransactionData {
    chain: EvmChain;
    from: EvmAddress;
    to?: EvmAddress;
    nonce?: BigNumber;
    data?: string;
    value?: EvmNative;
    hash: string;
    type?: number;
    gas?: BigNumber;
    gasPrice: BigNumber;
    index: number | string;
    blockNumber: BigNumber;
    blockHash: string;
    blockTimestamp: Date;
    cumulativeGasUsed: BigNumber;
    gasUsed: BigNumber;
    contractAddress?: EvmAddress;
    receiptRoot?: string;
    receiptStatus?: number;
    logs: EvmTransactionLog[];
    signature?: EvmSignature;
}

/**
 * Valid input for a new EvmTransaction instance.
 * This can be an existing {@link EvmTransaction} or a valid {@link EvmTransactionInput} object
 */
type EvmTransactionish = EvmTransactionInput | EvmTransaction;
/**
 * The EvmTranaction is a representation of a published transaction.
 *
 * Use this class any time you work with a transaction.
 *
 * @category DataType
 */
declare class EvmTransaction implements MoralisDataObject {
    /**
     * Create a new instance of EvmTransaction from any valid transaction input
     * @param data - the EvmTransactionish type
     * @example
     * ```
     * const transaction = EvmTransaction.create(data);
     *```
     */
    static create(data: EvmTransactionish, core?: _moralisweb3_common_core__default): EvmTransaction;
    private _data;
    constructor(data: EvmTransactionInput, core: _moralisweb3_common_core__default);
    static parse: (data: EvmTransactionInput, core: _moralisweb3_common_core__default) => EvmTransactionData;
    /**
     * Check the equality between two Evm transactions
     * @param dataA - The first transaction
     * @param dataB - The second transaction
     * @example
     * ```ts
     * EvmTransaction.equals(dataA, dataB)
     * ```
     */
    static equals(dataA: EvmTransactionish, dataB: EvmTransactionish): boolean;
    /**
     * Checks the equality of the current transaction with another evm transaction
     * @param data - the transaction to compare with
     * @example
     * ```ts
     * transaction.equals(data)
     * ```
     */
    equals(data: EvmTransactionish): boolean;
    toJSON(): {
        to: string | undefined;
        from: string;
        nonce: string | undefined;
        gas: string | undefined;
        gasPrice: string;
        gasUsed: string;
        cumulativeGasUsed: string;
        value: string | undefined;
        chain: string | number;
        contractAddress: string | undefined;
        logs: {
            address: string;
            chain: string | number;
            logIndex?: number | undefined;
            transactionHash: string;
            transactionIndex?: number | undefined;
            data: string;
            topics: (string | null)[];
            blockHash: string;
            blockNumber: number;
            blockTimestamp?: string | undefined;
        }[];
        signature: _moralisweb3_common_core.MoralisDataObjectValue | undefined;
        blockNumber: string;
        blockTimestamp: string;
        data?: string | undefined;
        hash: string;
        type?: number | undefined;
        index: string | number;
        blockHash: string;
        receiptRoot?: string | undefined;
        receiptStatus?: number | undefined;
    };
    /**
     * @returns a JSON represention of the transaction.
     * @example
     * ```
     * transaction.format()
     * ```
     */
    format(): {
        to: string | undefined;
        from: string;
        nonce: string | undefined;
        gas: string | undefined;
        gasPrice: string;
        gasUsed: string;
        cumulativeGasUsed: string;
        value: string | undefined;
        chain: string | number;
        contractAddress: string | undefined;
        logs: {
            address: string;
            chain: string | number;
            logIndex?: number | undefined;
            transactionHash: string;
            transactionIndex?: number | undefined;
            data: string;
            topics: (string | null)[];
            blockHash: string;
            blockNumber: number;
            blockTimestamp?: string | undefined;
        }[];
        signature: _moralisweb3_common_core.MoralisDataObjectValue | undefined;
        blockNumber: string;
        blockTimestamp: string;
        data?: string | undefined;
        hash: string;
        type?: number | undefined;
        index: string | number;
        blockHash: string;
        receiptRoot?: string | undefined;
        receiptStatus?: number | undefined;
    };
    /**
     * @returns the transaction
     * @example
     * ```
     * transaction.result
     * ```
     */
    get result(): EvmTransactionData;
    /**
     * @returns the transaction to address
     * @example
     * ```
     * transaction.to // EvmAddress
     * ```
     */
    get to(): EvmAddress | undefined;
    /**
     * @returns the transaction from address
     * @example
     * ```
     * transaction.address // EvmAddress
     * ```
     */
    get from(): EvmAddress;
    /**
     * @returns the transaction nonce
     * @example
     * ```
     * transaction.nonce // 326595425
     * ```
     */
    get nonce(): BigNumber | undefined;
    /**
     * @returns the transaction gas
     * @example
     * ```
     * transaction.gas // 6721975
     * ```
     */
    get gas(): BigNumber | undefined;
    /**
     * @returns the transaction gas price
     * @example
     * ```
     * transaction.gasPrice // 20000000000
     * ```
     */
    get gasPrice(): BigNumber;
    /**
     * @returns the transaction gas used
     * @example
     * ```
     * transaction.gasUsed // 1340925
     * ```
     */
    get gasUsed(): BigNumber;
    /**
     * @returns the transaction cumulative gas used
     * @example
     * ```
     * transaction.cumulativeGasUsed // 1340925
     * ```
     */
    get cumulativeGasUsed(): BigNumber;
    /**
     * @returns the transaction block number
     * @example
     * ```
     * transaction.blockNumber // 12526958
     * ```
     */
    get blockNumber(): BigNumber;
    /**
     * @returns the transaction value
     * @example
     * ```
     * transaction.value // EvmNative
     * ```
     */
    get value(): EvmNative | undefined;
    /**
     * @returns the transaction chain
     * @example
     * ```
     * transaction.chain // EvmChain
     * ```
     */
    get chain(): EvmChain;
    /**
     * @returns the transaction contract address
     * @example
     * ```
     * transaction.contractAddress // EvmAddress
     * ```
     */
    get contractAddress(): EvmAddress | undefined;
    /**
     * @returns the transaction logs
     * @example
     * ```
     * transaction.logs // EvmTransactionLog[]
     * ```
     */
    get logs(): EvmTransactionLog[];
    /**
     * @returns the transaction receipt root
     * @example
     * ```
     * transaction.receiptRoot // string
     * ```
     */
    get receiptRoot(): string | undefined;
    /**
     * @returns the transaction receipt status
     * @example
     * ```
     * transaction.receiptStatus // 1
     * ```
     */
    get receiptStatus(): number | undefined;
    /**
     * @returns the transaction data
     * @example
     * ```
     * transaction.data // 0x000000000000000000000000000000000000000000000000000000000000002
     * ```
     */
    get data(): string | undefined;
    /**
     * @returns the transaction hash
     * @example
     * ```
     * transaction.hash // 0x057Ec652A4F150f7FF94f089A38008f49a0DF88e
     * ```
     */
    get hash(): string;
    /**
     * @returns the transaction type
     * @example
     * ```
     * transaction.type // 1
     * ```
     */
    get type(): number | undefined;
    /**
     * @returns the transaction black hash
     * @example
     * ```
     * transaction.blockHash // 0x0372c302e3c52e8f2e15d155e2c545e6d802e479236564af052759253b20fd86
     * ```
     */
    get blockHash(): string;
    /**
     * @returns the transaction block timestamp
     * @example
     * ```
     * transaction.blockTimestamp // Date
     * ```
     */
    get blockTimestamp(): Date;
    /**
     * @returns the signature (if available)
     * @example
     * ```
     * transaction.signature // EvmSignature
     * ```
     */
    get signature(): EvmSignature | undefined;
    /**
     * @returns the index
     * @example
     * ```
     * transaction.index // 1
     * ```
     */
    get index(): string | number;
    get v(): number | undefined;
    get r(): string | undefined;
    get s(): string | undefined;
}

/**
 * This can be any object with valid block data.
 * @example
 * ```
 * const input = {
 *    chain: 1,
 *    hash: '0x9b559aef7ea858608c2e554246fe4a24287e7aeeb976848df2b9a2531f4b9171',
 *    number: '12386788',
 *    timestamp: '2021-05-07T11:08:35.000Z',
 *  }
 * ```
 */
interface EvmSimpleBlockInput {
    timestamp: DateInput;
    number: BigNumberish;
    hash: string;
    chain: EvmChainish;
}
/**
 * This is the return type of the processed EVM Block
 */
interface EvmSimpleBlockData {
    timestamp: Date;
    number: BigNumber;
    hash: string;
    chain: EvmChain;
}
/**
 * This can be any object with valid block data.
 * @example
 * ```
 * const input = {
 *    chain: 1,
 *    hash: '0x9b559aef7ea858608c2e554246fe4a24287e7aeeb976848df2b9a2531f4b9171',
 *    difficulty: '7253857437305950',
 *    extraData: '0xd883010a01846765746888676f312e31352e31856c696e7578',
 *    gasLimit: '14977947',
 *    gasUsed: '14964688',
 *    logsBloom:
        '0xdde5fc46c5d8bcbd58207bc9f267bf43298e23791a326ff02661e99790da9996b3e0dd912c0b8202d389d282c56e4d11eb2dec4898a32b6b165f1f4cae6aa0079498eab50293f3b8defbf6af11bb75f0408a563ddfc26a3323d1ff5f9849e95d5f034d88a757ddea032c75c00708c9ff34d2207f997cc7d93fd1fa160a6bfaf62a54e31f9fe67ab95752106ba9d185bfdc9b6dc3e17427f844ee74e5c09b17b83ad6e8fc7360f5c7c3e4e1939e77a6374bee57d1fa6b2322b11ad56ad0398302de9b26d6fbfe414aa416bff141fad9d4af6aea19322e47595e342cd377403f417dfd396ab5f151095a5535f51cbc34a40ce9648927b7d1d72ab9daf253e31daf',
 *    miner: '0xea674fdde714fd979de3edf0f56aa9716b898ec8',
 *    nonce: '0xedeb2d8fd2b2bdec',
 *    number: '12386788',
 *    parentHash: '0x011d1fc45839de975cc55d758943f9f1d204f80a90eb631f3bf064b80d53e045',
 *    receiptsRoot: '0x7cf43d7e837284f036cf92c56973f5e27bdd253ca46168fa195a6b07fa719f23',
 *    sha3Uncles: '0x1dcc4de8dec75d7aab85b567b6ccd41ad312451b948a7413f0a142fd40d49347',
 *    size: '61271',
 *    stateRoot: '0x49e3bfe7b618e27fde8fa08884803a8458b502c6534af69873a3cc926a7c724b',
 *    timestamp: '2021-05-07T11:08:35.000Z',
 *    totalDifficulty: '7253857437305950',
 *    transactionsRoot: '0xe4c7bf3aff7ad07f9e80d57f7189f0252592fee6321c2a9bd9b09b6ce0690d27',
 *    transactionCount: '252',
 *    transactions: [],
 *  }
 * ```
 */
interface EvmBlockInput extends EvmSimpleBlockInput {
    parentHash: string;
    nonce: string;
    sha3Uncles: string;
    logsBloom: string;
    transactionsRoot: string;
    stateRoot: string;
    receiptsRoot: string;
    miner: EvmAddressish;
    difficulty: BigNumberish;
    totalDifficulty: BigNumberish;
    size: BigNumberish;
    extraData: string;
    gasLimit: BigNumberish;
    gasUsed: BigNumberish;
    transactionCount: number | string;
    transactions: EvmTransactionish[];
}
/**
 * This is the return type of the processed EVM transaction
 */
interface EvmBlockData extends EvmSimpleBlockData {
    parentHash: string;
    nonce: string;
    sha3Uncles: string;
    logsBloom: string;
    transactionsRoot: string;
    stateRoot: string;
    receiptsRoot: string;
    miner: EvmAddress;
    difficulty: BigNumber;
    totalDifficulty: BigNumber;
    size: BigNumber;
    extraData: string;
    gasLimit: BigNumber;
    gasUsed: BigNumber;
    transactionCount: number;
    transactions: EvmTransaction[];
}

/**
 * Valid input for a new EvmSimpleBlock instance.
 * This can be an existing {@link EvmSimpleBlock} or a valid {@link EvmSimpleBlockInput} object
 */
type EvmSimpleBlockish = EvmSimpleBlockInput | EvmSimpleBlock;
/**
 * The EvmSimpleBlock is a representation of a block.
 *
 * @category DataType
 */
declare class EvmSimpleBlock implements MoralisDataObject {
    /**
     * Create a new instance of EvmSimpleBlock from any valid transaction input
     * @param data - the EvmSimpleBlockish type
     * @example const transaction = EvmTransaction.create(data);
     */
    static create(data: EvmSimpleBlockish, core?: _moralisweb3_common_core__default): EvmSimpleBlock;
    private _data;
    constructor(data: EvmSimpleBlockInput, core: _moralisweb3_common_core__default);
    static parse: (data: EvmSimpleBlockInput, core: _moralisweb3_common_core__default) => EvmSimpleBlockData;
    /**
     * Check the equality between two Evm blocks. It compares their hashes and blocks.
     * @param dataA - The first block to compare
     * @param dataB - The second block to compare
     * @example EvmTransaction.equals(dataA, dataB)
     */
    static equals(dataA: EvmSimpleBlockish | EvmBlockish, dataB: EvmSimpleBlockish | EvmBlockish): boolean;
    /**
     * Checks the equality of the current block with another evm block
     * @param data - the block to compare with
     * @example
     * ```ts
     * block.equals(data)
     * ```
     */
    equals(data: EvmSimpleBlockish): boolean;
    /**
     * @returns a JSON represention of the block.
     * @example
     * ```
     * block.toJSON()
     * ```
     */
    toJSON(): {
        number: string;
        chain: string | number;
        timestamp: Date;
        hash: string;
    };
    /**
     * @returns a JSON represention of the block.
     * @example
     * ```
     * block.format()
     * ```
     */
    format(): {
        number: string;
        chain: string | number;
        timestamp: Date;
        hash: string;
    };
    /**
     * @returns all the data without casting it to JSON.
     * @example block.result
     */
    get result(): EvmSimpleBlockData;
    /**
     * @returns the block number.
     * @example block.number // BigNumber
     */
    get number(): BigNumber;
    /**
     * @returns the block hash.
     * @example block.hash // "0x9b559aef7ea858608c2e554246fe4a24287e7aeeb976848df2b9a2531f4b9171"
     */
    get hash(): string;
    /**
     * @returns the block timestamp.
     * @example block.timestamp // Date
     */
    get timestamp(): Date;
    /**
     * @returns the block chain.
     * @example block.chain // EvmChain
     */
    get chain(): EvmChain;
}

/**
 * Valid input for a new EvmBlock instance.
 * This can be an existing {@link EvmBlock} or a valid {@link EvmBlockInput} object
 */
type EvmBlockish = EvmBlockInput | EvmBlock;
/**
 * The EvmBlock is a representation of a block.
 *
 * @category DataType
 */
declare class EvmBlock implements MoralisDataObject {
    /**
     * Create a new instance of EvmBlock from any valid transaction input
     * @param data - the EvmBlockish type
     * @example const transaction = EvmTransaction.create(data);
     */
    static create(data: EvmBlockish, core?: _moralisweb3_common_core__default): EvmBlock;
    private _data;
    constructor(data: EvmBlockInput, core: _moralisweb3_common_core__default);
    static parse: (data: EvmBlockInput, core: _moralisweb3_common_core__default) => EvmBlockData;
    /**
     * Check the equality between two Evm blocks. It compares their hashes and blocks.
     * @param dataA - The first block to compare
     * @param dataB - The second block to compare
     * @example EvmTransaction.equals(dataA, dataB)
     */
    static equals(dataA: EvmSimpleBlockish | EvmBlockish, dataB: EvmSimpleBlockish | EvmBlockish): boolean;
    /**
     * Checks the equality of the current block with another evm block
     * @param data - the block to compare with
     * @example
     * ```ts
     * block.equals(data)
     * ```
     */
    equals(data: EvmBlockish): boolean;
    /**
     * @returns a JSON represention of the block.
     * @example
     * ```
     * block.toJSON()
     * ```
     */
    toJSON(): {
        number: string;
        difficulty: string;
        totalDifficulty: string;
        size: string;
        gasLimit: string;
        gasUsed: string;
        chain: string | number;
        miner: string;
        transactions: {
            to: string | undefined; /**
             * @returns the block number.
             * @example block.number // BigNumber
             */
            from: string;
            nonce: string | undefined;
            gas: string | undefined;
            gasPrice: string;
            gasUsed: string;
            cumulativeGasUsed: string;
            value: string | undefined;
            chain: string | number;
            /**
             * @returns the block timestamp.
             * @example block.timestamp // Date
             */
            contractAddress: string | undefined;
            logs: {
                address: string;
                chain: string | number;
                logIndex?: number | undefined;
                transactionHash: string;
                transactionIndex?: number | undefined;
                data: string;
                topics: (string | null)[];
                blockHash: string;
                blockNumber: number;
                blockTimestamp?: string | undefined;
            }[];
            signature: _moralisweb3_common_core.MoralisDataObjectValue | undefined; /**
             * @returns the block miner.
             * @example block.miner // EvmAddress
             */
            blockNumber: string;
            blockTimestamp: string;
            data?: string | undefined;
            hash: string;
            type?: number | undefined;
            index: string | number;
            blockHash: string;
            receiptRoot?: string | undefined;
            receiptStatus?: number | undefined;
        }[];
        parentHash: string;
        nonce: string;
        sha3Uncles: string;
        logsBloom: string;
        transactionsRoot: string;
        stateRoot: string;
        receiptsRoot: string;
        extraData: string; /**
         * @returns a JSON represention of the block.
         * @example
         * ```
         * block.format()
         * ```
         */
        transactionCount: number;
        timestamp: Date;
        hash: string;
    };
    /**
     * @returns a JSON represention of the block.
     * @example
     * ```
     * block.format()
     * ```
     */
    format(): {
        number: string;
        difficulty: string;
        totalDifficulty: string;
        size: string;
        gasLimit: string;
        gasUsed: string;
        chain: string | number;
        miner: string;
        transactions: {
            to: string | undefined; /**
             * @returns the block number.
             * @example block.number // BigNumber
             */
            from: string;
            nonce: string | undefined;
            gas: string | undefined;
            gasPrice: string;
            gasUsed: string;
            cumulativeGasUsed: string;
            value: string | undefined;
            chain: string | number;
            /**
             * @returns the block timestamp.
             * @example block.timestamp // Date
             */
            contractAddress: string | undefined;
            logs: {
                address: string;
                chain: string | number;
                logIndex?: number | undefined;
                transactionHash: string;
                transactionIndex?: number | undefined;
                data: string;
                topics: (string | null)[];
                blockHash: string;
                blockNumber: number;
                blockTimestamp?: string | undefined;
            }[];
            signature: _moralisweb3_common_core.MoralisDataObjectValue | undefined; /**
             * @returns the block miner.
             * @example block.miner // EvmAddress
             */
            blockNumber: string;
            blockTimestamp: string;
            data?: string | undefined;
            hash: string;
            type?: number | undefined;
            index: string | number;
            blockHash: string;
            receiptRoot?: string | undefined;
            receiptStatus?: number | undefined;
        }[];
        parentHash: string;
        nonce: string;
        sha3Uncles: string;
        logsBloom: string;
        transactionsRoot: string;
        stateRoot: string;
        receiptsRoot: string;
        extraData: string; /**
         * @returns a JSON represention of the block.
         * @example
         * ```
         * block.format()
         * ```
         */
        transactionCount: number;
        timestamp: Date;
        hash: string;
    };
    /**
     * @returns all the data without casting it to JSON.
     * @example block.result
     */
    get result(): EvmBlockData;
    /**
     * @returns the block number.
     * @example block.number // BigNumber
     */
    get number(): BigNumber;
    /**
     * @returns the block hash.
     * @example block.hash // "0x9b559aef7ea858608c2e554246fe4a24287e7aeeb976848df2b9a2531f4b9171"
     */
    get hash(): string;
    /**
     * @returns the block timestamp.
     * @example block.timestamp // Date
     */
    get timestamp(): Date;
    /**
     * @returns the block miner.
     * @example block.miner // EvmAddress
     */
    get miner(): EvmAddress;
    /**
     * @returns the block difficulty.
     * @example block.difficulty // BigNumber
     */
    get difficulty(): BigNumber;
    /**
     * @returns the block total difficulty.
     * @example block.totalDifficulty // BigNumber
     */
    get totalDifficulty(): BigNumber;
    /**
     * @returns the block size.
     * @example block.size // BigNumber
     */
    get size(): BigNumber;
    /**
     * @returns the block gas limit.
     * @example block.gasLimit // BigNumber
     */
    get gasLimit(): BigNumber;
    /**
     * @returns the block gas used.
     * @example block.gasUsed // BigNumber
     */
    get gasUsed(): BigNumber;
    /**
     * @returns the block transactions.
     * @example block.transactions // EvmTransaction[]
     */
    get transactions(): EvmTransaction[];
    /**
     * @returns the block chain.
     * @example block.chain // EvmChain
     */
    get chain(): EvmChain;
    /**
     * @returns the block transaction count.
     * @example block.transactionCount // 252
     */
    get transactionCount(): number;
    /**
     * @returns the block transactions root.
     * @example block.transactionsRoot // "0xe4c7bf3aff7ad07f9e80d57f7189f0252592fee6321c2a9bd9b09b6ce0690d27"
     */
    get transactionsRoot(): string;
    /**
     * @returns the block state root.
     * @example block.stateRoot // "0x49e3bfe7b618e27fde8fa08884803a8458b502c6534af69873a3cc926a7c724b"
     */
    get stateRoot(): string;
    /**
     * @returns the block receipts root.
     * @example block.receiptsRoot // "0x7cf43d7e837284f036cf92c56973f5e27bdd253ca46168fa195a6b07fa719f23"
     */
    get receiptsRoot(): string;
    /**
     * @returns the block logs bloom.
     * @example block.logsBloom // "0xdde5fc46c5d8bcbd58207bc9f267bf43298e23791a326ff02661e99790da9996b3e0dd912c0b8202d389d282c56e4d11eb2dec4898a32b6b165f1f4cae6aa0079498eab50293f3b8defbf6af11bb75f0408a563ddfc26a3323d1ff5f9849e95d5f034d88a757ddea032c75c00708c9ff34d2207f997cc7d93fd1fa160a6bfaf62a54e31f9fe67ab95752106ba9d185bfdc9b6dc3e17427f844ee74e5c09b17b83ad6e8fc7360f5c7c3e4e1939e77a6374bee57d1fa6b2322b11ad56ad0398302de9b26d6fbfe414aa416bff141fad9d4af6aea19322e47595e342cd377403f417dfd396ab5f151095a5535f51cbc34a40ce9648927b7d1d72ab9daf253e31daf"
     */
    get logsBloom(): string;
    /**
     * @returns the block extra data.
     * @example block.extraData // "0x65746865726d696e652d6575726f70652d7765737433"
     */
    get extraData(): string;
    /**
     * @returns the block parent hash.
     * @example block.parentHash // "0x011d1fc45839de975cc55d758943f9f1d204f80a90eb631f3bf064b80d53e045"
     */
    get parentHash(): string;
    /**
     * @returns the block sha3Uncles.
     * @example block.sha3Uncles // "0x1dcc4de8dec75d7aab85b567b6ccd41ad312451b948a7413f0a142fd40d49347"
     */
    get sha3Uncles(): string;
    /**
     * @returns the block nonce.
     * @example block.nonce // "0xedeb2d8fd2b2bdec"
     */
    get nonce(): string;
}

interface components {
    schemas: {
        logCollection: {
            /**
             * @description The total number of matches for this query
             * @example 100
             */
            total?: number;
            /**
             * @description The current page of the result
             * @example 1
             */
            page?: number;
            /**
             * @description The number of results per page
             * @example 100
             */
            page_size?: number;
            /** @description The cursor to get to the next page */
            cursor?: string;
            result?: components["schemas"]["logEventByAddress"][];
        };
        logEventByAddress: {
            /**
             * @description The transaction hash
             * @example 0x2d30ca6f024dbc1307ac8a1a44ca27de6f797ec22ef20627a1307243b0ab7d09
             */
            transaction_hash: string;
            /**
             * @description The address of the contract
             * @example 0x057Ec652A4F150f7FF94f089A38008f49a0DF88e
             */
            address: string;
            /**
             * @description The block timestamp
             * @example 2021-04-02T10:07:54.000Z
             */
            block_timestamp: string;
            /**
             * @description The block number
             * @example 12526958
             */
            block_number: string;
            /**
             * @description The block hash
             * @example 0x0372c302e3c52e8f2e15d155e2c545e6d802e479236564af052759253b20fd86
             */
            block_hash: string;
            /**
             * @description The data of the log
             * @example 0x00000000000000000000000000000000000000000000000de05239bccd4d537400000000000000000000000000024dbc80a9f80e3d5fc0a0ee30e2693781a443
             */
            data: string;
            /** @example 0x2caecd17d02f56fa897705dcc740da2d237c373f70686f4e0d9bd3bf0400ea7a */
            topic0: string;
            /** @example 0x000000000000000000000000031002d15b0d0cd7c9129d6f644446368deae391 */
            topic1: string;
            /** @example 0x000000000000000000000000d25943be09f968ba740e0782a34e710100defae9 */
            topic2: string;
            /** @example null */
            topic3: string;
            /**
             * @description The Transaction index of the log within the block
             * @example 12
             */
            transaction_index: number;
            /**
             * @description The log index of the log within the block
             * @example 15
             */
            log_index: number;
        };
        logEvent: {
            /**
             * @description The transaction hash
             * @example 0x2d30ca6f024dbc1307ac8a1a44ca27de6f797ec22ef20627a1307243b0ab7d09
             */
            transaction_hash: string;
            /**
             * @description The address of the contract
             * @example 0x18F97EF6B2cbac5CA85b375b7093C4A207340d06
             */
            address: string;
            /**
             * @description The block timestamp
             * @example 2021-04-02T10:07:54.000Z
             */
            block_timestamp: string;
            /**
             * @description The block number
             * @example 12526958
             */
            block_number: string;
            /**
             * @description The block hash
             * @example 0x0372c302e3c52e8f2e15d155e2c545e6d802e479236564af052759253b20fd86
             */
            block_hash: string;
            /** @description The content of the event */
            data: {
                /** @example 0x54ff6974c715956a5049a123408bff91fbe29f01 */
                from?: string;
                /** @example 0x74de5d4fcbf63e00296fd95d33236b9794016631 */
                to?: string;
                /** @example 260103496340000000000 */
                value?: string;
            };
        };
        log: {
            /** @example 273 */
            log_index: string;
            /**
             * @description The hash of the transaction
             * @example 0xdd9006489e46670e0e85d1fb88823099e7f596b08aeaac023e9da0851f26fdd5
             */
            transaction_hash: string;
            /** @example 204 */
            transaction_index: string;
            /**
             * @description The address of the contract
             * @example 0x3105d328c66d8d55092358cf595d54608178e9b5
             */
            address: string;
            /**
             * @description The data of the log
             * @example 0x00000000000000000000000000000000000000000000000de05239bccd4d537400000000000000000000000000024dbc80a9f80e3d5fc0a0ee30e2693781a443
             */
            data: string;
            /** @example 0x2caecd17d02f56fa897705dcc740da2d237c373f70686f4e0d9bd3bf0400ea7a */
            topic0: string;
            /** @example 0x000000000000000000000000031002d15b0d0cd7c9129d6f644446368deae391 */
            topic1?: string | unknown;
            /** @example 0x000000000000000000000000d25943be09f968ba740e0782a34e710100defae9 */
            topic2?: string | unknown;
            /** @example null */
            topic3?: string | unknown;
            /**
             * @description The timestamp of the block
             * @example 2021-05-07T11:08:35.000Z
             */
            block_timestamp: string;
            /**
             * @description The block number
             * @example 12386788
             */
            block_number: string;
            /**
             * @description The hash of the block
             * @example 0x9b559aef7ea858608c2e554246fe4a24287e7aeeb976848df2b9a2531f4b9171
             */
            block_hash: string;
        };
        blockTransaction: {
            /**
             * @description The hash of the transaction
             * @example 0x1ed85b3757a6d31d01a4d6677fc52fd3911d649a0af21fe5ca3f886b153773ed
             */
            hash: string;
            /**
             * @description The nonce
             * @example 1848059
             */
            nonce: string;
            /** @example 108 */
            transaction_index: string;
            /**
             * @description The from address
             * @example 0x267be1c1d684f78cb4f6a176c4911b741e4ffdc0
             */
            from_address: string;
            /**
             * @description The to address
             * @example 0x003dde3494f30d861d063232c6a8c04394b686ff
             */
            to_address: string | unknown;
            /**
             * @description The value sent
             * @example 115580000000000000
             */
            value: string;
            /** @example 30000 */
            gas?: string;
            /**
             * @description The gas price
             * @example 52500000000
             */
            gas_price: string;
            /** @example 0x */
            input: string;
            /** @example 4923073 */
            receipt_cumulative_gas_used: string;
            /** @example 21000 */
            receipt_gas_used: string;
            /** @example null */
            receipt_contract_address?: string | unknown;
            /** @example null */
            receipt_root?: string | unknown;
            /** @example 1 */
            receipt_status: string;
            /**
             * @description The block timestamp
             * @example 2021-05-07T11:08:35.000Z
             */
            block_timestamp: string;
            /**
             * @description The block number
             * @example 12386788
             */
            block_number: string;
            /**
             * @description The hash of the block
             * @example 0x9b559aef7ea858608c2e554246fe4a24287e7aeeb976848df2b9a2531f4b9171
             */
            block_hash: string;
            /** @description The logs of the transaction */
            logs?: components["schemas"]["log"][];
        };
        block: {
            /**
             * @description The block timestamp
             * @example 2021-05-07T11:08:35.000Z
             */
            timestamp: string;
            /**
             * @description The block number
             * @example 12386788
             */
            number: string;
            /**
             * @description The block hash
             * @example 0x9b559aef7ea858608c2e554246fe4a24287e7aeeb976848df2b9a2531f4b9171
             */
            hash: string;
            /**
             * @description The block hash of the parent block
             * @example 0x011d1fc45839de975cc55d758943f9f1d204f80a90eb631f3bf064b80d53e045
             */
            parent_hash: string;
            /**
             * @description The nonce
             * @example 0xedeb2d8fd2b2bdec
             */
            nonce: string;
            /** @example 0x1dcc4de8dec75d7aab85b567b6ccd41ad312451b948a7413f0a142fd40d49347 */
            sha3_uncles: string;
            /** @example 0xdde5fc46c5d8bcbd58207bc9f267bf43298e23791a326ff02661e99790da9996b3e0dd912c0b8202d389d282c56e4d11eb2dec4898a32b6b165f1f4cae6aa0079498eab50293f3b8defbf6af11bb75f0408a563ddfc26a3323d1ff5f9849e95d5f034d88a757ddea032c75c00708c9ff34d2207f997cc7d93fd1fa160a6bfaf62a54e31f9fe67ab95752106ba9d185bfdc9b6dc3e17427f844ee74e5c09b17b83ad6e8fc7360f5c7c3e4e1939e77a6374bee57d1fa6b2322b11ad56ad0398302de9b26d6fbfe414aa416bff141fad9d4af6aea19322e47595e342cd377403f417dfd396ab5f151095a5535f51cbc34a40ce9648927b7d1d72ab9daf253e31daf */
            logs_bloom: string;
            /** @example 0xe4c7bf3aff7ad07f9e80d57f7189f0252592fee6321c2a9bd9b09b6ce0690d27 */
            transactions_root: string;
            /** @example 0x49e3bfe7b618e27fde8fa08884803a8458b502c6534af69873a3cc926a7c724b */
            state_root: string;
            /** @example 0x7cf43d7e837284f036cf92c56973f5e27bdd253ca46168fa195a6b07fa719f23 */
            receipts_root: string;
            /**
             * @description The address of the miner
             * @example 0xea674fdde714fd979de3edf0f56aa9716b898ec8
             */
            miner: string;
            /**
             * @description The difficulty of the block
             * @example 7253857437305950
             */
            difficulty: string;
            /**
             * @description The total difficulty
             * @example 24325637817906576196890
             */
            total_difficulty: string;
            /**
             * @description The block size
             * @example 61271
             */
            size: string;
            /** @example 0x65746865726d696e652d6575726f70652d7765737433 */
            extra_data: string;
            /**
             * @description The gas limit
             * @example 14977947
             */
            gas_limit: string;
            /**
             * @description The gas used
             * @example 14964688
             */
            gas_used: string;
            /**
             * @description The number of transactions in the block
             * @example 252
             */
            transaction_count: string;
            /** @description The transactions in the block */
            transactions: components["schemas"]["blockTransaction"][];
        };
        blockDate: {
            /**
             * @description The date of the block
             * @example 2020-01-01T00:00:00+00:00
             */
            date: string;
            /**
             * @description The block number
             * @example 9193266
             */
            block: number;
            /**
             * @description The timestamp of the block
             * @example 1577836811
             */
            timestamp: number;
            /**
             * @description The timestamp of the block
             * @example 2019-12-31T23:59:45.000Z
             */
            block_timestamp?: string;
            /**
             * @description The block hash
             * @example 0x9b559aef7ea858608c2e554246fe4a24287e7aeeb976848df2b9a2531f4b9171
             */
            hash?: string;
            /**
             * @description The block hash of the parent block
             * @example 0x011d1fc45839de975cc55d758943f9f1d204f80a90eb631f3bf064b80d53e045
             */
            parent_hash?: string;
        };
        RunContractDto: {
            /**
             * @description The contract ABI
             * @example []
             */
            abi: {
                [key: string]: unknown;
            }[];
            /**
             * @description The params for the given function
             * @example {}
             */
            params?: {
                [key: string]: unknown;
            };
        };
        tokenItem: {
            /**
             * @description The contract address
             * @example 0x06012c8cf97bead5deae237070f9587f8e7a266d
             */
            token_address?: string;
            /**
             * @description The id of the token
             * @example 100
             */
            token_id?: string;
        };
        GetMultipleNftsDto: {
            /**
             * @description The tokens to be fetched (max 25 tokens)
             * @example [
             *   {
             *     "token_address": "0xa4991609c508b6d4fb7156426db0bd49fe298bd8",
             *     "token_id": "12"
             *   },
             *   {
             *     "token_address": "0x3c64dc415ebb4690d1df2b6216148c8de6dd29f7",
             *     "token_id": "1"
             *   },
             *   {
             *     "token_address": "0x3c64dc415ebb4690d1df2b6216148c8de6dd29f7",
             *     "token_id": "200"
             *   }
             * ]
             */
            tokens: components["schemas"]["tokenItem"][];
            /**
             * @description Should normalized metadata be returned?
             * @example false
             */
            normalizeMetadata?: boolean;
        };
        transactionCollection: {
            /**
             * @description The total number of matches for this query
             * @example 2000
             */
            total?: number;
            /**
             * @description The current page of the result
             * @example 2
             */
            page?: number;
            /**
             * @description The number of results per page
             * @example 100
             */
            page_size?: number;
            result?: components["schemas"]["transaction"][];
        };
        transactionCollectionVerbose: {
            /**
             * @description The current page of the result
             * @example 2
             */
            page?: number;
            /**
             * @description The number of results per page
             * @example 100
             */
            page_size?: number;
            result?: components["schemas"]["blockTransaction"][];
        };
        transaction: {
            /**
             * @description The hash of the transaction
             * @example 0x057Ec652A4F150f7FF94f089A38008f49a0DF88e
             */
            hash: string;
            /**
             * @description The nonce of the transaction
             * @example 326595425
             */
            nonce: string;
            /**
             * @description The transaction index
             * @example 25
             */
            transaction_index: string;
            /**
             * @description The sender
             * @example 0xd4a3BebD824189481FC45363602b83C9c7e9cbDf
             */
            from_address: string;
            /**
             * @description The recipient
             * @example 0xa71db868318f0a0bae9411347cd4a6fa23d8d4ef
             */
            to_address: string;
            /**
             * @description The value that was transferred (in wei)
             * @example 650000000000000000
             */
            value: string;
            /**
             * @description The gas of the transaction
             * @example 6721975
             */
            gas: string;
            /**
             * @description The gas price
             * @example 20000000000
             */
            gas_price: string;
            /** @description The input */
            input: string;
            /**
             * @description The receipt cumulative gas used
             * @example 1340925
             */
            receipt_cumulative_gas_used: string;
            /**
             * @description The receipt gas used
             * @example 1340925
             */
            receipt_gas_used: string;
            /**
             * @description The receipt contract address
             * @example 0x1d6a4cf64b52f6c73f201839aded7379ce58059c
             */
            receipt_contract_address: string;
            /** @description The receipt root */
            receipt_root: string;
            /**
             * @description The receipt status
             * @example 1
             */
            receipt_status: string;
            /**
             * @description The block timestamp
             * @example 2021-04-02T10:07:54.000Z
             */
            block_timestamp: string;
            /**
             * @description The block number
             * @example 12526958
             */
            block_number: string;
            /**
             * @description The block hash
             * @example 0x0372c302e3c52e8f2e15d155e2c545e6d802e479236564af052759253b20fd86
             */
            block_hash: string;
        };
        erc20Allowance: {
            /** @description The allowance */
            allowance: string;
        };
        erc20TokenBalance: {
            /**
             * @description The address of the token contract
             * @example 0x2d30ca6f024dbc1307ac8a1a44ca27de6f797ec22ef20627a1307243b0ab7d09
             */
            token_address: string;
            /**
             * @description The name of the token contract
             * @example Kylin Network
             */
            name: string;
            /**
             * @description The symbol of the NFT contract
             * @example KYL
             */
            symbol: string;
            /**
             * @description The logo of the token
             * @example https://cdn.moralis.io/eth/0x67b6d479c7bb412c54e03dca8e1bc6740ce6b99c.png
             */
            logo?: string;
            /**
             * @description The thumbnail of the logo
             * @example https://cdn.moralis.io/eth/0x67b6d479c7bb412c54e03dca8e1bc6740ce6b99c_thumb.png
             */
            thumbnail?: string;
            /**
             * @description The number of decimals on the token
             * @example 18
             */
            decimals: number;
            /**
             * @description Timestamp of when the contract was last synced with the node
             * @example 123456789
             */
            balance: string;
        };
        nativeBalance: {
            /**
             * @description The balance
             * @example 1234567890
             */
            balance: string;
        };
        trade: {
            /**
             * @description The transaction hash
             * @example 0x057Ec652A4F150f7FF94f089A38008f49a0DF88e
             */
            transaction_hash: string;
            /** @description The transaction index */
            transaction_index: string;
            /**
             * @description The token ID(s) traded
             * @example [
             *   "15",
             *   "54"
             * ]
             */
            token_ids: string[];
            /**
             * @description The address that sold the NFT
             * @example 0x057Ec652A4F150f7FF94f089A38008f49a0DF88e
             */
            seller_address: string;
            /**
             * @description The address that bought the NFT
             * @example 0x057Ec652A4F150f7FF94f089A38008f49a0DF88e
             */
            buyer_address: string;
            /**
             * @description The address of the contract that traded the NFT
             * @example 0x057Ec652A4F150f7FF94f089A38008f49a0DF88e
             */
            marketplace_address: string;
            /**
             * @description The value that was sent in the transaction (ETH/BNB/etc..)
             * @example 1000000000000000
             */
            price: string;
            /**
             * @description The block timestamp
             * @example 2021-06-04T16:00:15
             */
            block_timestamp: string;
            /**
             * @description The block number of the transaction
             * @example 13680123
             */
            block_number: string;
            /**
             * @description The block hash
             * @example 0x4a7c916ca4a970358b9df90051008f729685ff05e9724a9dddba32630c37cb96
             */
            block_hash: string;
        } & {
            token_address: unknown;
        };
        tradeCollection: {
            /**
             * @description The total number of matches for this query
             * @example 2000
             */
            total?: number;
            /**
             * @description The current page of the result
             * @example 2
             */
            page?: number;
            /**
             * @description The number of results per page
             * @example 100
             */
            page_size?: number;
            result?: components["schemas"]["trade"][];
        };
        /**
         * @default eth
         * @example eth
         * @enum {string}
         */
        chainList: "eth" | "0x1" | "goerli" | "0x5" | "sepolia" | "0xaa36a7" | "polygon" | "0x89" | "mumbai" | "0x13881" | "bsc" | "0x38" | "bsc testnet" | "0x61" | "avalanche" | "0xa86a" | "avalanche testnet" | "0xa869" | "fantom" | "0xfa" | "palm" | "0x2a15c308d" | "cronos" | "0x19" | "cronos testnet" | "0x152" | "arbitrum" | "0xa4b1";
        nft: {
            /**
             * @description The address of the NFT contract
             * @example 0xb47e3cd837dDF8e4c57F05d70Ab865de6e193BBB
             */
            token_address: string;
            /**
             * @description The token ID of the NFT
             * @example 15
             */
            token_id: string;
            /**
             * @description The wallet address of the owner of the NFT
             * @example 0x9c83ff0f1c8924da96cb2fcb7e093f78eb2e316b
             */
            owner_of?: string;
            /**
             * @description The token hash
             * @example 502cee781b0fb40ea02508b21d319ced
             */
            token_hash?: string;
            /**
             * @description The block number when the amount or owner changed
             * @example 88256
             */
            block_number?: string;
            /**
             * @description The block number when the NFT was minted
             * @example 88256
             */
            block_number_minted?: string;
            /**
             * @description The type of NFT contract standard
             * @example ERC721
             */
            contract_type: string;
            /** @description The URI to the metadata of the token */
            token_uri?: string;
            /** @description The metadata of the token */
            metadata?: string;
            /** @description A normalized metadata version of the NFT's metadata. */
            normalized_metadata?: components["schemas"]["normalizedMetadata"];
            /**
             * @description The address that minted the NFT
             * @example 0x9c83ff0f1c8924da96cb2fcb7e093f78eb2e316b
             */
            minter_address?: string;
            /** @description When the token_uri was last updated */
            last_token_uri_sync?: string;
            /** @description When the metadata was last updated */
            last_metadata_sync?: string;
            /**
             * @description The quantity of this item that the user owns (used by ERC1155)
             * @example 1
             */
            amount?: string;
            /**
             * @description The name of the NFT contract
             * @example CryptoKitties
             */
            name: string;
            /**
             * @description The symbol of the NFT contract
             * @example RARI
             */
            symbol: string;
        };
        nftMetadata: {
            /**
             * @description The token ID of the NFT
             * @example 889
             */
            token_id: string;
            /**
             * @description The address of the NFT contract
             * @example 0x8ce66ff0865570d1ff0bb0098fa41b4dc61e02e6
             */
            token_address: string;
            /**
             * @description The URI to the metadata of the token
             * @example https://ipfs.moralis.io:2053/ipfs/QmZZbo8u8zEWg7wtmZhJS2W718WL6FA95T4XdgmCcLp1SJ/889.json
             */
            token_uri: string;
            /**
             * @description The metadata of the token
             * @example {"name":"Bape #889","description":"The #1 metavestor clan (NFT/DAO) by a team with multi billion dollar company experience.","image":"https://bapesclan.mypinata.cloud/ipfs/QmTSUD5JA6qHaC5t25mcXySfz19AV9u4Mb6Na7ntQ6tEwf/889.jpg","attributes":[{"trait_type":"Background","value":"Black"},{"trait_type":"Body","value":"Man"},{"trait_type":"Dress","value":"Suit Tie Blue"},{"trait_type":"Face","value":"Pipe"},{"trait_type":"Eye","value":"Eye"}]}
             */
            metadata: string;
            /** @example 1 */
            is_valid: number;
            /** @example 2 */
            syncing: number;
            /** @example 0 */
            frozen: number;
            /** @example 0 */
            resyncing: number;
            /**
             * @description The type of NFT contract standard
             * @example ERC721
             */
            contract_type: string;
            /** @example fffa3102469ce77f569893d16d5884f9 */
            token_hash: string;
            /** @example fd995c8a-f8b2-40cb-a407-f43e552638b4 */
            batch_id: string;
            /** @example Bape #889 */
            metadata_name: string;
            /** @example The #1 metavestor clan (NFT/DAO) by a team with multi billion dollar company experience. */
            metadata_description: string;
            /** @example [{"trait_type":"Background","value":"Black"},{"trait_type":"Body","value":"Man"},{"trait_type":"Dress","value":"Suit Tie Blue"},{"trait_type":"Face","value":"Pipe"},{"trait_type":"Eye","value":"Eye"}] */
            metadata_attributes: string;
            /** @example 14265936 */
            block_number_minted: string;
            /** @example null */
            opensea_lookup?: {
                [key: string]: unknown;
            };
            /** @example 0xdcf086e3f7954b38180daae1405569da86588bfe */
            minter_address: string;
            /** @example 0x2c8d7ec7a8439b0f67b50e93be63242de52e9b5cdfc7dc0aee80c6a2f104c41a */
            transaction_minted: string;
            /** @example null */
            frozen_log_index?: {
                [key: string]: unknown;
            };
            /** @example null */
            imported?: {
                [key: string]: unknown;
            };
            /**
             * @description When the token_uri was last updated
             * @example 2021-02-24T00:47:26.647Z
             */
            last_token_uri_sync: string;
            /**
             * @description When the metadata was last updated
             * @example 2021-02-24T00:47:26.647Z
             */
            last_metadata_sync: string;
            /**
             * Format: date-time
             * @example 2022-02-24T00:47:26.647Z
             */
            createdAt: string;
            /**
             * Format: date-time
             * @example 2022-04-09T23:56:44.807Z
             */
            updatedAt: string;
        };
        nftWalletCollections: {
            /**
             * @description The syncing status of the address [SYNCING/SYNCED]
             * @example SYNCING
             */
            status?: string;
            /**
             * @description The total number of matches for this query
             * @example 2000
             */
            total?: number;
            /**
             * @description The current page of the result
             * @example 2
             */
            page?: number;
            /**
             * @description The number of results per page
             * @example 100
             */
            page_size?: number;
            /** @description The cursor to get to the next page */
            cursor?: string;
            result?: components["schemas"]["nftCollections"][];
        };
        nftCollection: {
            /**
             * @description The total number of matches for this query
             * @example 2000
             */
            total?: number;
            /**
             * @description The current page of the result
             * @example 2
             */
            page?: number;
            /**
             * @description The number of results per page
             * @example 100
             */
            page_size?: number;
            /** @description The cursor to get to the next page */
            cursor?: string;
            result?: components["schemas"]["nft"][];
        };
        nftMetadataCollection: {
            /**
             * @description The total number of matches for this query
             * @example 2000
             */
            total?: number;
            /**
             * @description The current page of the result
             * @example 2
             */
            page?: number;
            /**
             * @description The number of results per page
             * @example 100
             */
            page_size?: number;
            result?: components["schemas"]["nftMetadata"][];
        };
        nftCollections: {
            /**
             * @description The address of the NFT contract
             * @example 0xb47e3cd837dDF8e4c57F05d70Ab865de6e193BBB
             */
            token_address: string;
            /**
             * @description The type of NFT contract standard
             * @example ERC721
             */
            contract_type: string;
            /**
             * @description The name of the NFT contract
             * @example CryptoKitties
             */
            name: string;
            /**
             * @description The symbol of the NFT contract
             * @example RARI
             */
            symbol: string;
        };
        nftOwner: {
            /**
             * @description The address of the NFT contract
             * @example 0xb47e3cd837dDF8e4c57F05d70Ab865de6e193BBB
             */
            token_address: string;
            /**
             * @description The token ID of the NFT
             * @example 15
             */
            token_id: string;
            /**
             * @description The type of NFT contract standard
             * @example ERC721
             */
            contract_type: string;
            /**
             * @description The wallet address of the owner of the NFT
             * @example 0x057Ec652A4F150f7FF94f089A38008f49a0DF88e
             */
            owner_of: string;
            /**
             * @description The block number when the amount or owner changed
             * @example 88256
             */
            block_number: string;
            /**
             * @description The block number when the NFT was minted
             * @example 88256
             */
            block_number_minted: string;
            /** @description The URI to the metadata of the token */
            token_uri?: string;
            /** @description The metadata of the token */
            metadata?: string;
            /** @description A normalized metadata version of the NFT's metadata. */
            normalized_metadata?: components["schemas"]["normalizedMetadata"];
            /**
             * @description The number of this item the user owns (used by ERC1155)
             * @example 1
             */
            amount?: string;
            /**
             * @description The name of the NFT contract
             * @example CryptoKitties
             */
            name: string;
            /**
             * @description The symbol of the NFT contract
             * @example RARI
             */
            symbol: string;
            /**
             * @description The token hash
             * @example 502cee781b0fb40ea02508b21d319ced
             */
            token_hash: string;
            /**
             * @description When the token_uri was last updated
             * @example 2021-02-24T00:47:26.647Z
             */
            last_token_uri_sync: string;
            /**
             * @description When the metadata was last updated
             * @example 2021-02-24T00:47:26.647Z
             */
            last_metadata_sync: string;
        };
        normalizedMetadataAttribute: {
            /**
             * @description The trait title or descriptor
             * @example Eye Color
             */
            trait_type?: string;
            /**
             * @description The value of the attribute
             * @example hazel
             */
            value?: {
                [key: string]: unknown;
            };
            /**
             * @description The type the attribute value should be displayed as
             * @example string
             */
            display_type?: string;
            /**
             * @description For numeric values, the upper range
             * @example 100
             */
            max_value?: number;
            /**
             * @description The number of possible values for this trait
             * @example 7
             */
            trait_count?: number;
            /**
             * @description Order the trait should appear in the attribute list.
             * @example 1
             */
            order?: number;
        };
        normalizedMetadata: {
            /**
             * @description The name or title of the NFT
             * @example Moralis Mug
             */
            name?: string;
            /**
             * @description A detailed description of the NFT
             * @example Moralis Coffee nug 3D Asset that can be used in 3D worldspaces. This NFT is presented as a flat PNG, a Unity3D Prefab and a standard fbx.
             */
            description?: string;
            /**
             * @description The URL of the NFT's image
             * @example https://arw2wxg84h6b.moralishost.com:2053/server/files/tNJatzsHirx4V2VAep6sc923OYGxvkpBeJttR7Ks/de504bbadadcbe30c86278342fcf2560_moralismug.png
             */
            image?: string;
            /**
             * @description A link to additional information
             * @example https://giphy.com/gifs/loop-recursion-ting-aaODAv1iuQdgI
             */
            external_link?: string;
            /**
             * @description An animated version of the NFT's image
             * @example https://giphy.com/gifs/food-design-donuts-o9ngTPVYW4qo8
             */
            animation_url?: string;
            attributes?: components["schemas"]["normalizedMetadataAttribute"][];
        };
        nftOwnerCollection: {
            /**
             * @description The syncing status of the address [SYNCING/SYNCED]
             * @example SYNCING
             */
            status?: string;
            /**
             * @description The total number of matches for this query
             * @example 2000
             */
            total?: number;
            /**
             * @description The current page of the result
             * @example 2
             */
            page?: number;
            /**
             * @description The number of results per page
             * @example 100
             */
            page_size?: number;
            /** @description The cursor to get to the next page */
            cursor?: string;
            result?: components["schemas"]["nftOwner"][];
        };
        nftTransfer: {
            /**
             * @description The address of the NFT contract
             * @example 0x057Ec652A4F150f7FF94f089A38008f49a0DF88e
             */
            token_address: string;
            /**
             * @description The token ID of the NFT
             * @example 15
             */
            token_id: string;
            /**
             * @description The address that sent the NFT
             * @example 0x057Ec652A4F150f7FF94f089A38008f49a0DF88e
             */
            from_address?: string;
            /**
             * @description The address that received the NFT
             * @example 0x057Ec652A4F150f7FF94f089A38008f49a0DF88e
             */
            to_address: string;
            /**
             * @description The value that was sent in the transaction (ETH/BNB/etc..)
             * @example 1000000000000000
             */
            value?: string;
            /**
             * @description The number of tokens transferred
             * @example 1
             */
            amount?: string;
            /**
             * @description The type of NFT contract standard
             * @example ERC721
             */
            contract_type: string;
            /**
             * @description The block number of the transaction
             * @example 88256
             */
            block_number: string;
            /**
             * @description The block timestamp
             * @example 2021-06-04T16:00:15
             */
            block_timestamp: string;
            /** @description The block hash of the transaction */
            block_hash: string;
            /**
             * @description The transaction hash
             * @example 0x057Ec652A4F150f7FF94f089A38008f49a0DF88e
             */
            transaction_hash: string;
            /** @description The transaction type */
            transaction_type?: string;
            /** @description The transaction index */
            transaction_index?: number;
            /** @description The log index */
            log_index: number;
            /**
             * @description The operator present only for ERC1155 transfers
             * @example 0x057Ec652A4F150f7FF94f089A38008f49a0DF88e
             */
            operator?: string;
        };
        nftTransferCollection: {
            /**
             * @description The total number of matches for this query
             * @example 2000
             */
            total: number;
            /**
             * @description The current page of the result
             * @example 2
             */
            page: number;
            /**
             * @description The number of results per page
             * @example 100
             */
            page_size: number;
            /** @description The cursor to get to the next page */
            cursor: string;
            result: components["schemas"]["nftTransfer"][];
            /**
             * @description Indicator if the block exists
             * @example true
             */
            block_exists?: boolean;
            /**
             * @description Indicator if the block is fully indexed
             * @example true
             */
            index_complete?: boolean;
        };
        nftContractMetadata: {
            /**
             * @description The address of the token contract
             * @example 0x2d30ca6f024dbc1307ac8a1a44ca27de6f797ec22ef20627a1307243b0ab7d09
             */
            token_address: string;
            /**
             * @description The name of the token contract
             * @example KryptoKitties
             */
            name: string;
            /** @description Timestamp of when the contract was last synced with the node */
            synced_at?: string;
            /**
             * @description The symbol of the NFT contract
             * @example RARI
             */
            symbol: string;
            /**
             * @description The type of NFT contract
             * @example ERC721
             */
            contract_type: string;
        };
        nftContractMetadataCollection: {
            /**
             * @description The total number of matches for this query
             * @example 2000
             */
            total: number;
            /**
             * @description The current page of the result
             * @example 2
             */
            page: number;
            /**
             * @description The number of results per page
             * @example 100
             */
            page_size: number;
            result: components["schemas"]["nftContractMetadata"][];
        };
        erc20Transaction: {
            /**
             * @description The transaction hash
             * @example 0x2d30ca6f024dbc1307ac8a1a44ca27de6f797ec22ef20627a1307243b0ab7d09
             */
            transaction_hash: string;
            /**
             * @description The address of the token
             * @example 0x057Ec652A4F150f7FF94f089A38008f49a0DF88e
             */
            address: string;
            /**
             * @description The block timestamp
             * @example 2021-04-02T10:07:54.000Z
             */
            block_timestamp: string;
            /**
             * @description The block number
             * @example 12526958
             */
            block_number: string;
            /**
             * @description The block hash
             * @example 0x0372c302e3c52e8f2e15d155e2c545e6d802e479236564af052759253b20fd86
             */
            block_hash: string;
            /**
             * @description The recipient
             * @example 0x62AED87d21Ad0F3cdE4D147Fdcc9245401Af0044
             */
            to_address: string;
            /**
             * @description The sender
             * @example 0xd4a3BebD824189481FC45363602b83C9c7e9cbDf
             */
            from_address: string;
            /**
             * @description The value that was transferred (in wei)
             * @example 650000000000000000
             */
            value: string;
            /**
             * @description The transaction index of the transfer within the block
             * @example 12
             */
            transaction_index: number;
            /**
             * @description The log index of the transfer within the block
             * @example 2
             */
            log_index: number;
        };
        historicalNftTransfer: {
            /**
             * @description The transaction hash
             * @example 0x2d30ca6f024dbc1307ac8a1a44ca27de6f797ec22ef20627a1307243b0ab7d09
             */
            transaction_hash: string;
            /**
             * @description The address of the token
             * @example 0x057Ec652A4F150f7FF94f089A38008f49a0DF88e
             */
            address: string;
            /**
             * @description The block timestamp
             * @example 2021-04-02T10:07:54.000Z
             */
            block_timestamp: string;
            /**
             * @description The block number
             * @example 12526958
             */
            block_number: string;
            /**
             * @description The block hash
             * @example 0x0372c302e3c52e8f2e15d155e2c545e6d802e479236564af052759253b20fd86
             */
            block_hash: string;
            /**
             * @description The recipient
             * @example 0x62AED87d21Ad0F3cdE4D147Fdcc9245401Af0044
             */
            to_address: string;
            /**
             * @description The sender
             * @example 0xd4a3BebD824189481FC45363602b83C9c7e9cbDf
             */
            from_address: string;
            /** @description The token ids of the tokens that were transferred */
            token_ids: string[];
            /** @description The amounts that were transferred */
            amounts: string[];
            /**
             * @description They contract type of the transfer
             * @example ERC721
             */
            contract_type: string;
        };
        erc20Metadata: {
            /**
             * @description The address of the token contract
             * @example 0x2d30ca6f024dbc1307ac8a1a44ca27de6f797ec22ef20627a1307243b0ab7d09
             */
            address: string;
            /**
             * @description The name of the token contract
             * @example Kylin Network
             */
            name: string;
            /**
             * @description The symbol of the NFT contract
             * @example KYL
             */
            symbol: string;
            /**
             * @description The number of decimals on the token
             * @example 18
             */
            decimals: string;
            /**
             * @description The logo of the token
             * @example https://cdn.moralis.io/eth/0x67b6d479c7bb412c54e03dca8e1bc6740ce6b99c.png
             */
            logo?: string;
            /**
             * @description The logo hash
             * @example ee7aa2cdf100649a3521a082116258e862e6971261a39b5cd4e4354fcccbc54d
             */
            logo_hash?: string;
            /**
             * @description The thumbnail of the logo
             * @example https://cdn.moralis.io/eth/0x67b6d479c7bb412c54e03dca8e1bc6740ce6b99c_thumb.png
             */
            thumbnail?: string;
            block_number?: string;
            validated?: string;
        };
        metadataResync: {
            /** @description The status of the resync request */
            status: string;
        };
        erc721Metadata: {
            /**
             * @description The name of the token contract
             * @example Kylin Network
             */
            name: string;
            /**
             * @description The symbol of the NFT contract
             * @example KYL
             */
            symbol: string;
            token_uri?: string;
        };
        erc20Price: {
            nativePrice?: components["schemas"]["nativeErc20Price"];
            /**
             * Format: double
             * @description The price in USD for the token
             * @example 19.722370676
             */
            usdPrice: number;
            /**
             * @description The address of the exchange used to calculate the price
             * @example 0x1f98431c8ad98523631ae4a59f267346ea31f984
             */
            exchangeAddress?: string;
            /**
             * @description The name of the exchange used to calculate the price
             * @example Uniswap v3
             */
            exchangeName?: string;
        };
        nativeErc20Price: {
            /**
             * @description The native price of the token
             * @example 8409770570506626
             */
            value: string;
            /**
             * @description The number of decimals on the token
             * @example 18
             */
            decimals: number;
            /**
             * @description The name of the token
             * @example Ether
             */
            name: string;
            /**
             * @description The symbol of the token
             * @example ETH
             */
            symbol: string;
        };
        erc20TransactionCollection: {
            /**
             * @description The total number of matches for this query
             * @example 2000
             */
            total?: number;
            /**
             * @description The current page of the result
             * @example 2
             */
            page?: number;
            /**
             * @description The number of results per page
             * @example 100
             */
            page_size?: number;
            result?: components["schemas"]["erc20Transaction"][];
        };
        ens: {
            /**
             * @description Resolved ENS address
             * @example Vitalik.eth
             */
            name: string;
        };
        resolve: {
            /**
             * @description Resolved domain address
             * @example 0x057Ec652A4F150f7FF94f089A38008f49a0DF88e
             */
            address: string;
        };
        reservesPair: {
            /** @example 220969226548536862025877 */
            reserve0?: string;
            /** @example 844810441191293211036 */
            reserve1?: string;
        };
        reservesCollection: {
            token0?: {
                /** @example 0x2b591e99afe9f32eaa6214f7b7629768c40eeb39 */
                address?: string;
                /** @example HEX */
                name?: string;
                /** @example HEX */
                symbol?: string;
                /** @example 9 */
                decimals?: string;
                /** @example https://cdn.moralis.io/eth/0x2b591e99afe9f32eaa6214f7b7629768c40eeb39.png */
                logo?: string;
                /** @example b3bd1b5512965d7b6aeee903dcc6d28b116d58c788eb41e9c1690baed878beaa */
                logo_hash?: string;
                /** @example https://cdn.moralis.io/eth/0x2b591e99afe9f32eaa6214f7b7629768c40eeb39_thumb.png */
                thumbnail?: string;
                /** @example 14836562 */
                block_number?: string;
                /** @example 0 */
                validated?: number;
                /** @example 2022-01-20T09:39:55.818Z */
                created_at?: string;
            };
            token1?: {
                /** @example 0xdac17f958d2ee523a2206206994597c13d831ec7 */
                address?: string;
                /** @example Tether USD */
                name?: string;
                /** @example USDT */
                symbol?: string;
                /** @example 6 */
                decimals?: string;
                /** @example https://cdn.moralis.io/eth/0xdac17f958d2ee523a2206206994597c13d831ec7.png */
                logo?: string;
                /** @example ee7aa2cdf100649a3521a082116258e862e6971261a39b5cd4e4354fcccbc54d */
                logo_hash?: string;
                /** @example https://cdn.moralis.io/eth/0xdac17f958d2ee523a2206206994597c13d831ec7_thumb.png */
                thumbnail?: string;
                /** @example 4638568 */
                block_number?: string;
                /** @example 1 */
                validated?: number;
                /** @example 2022-01-20T09:39:55.818Z */
                created_at?: string;
            };
            /** @example 0xbbb9bf440d0f686487925fef3b0a0f9aa67753f6 */
            pairAddress?: string;
        };
        ipfsFileRequest: {
            /**
             * @description Path to the file
             * @example moralis/logo.jpg
             */
            path: string;
            /**
             * @description Base64 or JSON
             * @example iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAABHNCSVQICAgIfAhkiAAAAAlwSFlzAAAApgAAAKYB3X3
             */
            content: string;
        };
        ipfsFile: {
            /**
             * @description Path to the file
             * @example https://ipfs.moralis.io/QmPQ3YJ3hgfsBzJ1U4MGyV2C1GhDy6MWCENr1qMdMpKVnY/moralis/logo.jpg
             */
            path: string;
        };
        web3version: {
            /**
             * @description The version of the API
             * @example 1.0.0
             */
            version: string;
        };
        endpointWeights: {
            /**
             * @description endpoint
             * @example endpointWeights
             */
            endpoint: string;
            /**
             * @description The path to the endpoint
             * @example /info/endpointWeights
             */
            path: string;
            /**
             * @description The number of hits the request counts towards rate limiting
             * @example 1
             */
            rateLimitCost: string;
            /**
             * @description The number of compute units the request counts towards billing
             * @example 0
             */
            price: string;
        };
        nativeBalances: {
            /**
             * @description The chain
             * @example eth_mainnet
             */
            chain: string;
            /**
             * @description The chain id
             * @example 2
             */
            chain_id: string;
            /**
             * @description The total balances for all the walttes
             * @example 57499206466583095
             */
            total_balance: string;
            /**
             * @description The block Number
             * @example 123456789
             */
            block_number: string;
            /**
             * @description The block timestamp
             * @example 0.057
             */
            block_timestamp: string;
            /**
             * @description The total balances for all the walttes formatted
             * @example 123456789
             */
            total_balance_formatted: string;
            wallet_balances: {
                /**
                 * @description address
                 * @example 0x123
                 */
                address: string;
                /**
                 * @description balance
                 * @example 28499206466583095
                 */
                balance: string;
                /**
                 * @description balance formatted
                 * @example 0.0285
                 */
                balance_formatted: string;
            }[];
        }[];
    };
}
interface operations$1 {
    /**
     * Get NFTs owned by a given address.
     * * The response will include status [SYNCED/SYNCING] based on the contracts being indexed.
     * * Use the token_address param to get results for a specific contract only
     * * Note that results will include all indexed NFTs
     * * Any request that includes the token_address param will start the indexing process for that NFT collection the very first time it is requested.
     */
    getWalletNFTs: {
        parameters: {
            query: {
                /** The chain to query */
                chain?: components["schemas"]["chainList"];
                /** The format of the token ID */
                format?: "decimal" | "hex";
                /** The desired page size of the result. */
                limit?: number;
                /** If the result should skip returning the total count (Improves performance). */
                disable_total?: boolean;
                /** The addresses to get balances for (optional) */
                token_addresses?: string[];
                /** The cursor returned in the previous response (used for getting the next page). */
                cursor?: string;
                /** Should normalized metadata be returned? */
                normalizeMetadata?: boolean;
            };
            path: {
                /** The address of the wallet */
                address: string;
            };
        };
        responses: {
            /** Returns a collection of NFT owners */
            200: {
                content: {
                    "application/json": components["schemas"]["nftOwnerCollection"];
                };
            };
        };
    };
    /**
     * Returns an array of NFTs specified in the request.
     * * Note that results will include all indexed NFTs
     * * Any request that includes the token_address param will start the indexing process for that NFT collection the very first time it is requested.
     * * Only 25 NFTs can be fetched in one API call.
     */
    getMultipleNFTs: {
        parameters: {
            query: {
                /** The chain to query */
                chain?: components["schemas"]["chainList"];
            };
        };
        responses: {
            /** Returns a collection of NFT owners */
            200: {
                content: {
                    "application/json": components["schemas"]["nftOwner"][];
                };
            };
        };
        /** Body */
        requestBody: {
            content: {
                "application/json": components["schemas"]["GetMultipleNftsDto"];
            };
        };
    };
    /** Get transfers of NFTs given the wallet and other parameters. */
    getWalletNFTTransfers: {
        parameters: {
            query: {
                /** The chain to query */
                chain?: components["schemas"]["chainList"];
                /** The format of the token ID */
                format?: "decimal" | "hex";
                /** The transfer direction */
                direction?: "both" | "to" | "from";
                /**
                 * The minimum block number from which to get the transfers
                 * * Provide the param 'from_block' or 'from_date'
                 * * If 'from_date' and 'from_block' are provided, 'from_block' will be used.
                 */
                from_block?: number;
                /** To get the reserves at this block number */
                to_block?: string;
                /** The desired page size of the result. */
                limit?: number;
                /** If the result should skip returning the total count (Improves performance). */
                disable_total?: boolean;
                /** The cursor returned in the previous response (used for getting the next page). */
                cursor?: string;
            };
            path: {
                /** The wallet address of the sender or recipient of the transfers */
                address: string;
            };
        };
        responses: {
            /** Returns a collection of NFT transfers */
            200: {
                content: {
                    "application/json": components["schemas"]["nftTransferCollection"];
                };
            };
        };
    };
    /** Get NFT collections owned by a given wallet address. */
    getWalletNFTCollections: {
        parameters: {
            query: {
                /** The chain to query */
                chain?: components["schemas"]["chainList"];
                /** The desired page size of the result. */
                limit?: number;
                /** If the result should skip returning the total count (Improves performance). */
                disable_total?: boolean;
                /** The cursor returned in the previous response (used for getting the next page). */
                cursor?: string;
            };
            path: {
                /** The wallet address of the owner of NFTs in the collections */
                address: string;
            };
        };
        responses: {
            /** Returns the NFT collections owned by a wallet */
            200: {
                content: {
                    "application/json": components["schemas"]["nftWalletCollections"];
                };
            };
        };
    };
    /**
     * Get NFTs for a given contract address, including metadata for all NFTs (where available).
     * * Results are limited to 100 per page by default
     * * Requests for contract addresses not yet indexed will automatically start the indexing process for that NFT collection.
     */
    getContractNFTs: {
        parameters: {
            query: {
                /** The chain to query */
                chain?: components["schemas"]["chainList"];
                /** The format of the token ID */
                format?: "decimal" | "hex";
                /** The desired page size of the result. */
                limit?: number;
                /** If the result should skip returning the total count (Improves performance). */
                disable_total?: boolean;
                /** The number of subranges to split the results into */
                totalRanges?: number;
                /** The desired subrange to query */
                range?: number;
                /** The cursor returned in the previous response (used for getting the next page). */
                cursor?: string;
                /** Should normalized metadata be returned? */
                normalizeMetadata?: boolean;
            };
            path: {
                /** The address of the NFT contract */
                address: string;
            };
        };
        responses: {
            /** Returns a collection of NFTs */
            200: {
                content: {
                    "application/json": components["schemas"]["nftCollection"];
                };
            };
        };
    };
    /**
     * Get owners of NFTs for a given contract.
     * * Requests for contract addresses not yet indexed will automatically start the indexing process for that NFT collection.
     */
    getNFTOwners: {
        parameters: {
            query: {
                /** The chain to query */
                chain?: components["schemas"]["chainList"];
                /** The format of the token ID */
                format?: "decimal" | "hex";
                /** The desired page size of the result. */
                limit?: number;
                /** If the result should skip returning the total count (Improves performance). */
                disable_total?: boolean;
                /** The cursor returned in the previous response (used for getting the next page). */
                cursor?: string;
                /** Should normalized metadata be returned? */
                normalizeMetadata?: boolean;
            };
            path: {
                /** The address of the NFT contract */
                address: string;
            };
        };
        responses: {
            /** Returns a collection of NFT owners */
            200: {
                content: {
                    "application/json": components["schemas"]["nftOwnerCollection"];
                };
            };
        };
    };
    /** Get transfers of NFTs for a given contract and other parameters. */
    getNFTContractTransfers: {
        parameters: {
            query: {
                /** The chain to query */
                chain?: components["schemas"]["chainList"];
                /**
                 * The minimum block number from where to get the transfers
                 * * Provide the param 'from_block' or 'from_date'
                 * * If 'from_date' and 'from_block' are provided, 'from_block' will be used.
                 */
                from_block?: number;
                /**
                 * The maximum block number from where to get the transfers.
                 * * Provide the param 'to_block' or 'to_date'
                 * * If 'to_date' and 'to_block' are provided, 'to_block' will be used.
                 */
                to_block?: number;
                /**
                 * The date from where to get the transfers (any format that is accepted by momentjs)
                 * * Provide the param 'from_block' or 'from_date'
                 * * If 'from_date' and 'from_block' are provided, 'from_block' will be used.
                 */
                from_date?: string;
                /**
                 * Get transfers up until this date (any format that is accepted by momentjs)
                 * * Provide the param 'to_block' or 'to_date'
                 * * If 'to_date' and 'to_block' are provided, 'to_block' will be used.
                 */
                to_date?: string;
                /** The format of the token ID */
                format?: "decimal" | "hex";
                /** The desired page size of the result. */
                limit?: number;
                /** If the result should skip returning the total count (Improves performance). */
                disable_total?: boolean;
                /** The cursor returned in the previous response (used for getting the next page). */
                cursor?: string;
            };
            path: {
                /** The address of the NFT contract */
                address: string;
            };
        };
        responses: {
            /** Returns a collection of NFT transfers */
            200: {
                content: {
                    "application/json": components["schemas"]["nftTransferCollection"];
                };
            };
        };
    };
    /** Get transfers of NFTs from a block number to a block number. */
    getNFTTransfersFromToBlock: {
        parameters: {
            query: {
                /** The chain to query */
                chain?: components["schemas"]["chainList"];
                /**
                 * The minimum block number from which to get the transfers
                 * * Provide the param 'from_block' or 'from_date'
                 * * If 'from_date' and 'from_block' are provided, 'from_block' will be used.
                 */
                from_block?: number;
                /**
                 * The maximum block number from which to get the transfers.
                 * * Provide the param 'to_block' or 'to_date'
                 * * If 'to_date' and 'to_block' are provided, 'to_block' will be used.
                 */
                to_block?: number;
                /**
                 * The start date from which to get the transfers (any format that is accepted by momentjs)
                 * * Provide the param 'from_block' or 'from_date'
                 * * If 'from_date' and 'from_block' are provided, 'from_block' will be used.
                 */
                from_date?: string;
                /**
                 * The end date from which to get the transfers (any format that is accepted by momentjs)
                 * * Provide the param 'to_block' or 'to_date'
                 * * If 'to_date' and 'to_block' are provided, 'to_block' will be used.
                 */
                to_date?: string;
                /** The format of the token ID */
                format?: "decimal" | "hex";
                /** The desired page size of the result. */
                limit?: number;
                /** If the result should skip returning the total count (Improves performance). */
                disable_total?: boolean;
                /** The cursor returned in the previous response (for getting the next page) */
                cursor?: string;
            };
        };
        responses: {
            /** Returns a collection of NFT transfers */
            200: {
                content: {
                    "application/json": components["schemas"]["nftTransferCollection"];
                };
            };
        };
    };
    /** Get transfers of NFTs given a block number or block hash. */
    getNFTTransfersByBlock: {
        parameters: {
            query: {
                /** The chain to query */
                chain?: components["schemas"]["chainList"];
                /** The desired page size of the result. */
                limit?: number;
                /** If the result should skip returning the total count (Improves performance). */
                disable_total?: boolean;
                /** The cursor returned in the previous response (used for getting the next page). */
                cursor?: string;
            };
            path: {
                /** The block number or block hash */
                block_number_or_hash: string;
            };
        };
        responses: {
            /** Returns the contents of a block */
            200: {
                content: {
                    "application/json": components["schemas"]["nftTransferCollection"];
                };
            };
        };
    };
    /** Get trades of NFTs for a given contract and marketplace. */
    getNFTTrades: {
        parameters: {
            query: {
                /** The chain to query */
                chain?: components["schemas"]["chainList"];
                /**
                 * The minimum block number from which to get the transfers
                 * * Provide the param 'from_block' or 'from_date'
                 * * If 'from_date' and 'from_block' are provided, 'from_block' will be used.
                 */
                from_block?: number;
                /** The block number to get the trades from */
                to_block?: string;
                /**
                 * The start date from which to get the transfers (any format that is accepted by momentjs)
                 * * Provide the param 'from_block' or 'from_date'
                 * * If 'from_date' and 'from_block' are provided, 'from_block' will be used.
                 */
                from_date?: string;
                /**
                 * The end date from which to get the transfers (any format that is accepted by momentjs)
                 * * Provide the param 'to_block' or 'to_date'
                 * * If 'to_date' and 'to_block' are provided, 'to_block' will be used.
                 */
                to_date?: string;
                /** Marketplace from which to get the trades (only OpenSea is supported at the moment) */
                marketplace?: "opensea";
                /** The cursor returned in the previous response (used for getting the next page). */
                cursor?: string;
                /** The desired page size of the result. */
                limit?: number;
                /** If the result should skip returning the total count (Improves performance). */
                disable_total?: boolean;
            };
            path: {
                /** The address of the NFT contract */
                address: string;
            };
        };
        responses: {
            /** Returns the trades */
            200: {
                content: {
                    "application/json": components["schemas"]["tradeCollection"];
                };
            };
        };
    };
    /**
     * Get the collection / contract level metadata for a given contract (name, symbol, base token URI).
     * * Requests for contract addresses not yet indexed will automatically start the indexing process for that NFT collection
     */
    getNFTContractMetadata: {
        parameters: {
            query: {
                /** The chain to query */
                chain?: components["schemas"]["chainList"];
            };
            path: {
                /** The address of the NFT contract */
                address: string;
            };
        };
        responses: {
            /** Returns the metadata for an NFT collection. */
            200: {
                content: {
                    "application/json": components["schemas"]["nftContractMetadata"];
                };
            };
        };
    };
    /**
     * Get NFT data, including metadata (where available), for the given NFT token ID and contract address.
     * * Requests for contract addresses not yet indexed will automatically start the indexing process for that NFT collection
     */
    getNFTMetadata: {
        parameters: {
            query: {
                /** The chain to query */
                chain?: components["schemas"]["chainList"];
                /** The format of the token ID */
                format?: "decimal" | "hex";
                /** Should normalized metadata be returned? */
                normalizeMetadata?: boolean;
            };
            path: {
                /** The address of the NFT contract */
                address: string;
                /** The ID of the token */
                token_id: string;
            };
        };
        responses: {
            /** Returns the specified NFT. */
            200: {
                content: {
                    "application/json": components["schemas"]["nft"];
                };
            };
        };
    };
    /** Get transfers of an NFT given a contract address and token ID. */
    getNFTTransfers: {
        parameters: {
            query: {
                /** The chain to query */
                chain?: components["schemas"]["chainList"];
                /** The format of the token ID */
                format?: "decimal" | "hex";
                /** The desired page size of the result. */
                limit?: number;
                /** If the result should skip returning the total count (Improves performance). */
                disable_total?: boolean;
                /** The cursor returned in the previous response (used for getting the next page). */
                cursor?: string;
            };
            path: {
                /** The address of the NFT contract */
                address: string;
                /** The ID of the token */
                token_id: string;
            };
        };
        responses: {
            /** Returns a collection of NFT transfers */
            200: {
                content: {
                    "application/json": components["schemas"]["nftTransferCollection"];
                };
            };
        };
    };
    /**
     * Get owners of a specific NFT given the contract address and token ID.
     * * Requests for contract addresses not yet indexed will automatically start the indexing process for that NFT collection
     */
    getNFTTokenIdOwners: {
        parameters: {
            query: {
                /** The chain to query */
                chain?: components["schemas"]["chainList"];
                /** The format of the token ID */
                format?: "decimal" | "hex";
                /** The desired page size of the result. */
                limit?: number;
                /** If the result should skip returning the total count (Improves performance). */
                disable_total?: boolean;
                /** The cursor returned in the previous response (used for getting the next page). */
                cursor?: string;
                /** Should normalized metadata be returned? */
                normalizeMetadata?: boolean;
            };
            path: {
                /** The address of the NFT contract */
                address: string;
                /** The ID of the token */
                token_id: string;
            };
        };
        responses: {
            /** Returns a collection of NFTs with their respective owners. */
            200: {
                content: {
                    "application/json": components["schemas"]["nftOwnerCollection"];
                };
            };
        };
    };
    /** Initiates a sync of a previously non synced contract. */
    syncNFTContract: {
        parameters: {
            query: {
                /** The chain to query */
                chain?: components["schemas"]["chainList"];
            };
            path: {
                /** The address of the NFT contract */
                address: string;
            };
        };
        responses: {
            /** Contract address was triggered for index. */
            201: unknown;
        };
    };
    /**
     * Resync the metadata for an NFT
     * * The metadata flag will request the NFT's metadata from an already existing token_uri
     * * The uri (default) flag will fetch the latest token_uri from the given NFT contract address. In sync mode the metadata will also be fetched
     * * The sync mode will make the endpoint synchronous so it will wait for the task to be completed before responding
     * * The async mode (default) will make the endpoint asynchronous so we will wait for the task to be completed before responding
     */
    reSyncMetadata: {
        parameters: {
            query: {
                /** The chain to query */
                chain?: components["schemas"]["chainList"];
                /** The type of resync to operate */
                flag?: "uri" | "metadata";
                /** To define the behaviour of the endpoint */
                mode?: "async" | "sync";
            };
            path: {
                /** The address of the NFT contract */
                address: string;
                /** The ID of the token */
                token_id: string;
            };
        };
        responses: {
            /** (In sync mode) Resync request executed. */
            200: {
                content: {
                    "application/json": components["schemas"]["metadataResync"];
                };
            };
            /** The resync request was received and will be executed. */
            202: {
                content: {
                    "application/json": components["schemas"]["metadataResync"];
                };
            };
            /** (In sync mode) Resync request executed and metadata could not be updated. */
            404: {
                content: {
                    "application/json": components["schemas"]["metadataResync"];
                };
            };
        };
    };
    /** Get the lowest executed price for an NFT contract for the last x days (only trades paid in ETH). */
    getNFTLowestPrice: {
        parameters: {
            query: {
                /** The chain to query */
                chain?: components["schemas"]["chainList"];
                /**
                 * The number of days to look back to find the lowest price
                 * If not provided 7 days will be the default
                 */
                days?: number;
                /** Marketplace from which to get the trades (only OpenSea is supported at the moment) */
                marketplace?: "opensea";
            };
            path: {
                /** The address of the NFT contract */
                address: string;
            };
        };
        responses: {
            /** Returns the trade with the lowest price */
            200: {
                content: {
                    "application/json": components["schemas"]["trade"];
                };
            };
        };
    };
    /** Get NFTs that match a given metadata search query. */
    searchNFTs: {
        parameters: {
            query: {
                /** The chain to query */
                chain?: components["schemas"]["chainList"];
                /** The format of the token ID */
                format?: "decimal" | "hex";
                /** The search string */
                q: string;
                /** What fields the search should match on. To look into the entire metadata set the value to 'global'. To have a better response time you can look into a specific field like name */
                filter?: "name" | "description" | "attributes" | "global" | "name,description" | "name,attributes" | "description,attributes" | "name,description,attributes";
                /**
                 * The minimum block number from which to start the search
                 * * Provide the param 'from_block' or 'from_date'
                 * * If 'from_date' and 'from_block' are provided, 'from_block' will be used.
                 */
                from_block?: number;
                /**
                 * The maximum block number from which to end the search
                 * * Provide the param 'to_block' or 'to_date'
                 * * If 'to_date' and 'to_block' are provided, 'to_block' will be used.
                 */
                to_block?: number;
                /**
                 * The date from which to start the search (any format that is accepted by momentjs)
                 * * Provide the param 'from_block' or 'from_date'
                 * * If 'from_date' and 'from_block' are provided, 'from_block' will be used.
                 */
                from_date?: string;
                /**
                 * Get search results up until this date (any format that is accepted by momentjs)
                 * * Provide the param 'to_block' or 'to_date'
                 * * If 'to_date' and 'to_block' are provided, 'to_block' will be used.
                 */
                to_date?: string;
                /** The addresses to get metadata for */
                addresses?: string[];
                /** The cursor returned in the previous response (used for getting the next page). */
                cursor?: string;
                /** The desired page size of the result. */
                limit?: number;
                /** If the result should skip returning the total count (Improves performance). */
                disable_total?: boolean;
            };
        };
        responses: {
            /** Returns the matching NFTs */
            200: {
                content: {
                    "application/json": components["schemas"]["nftMetadataCollection"];
                };
            };
        };
    };
    /** Get the token price denominated in the blockchain's native token and USD. */
    getTokenPrice: {
        parameters: {
            query: {
                /** The chain to query */
                chain?: components["schemas"]["chainList"];
                /** The factory name or address of the token exchange */
                exchange?: string;
                /** The block number from which the token price should be checked */
                to_block?: number;
            };
            path: {
                /** The address of the token contract */
                address: string;
            };
        };
        responses: {
            /** Returns the price denominated in the blockchain's native token and USD for a given token contract address */
            200: {
                content: {
                    "application/json": components["schemas"]["erc20Price"];
                };
            };
        };
    };
    /** Get token balances for a specific wallet address. */
    getWalletTokenBalances: {
        parameters: {
            query: {
                /** The chain to query */
                chain?: components["schemas"]["chainList"];
                /** The block number from which the balances should be checked */
                to_block?: number;
                /** The addresses to get balances for (optional) */
                token_addresses?: string[];
            };
            path: {
                /** The address from which token balances will be checked */
                address: string;
            };
        };
        responses: {
            /** Returns token balances for a specific address */
            200: {
                content: {
                    "application/json": components["schemas"]["erc20TokenBalance"][];
                };
            };
        };
    };
    /** Get ERC20 token transactions ordered by block number in descending order. */
    getWalletTokenTransfers: {
        parameters: {
            query: {
                /** The chain to query */
                chain?: components["schemas"]["chainList"];
                /**
                 * The minimum block number from which to get the transactions
                 * * Provide the param 'from_block' or 'from_date'
                 * * If 'from_date' and 'from_block' are provided, 'from_block' will be used.
                 */
                from_block?: number;
                /**
                 * The maximum block number from which to get the transactions.
                 * * Provide the param 'to_block' or 'to_date'
                 * * If 'to_date' and 'to_block' are provided, 'to_block' will be used.
                 */
                to_block?: number;
                /**
                 * The start date from which to get the transactions (any format that is accepted by momentjs)
                 * * Provide the param 'from_block' or 'from_date'
                 * * If 'from_date' and 'from_block' are provided, 'from_block' will be used.
                 */
                from_date?: string;
                /**
                 * Get the transactions up to this date (any format that is accepted by momentjs)
                 * * Provide the param 'to_block' or 'to_date'
                 * * If 'to_date' and 'to_block' are provided, 'to_block' will be used.
                 */
                to_date?: string;
                /** The desired page size of the result. */
                limit?: number;
                /** If the result should skip returning the total count (Improves performance). */
                disable_total?: boolean;
                /** The cursor returned in the previous response (used for getting the next page). */
                cursor?: string;
            };
            path: {
                /** The address of the wallet */
                address: string;
            };
        };
        responses: {
            /** Returns a collection of token transactions. */
            200: {
                content: {
                    "application/json": components["schemas"]["erc20TransactionCollection"];
                };
            };
        };
    };
    /** Get the metadata for a given token contract address (name, symbol, decimals, logo). */
    getTokenMetadata: {
        parameters: {
            query: {
                /** The chain to query */
                chain?: components["schemas"]["chainList"];
                /** The addresses to get metadata for */
                addresses: string[];
            };
        };
        responses: {
            /** Get the metadata for a given ERC20 token contract address (name, symbol, decimals, logo). */
            200: {
                content: {
                    "application/json": components["schemas"]["erc20Metadata"][];
                };
            };
        };
    };
    /** Get the metadata for a list of token symbols (name, symbol, decimals, logo). */
    getTokenMetadataBySymbol: {
        parameters: {
            query: {
                /** The chain to query */
                chain?: components["schemas"]["chainList"];
                /** The symbols to get metadata for */
                symbols: string[];
            };
        };
        responses: {
            /** Returns metadata for a given token contract address (name, symbol, decimals, logo). */
            200: {
                content: {
                    "application/json": components["schemas"]["erc20Metadata"][];
                };
            };
        };
    };
    /** Get the amount which the spender is allowed to withdraw on behalf of the owner. */
    getTokenAllowance: {
        parameters: {
            query: {
                /** The chain to query */
                chain?: components["schemas"]["chainList"];
                /** The address of the token owner */
                owner_address: string;
                /** The address of the token spender */
                spender_address: string;
            };
            path: {
                /** The address of the token contract */
                address: string;
            };
        };
        responses: {
            /** Returns the amount which the spender is allowed to withdraw on behalf of the owner. */
            200: {
                content: {
                    "application/json": components["schemas"]["erc20Allowance"];
                };
            };
        };
    };
    /** Get ERC20 token transactions from a contract ordered by block number in descending order. */
    getTokenTransfers: {
        parameters: {
            query: {
                /** The chain to query */
                chain?: components["schemas"]["chainList"];
                /**
                 * The minimum block number from which to get the transfers
                 * * Provide the param 'from_block' or 'from_date'
                 * * If 'from_date' and 'from_block' are provided, 'from_block' will be used.
                 */
                from_block?: number;
                /**
                 * The maximum block number from which to get the transfers.
                 * * Provide the param 'to_block' or 'to_date'
                 * * If 'to_date' and 'to_block' are provided, 'to_block' will be used.
                 */
                to_block?: number;
                /**
                 * The start date from which to get the transfers (any format that is accepted by momentjs)
                 * * Provide the param 'from_block' or 'from_date'
                 * * If 'from_date' and 'from_block' are provided, 'from_block' will be used.
                 */
                from_date?: string;
                /**
                 * Get the transfers up to this date (any format that is accepted by momentjs)
                 * * Provide the param 'to_block' or 'to_date'
                 * * If 'to_date' and 'to_block' are provided, 'to_block' will be used.
                 */
                to_date?: string;
                /** The desired page size of the result. */
                limit?: number;
                /** If the result should skip returning the total count (Improves performance). */
                disable_total?: boolean;
                /** The cursor returned in the previous response (used for getting the next page). */
                cursor?: string;
            };
            path: {
                /** The address of the token contract */
                address: string;
            };
        };
        responses: {
            /** Returns a collection of token contract transactions. */
            200: {
                content: {
                    "application/json": components["schemas"]["erc20TransactionCollection"];
                };
            };
        };
    };
    /** Get the native balance for a specific wallet address. */
    getNativeBalance: {
        parameters: {
            query: {
                /** The chain to query */
                chain?: components["schemas"]["chainList"];
                /** The block number from which the balances should be checked */
                to_block?: number;
            };
            path: {
                /** The address from which the native balance will be checked */
                address: string;
            };
        };
        responses: {
            /** Returns the native balance for a specific address */
            200: {
                content: {
                    "application/json": components["schemas"]["nativeBalance"];
                };
            };
        };
    };
    /** Get the native balances for a set of specific addresses */
    getNativeBalancesForAddresses: {
        parameters: {
            query: {
                /** The chain to query */
                chain?: components["schemas"]["chainList"];
                /** The web3 provider URL to use when using local dev chain */
                providerUrl?: string;
                /** The block number on which the balances should be checked */
                to_block?: number;
                /** The addresses to get metadata for */
                wallet_addresses: string[];
            };
        };
        responses: {
            /** Returns a collection of balances */
            200: {
                content: {
                    "application/json": components["schemas"]["nativeBalances"];
                };
            };
        };
    };
    /** Get native transactions ordered by block number in descending order. */
    getWalletTransactions: {
        parameters: {
            query: {
                /** The chain to query */
                chain?: components["schemas"]["chainList"];
                /**
                 * The minimum block number from which to get the transactions
                 * * Provide the param 'from_block' or 'from_date'
                 * * If 'from_date' and 'from_block' are provided, 'from_block' will be used.
                 */
                from_block?: number;
                /**
                 * The maximum block number from which to get the transactions.
                 * * Provide the param 'to_block' or 'to_date'
                 * * If 'to_date' and 'to_block' are provided, 'to_block' will be used.
                 */
                to_block?: number;
                /**
                 * The start date from which to get the transactions (any format that is accepted by momentjs)
                 * * Provide the param 'from_block' or 'from_date'
                 * * If 'from_date' and 'from_block' are provided, 'from_block' will be used.
                 */
                from_date?: string;
                /**
                 * Get the transactions up to this date (any format that is accepted by momentjs)
                 * * Provide the param 'to_block' or 'to_date'
                 * * If 'to_date' and 'to_block' are provided, 'to_block' will be used.
                 */
                to_date?: string;
                /** The cursor returned in the previous response (used for getting the next page). */
                cursor?: string;
                /** The desired page size of the result. */
                limit?: number;
                /** If the result should skip returning the total count (Improves performance). */
                disable_total?: boolean;
            };
            path: {
                /** The address of the wallet */
                address: string;
            };
        };
        responses: {
            /** Returns a collection of native transactions. */
            200: {
                content: {
                    "application/json": components["schemas"]["transactionCollection"];
                };
            };
        };
    };
    /** Get native transactions and logs ordered by block number in descending order. */
    getWalletTransactionsVerbose: {
        parameters: {
            query: {
                /** The chain to query */
                chain?: components["schemas"]["chainList"];
                /**
                 * The minimum block number from which to get the transactions
                 * * Provide the param 'from_block' or 'from_date'
                 * * If 'from_date' and 'from_block' are provided, 'from_block' will be used.
                 */
                from_block?: number;
                /**
                 * The maximum block number from which to get the transactions.
                 * * Provide the param 'to_block' or 'to_date'
                 * * If 'to_date' and 'to_block' are provided, 'to_block' will be used.
                 */
                to_block?: number;
                /**
                 * The start date from which to get the transactions (any format that is accepted by momentjs)
                 * * Provide the param 'from_block' or 'from_date'
                 * * If 'from_date' and 'from_block' are provided, 'from_block' will be used.
                 */
                from_date?: string;
                /**
                 * Get the transactions up to this date (any format that is accepted by momentjs)
                 * * Provide the param 'to_block' or 'to_date'
                 * * If 'to_date' and 'to_block' are provided, 'to_block' will be used.
                 */
                to_date?: string;
                /** The cursor returned in the previous response (used for getting the next page). */
                cursor?: string;
                /** The desired page size of the result. */
                limit?: number;
                /** If the result should skip returning the total count (Improves performance). */
                disable_total?: boolean;
            };
            path: {
                /** The address of the wallet */
                address: string;
            };
        };
        responses: {
            /** Returns a collection of native transactions. */
            200: {
                content: {
                    "application/json": components["schemas"]["transactionCollectionVerbose"];
                };
            };
        };
    };
    /** Get the contents of a transaction by the given transaction hash. */
    getTransaction: {
        parameters: {
            query: {
                /** The chain to query */
                chain?: components["schemas"]["chainList"];
            };
            path: {
                /** The transaction hash */
                transaction_hash: string;
            };
        };
        responses: {
            /** Transaction details by transaction hash */
            200: {
                content: {
                    "application/json": components["schemas"]["blockTransaction"];
                };
            };
        };
    };
    /** Get the contents of a block given the block hash. */
    getBlock: {
        parameters: {
            query: {
                /** The chain to query */
                chain?: components["schemas"]["chainList"];
            };
            path: {
                /** The block number or block hash */
                block_number_or_hash: string;
            };
        };
        responses: {
            /** Returns the contents of a block */
            200: {
                content: {
                    "application/json": components["schemas"]["block"];
                };
            };
        };
    };
    /** Get the closest block given the date. */
    getDateToBlock: {
        parameters: {
            query: {
                /** The chain to query */
                chain?: components["schemas"]["chainList"];
                /** Unix date in milliseconds or a datestring (any format that is accepted by momentjs) */
                date: string;
            };
        };
        responses: {
            /** Returns the block number and corresponding date and timestamp */
            200: {
                content: {
                    "application/json": components["schemas"]["blockDate"];
                };
            };
        };
    };
    /** Get the logs for a contract. */
    getContractLogs: {
        parameters: {
            query: {
                /** The chain to query */
                chain?: components["schemas"]["chainList"];
                /**
                 * The block number
                 * * Provide the param 'block_numer' or ('from_block' and / or 'to_block')
                 * * If 'block_numer' is provided in combination with 'from_block' and / or 'to_block', 'block_number' will will be used
                 */
                block_number?: string;
                /**
                 * The minimum block number from which to get the logs
                 * * Provide the param 'block_numer' or ('from_block' and / or 'to_block')
                 * * If 'block_numer' is provided in combination with 'from_block' and / or 'to_block', 'block_number' will will be used
                 */
                from_block?: string;
                /**
                 * The maximum block number from which to get the logs
                 * * Provide the param 'block_numer' or ('from_block' and / or 'to_block')
                 * * If 'block_numer' is provided in combination with 'from_block' and / or 'to_block', 'block_number' will will be used
                 */
                to_block?: string;
                /**
                 * The start date from which to get the logs (any format that is accepted by momentjs)
                 * * Provide the param 'from_block' or 'from_date'
                 * * If 'from_date' and 'from_block' are provided, 'from_block' will be used.
                 * * If 'from_date' and the block params are provided, the block params will be used. Please refer to the blocks params sections (block_number,from_block and to_block) on how to use them
                 */
                from_date?: string;
                /**
                 * Get the logs up to this date (any format that is accepted by momentjs)
                 * * Provide the param 'to_block' or 'to_date'
                 * * If 'to_date' and 'to_block' are provided, 'to_block' will be used.
                 * * If 'to_date' and the block params are provided, the block params will be used. Please refer to the blocks params sections (block_number,from_block and to_block) on how to use them
                 */
                to_date?: string;
                /** topic0 */
                topic0?: string;
                /** topic1 */
                topic1?: string;
                /** topic2 */
                topic2?: string;
                /** topic3 */
                topic3?: string;
                /** The desired page size of the result. */
                limit?: number;
                /** If the result should skip returning the total count (Improves performance). */
                disable_total?: boolean;
                /** The cursor returned in the previous response (used for getting the next page). */
                cursor?: string;
            };
            path: {
                /** The address of the contract */
                address: string;
            };
        };
        responses: {
            /** Returns the logs for an address */
            200: {
                content: {
                    "application/json": components["schemas"]["logCollection"];
                };
            };
        };
    };
    /** Get events for a contract ordered by block number in descending order. [Try it with Swagger](https://deep-index.moralis.io/api-docs-2.1/#/Events/getContractEvents). */
    getContractEvents: {
        parameters: {
            query: {
                /** The chain to query */
                chain?: components["schemas"]["chainList"];
                /**
                 * The minimum block number from which to get the logs
                 * * Provide the param 'from_block' or 'from_date'
                 * * If 'from_date' and 'from_block' are provided, 'from_block' will be used.
                 */
                from_block?: number;
                /**
                 * The maximum block number from which to get the logs.
                 * * Provide the param 'to_block' or 'to_date'
                 * * If 'to_date' and 'to_block' are provided, 'to_block' will be used.
                 */
                to_block?: number;
                /**
                 * The start date from which to get the logs (any format that is accepted by momentjs)
                 * * Provide the param 'from_block' or 'from_date'
                 * * If 'from_date' and 'from_block' are provided, 'from_block' will be used.
                 */
                from_date?: string;
                /**
                 * Get the logs up to this date (any format that is accepted by momentjs)
                 * * Provide the param 'to_block' or 'to_date'
                 * * If 'to_date' and 'to_block' are provided, 'to_block' will be used.
                 */
                to_date?: string;
                /** The topic of the event */
                topic: string;
                /** offset */
                offset?: number;
                /** The desired page size of the result. */
                limit?: number;
                /** If the result should skip returning the total count (Improves performance). */
                disable_total?: boolean;
            };
            path: {
                /** The address of the contract */
                address: string;
            };
        };
        responses: {
            /** Returns a collection of events by topic */
            200: {
                content: {
                    "application/json": {
                        /**
                         * @description The total number of matches for this query
                         * @example 2000
                         */
                        total?: number;
                        /**
                         * @description The current page of the result
                         * @example 2
                         */
                        page?: number;
                        /**
                         * @description The number of results per page
                         * @example 100
                         */
                        page_size?: number;
                        result?: components["schemas"]["logEvent"][];
                    };
                };
            };
        };
        /** ABI of the specific event */
        requestBody: {
            content: {
                "application/json": {
                    [key: string]: unknown;
                };
            };
        };
    };
    /** Run a given function of a contract ABI and retrieve readonly data. [Try it with Swagger](https://deep-index.moralis.io/api-docs-2.1/#/Utils/runContractFunction). */
    runContractFunction: {
        parameters: {
            query: {
                /** The chain to query */
                chain?: components["schemas"]["chainList"];
                /** The function name of the contract */
                function_name: string;
            };
            path: {
                /** The address of the contract */
                address: string;
            };
        };
        responses: {
            /** Returns response of the function executed */
            200: {
                content: {
                    "application/json": string;
                };
            };
        };
        /** Body */
        requestBody: {
            content: {
                "application/json": components["schemas"]["RunContractDto"];
            };
        };
    };
    /** Get the current version of the Moralis Web3 API. */
    web3ApiVersion: {
        responses: {
            /** Get the current version of the Moralis Web3 API. */
            200: {
                content: {
                    "application/json": components["schemas"]["web3version"];
                };
            };
        };
    };
    /** Get the cost and rate limit for each API endpoint. */
    endpointWeights: {
        responses: {
            /** The cost and rate limit for each API endpoint. */
            200: {
                content: {
                    "application/json": components["schemas"]["endpointWeights"][];
                };
            };
        };
    };
    /** Reverse resolve a given ETH address to its ENS domain. */
    resolveAddress: {
        parameters: {
            path: {
                /** The address to be resolved */
                address: string;
            };
        };
        responses: {
            /** Returns an ENS */
            200: {
                content: {
                    "application/json": components["schemas"]["ens"];
                };
            };
        };
    };
    /** Resolve a specific Unstoppable domain to its address. */
    resolveDomain: {
        parameters: {
            query: {
                /** The currency to query */
                currency?: "eth" | "0x1";
            };
            path: {
                /** The domain to be resolved */
                domain: string;
            };
        };
        responses: {
            /** Returns an address */
            200: {
                content: {
                    "application/json": components["schemas"]["resolve"];
                };
            };
            /** Returns an address */
            404: {
                content: {
                    "application/json": {
                        [key: string]: unknown;
                    };
                };
            };
        };
    };
    /** Get the liquidity reserves for a given pair address. Only Uniswap V2 based exchanges supported at the moment. */
    getPairReserves: {
        parameters: {
            query: {
                /** The chain to query */
                chain?: components["schemas"]["chainList"];
                /** The block number to get the reserves from */
                to_block?: string;
                /**
                 * Get the reserves up to this date (any format that is accepted by momentjs)
                 * * Provide the param 'to_block' or 'to_date'
                 * * If 'to_date' and 'to_block' are provided, 'to_block' will be used.
                 */
                to_date?: string;
            };
            path: {
                /** The liquidity pair address */
                pair_address: string;
            };
        };
        responses: {
            /** Returns the pair reserves */
            200: {
                content: {
                    "application/json": {
                        /** @example 220969226548536862025877 */
                        reserve0?: string;
                        /** @example 844810441191293211036 */
                        reserve1?: string;
                    };
                };
            };
        };
    };
    /**
     * Fetch the pair data of the provided token0+token1 combination.
     * The token0 and token1 options are interchangable (ie. there is no different outcome in "token0=WETH and token1=USDT" or "token0=USDT and token1=WETH")
     */
    getPairAddress: {
        parameters: {
            query: {
                /** The chain to query */
                chain?: components["schemas"]["chainList"];
                /** The block number to get the reserves from */
                to_block?: string;
                /**
                 * Get the reserves up to this date (any format that is accepted by momentjs)
                 * * Provide the param 'to_block' or 'to_date'
                 * * If 'to_date' and 'to_block' are provided, 'to_block' will be used.
                 */
                to_date?: string;
                /** The factory name or address of the token exchange */
                exchange: "uniswapv2" | "uniswapv3" | "sushiswapv2" | "pancakeswapv2" | "pancakeswapv1" | "quickswap";
            };
            path: {
                /** The token0 address */
                token0_address: string;
                /** The token1 address */
                token1_address: string;
            };
        };
        responses: {
            /** Returns the pair address of the two tokens. */
            200: {
                content: {
                    "application/json": components["schemas"]["reservesCollection"];
                };
            };
        };
    };
    /** Upload multiple files to IPFS and place them in a folder directory. */
    uploadFolder: {
        responses: {
            /** Returns the path to the uploaded files */
            200: {
                content: {
                    "application/json": components["schemas"]["ipfsFile"][];
                };
            };
        };
        /** Array of JSON and Base64 Supported */
        requestBody: {
            content: {
                "application/json": components["schemas"]["ipfsFileRequest"][];
            };
        };
    };
}

type EvmBlockDateInput = components['schemas']['blockDate'];
interface EvmBlockDateData {
    date: Date;
    block: number;
    timestamp: number;
    blockTimestamp?: string;
    hash?: string;
    parentHash?: string;
}

type EvmBlockDateish = EvmBlockDateInput | EvmBlockDate;
declare class EvmBlockDate {
    private readonly data;
    /**
     * Create a new instance of EvmBlockDate.
     * @param data - the EvmBlockDateish type.
     */
    static create(data: EvmBlockDateish): EvmBlockDate;
    private static parse;
    private constructor();
    /**
     * @description The block number.
     * @example `9193266`
     */
    get block(): number;
    /**
     * @description The date of the block.
     * @example `2020-01-01T00:00:00+00:00`
     */
    get date(): Date;
    /**
     * @description The timestamp of the block
     * @example `1577836811`
     */
    get timestamp(): number;
    /**
     * @description The timestamp of the block
     * @example `2022-01-03T22:59:39.000Z`
     */
    get blockTimestamp(): string | undefined;
    /**
     * @deprecated Use `blockTimestamp` instead.
     */
    get block_timestamp(): string | undefined;
    /**
     * @description The block hash.
     * @example `0x9b559aef7ea858608c2e554246fe4a24287e7aeeb976848df2b9a2531f4b9171`
     */
    get hash(): string | undefined;
    /**
     * @deprecated Use `hash` instead.
     */
    get block_hash(): string | undefined;
    /**
     * @description The block hash of the parent block.
     * @example `0x011d1fc45839de975cc55d758943f9f1d204f80a90eb631f3bf064b80d53e045`
     */
    get parentHash(): string | undefined;
    /**
     * @deprecated Use `parentHash` instead.
     */
    get parent_hash(): string | undefined;
}

/**
 * This can be any object with valid event data.
 * @example
 * ```
 * const transactionInput = {
 * chain: 1,
 * address: "0xdac17f958d2ee523a2206206994597c13d831ec7",
 * blockHash: "0x1bb168d2725d15b12604c92a83c529617cd54a415c5d610a687f7859d45f9ea5",
 * blockNumber: "14327217",
 * blockTimestamp: "2022-03-05T13:45:42.000Z",
 * transactionHash: "0xc9f62f4f6ab505a96c1a84ec2899c6bfd86245ef1effaa689fc997798be763d5",
 * data: {
 *  to: "0x54e41aa7ac19efd71d19a3ca6b8a6c0154fe3afb",
 *  from: "0x21f510cc9f81df4e4d2c705e672761cf487cdc5a",
 *  value: "878000000",
 * },
 *}
 * ```
 */
interface EvmEventInput {
    chain: EvmChainish;
    transactionHash: string;
    address: EvmAddressish;
    blockTimestamp: DateInput;
    blockNumber: BigNumberish;
    blockHash: string;
    data: {
        from?: EvmAddressish;
        to?: EvmAddressish;
        value?: EvmNativeish;
    };
}
/**
 * This is the return type of the processed EVM event
 */
interface EvmEventData {
    chain: EvmChain;
    transactionHash: string;
    address: EvmAddress;
    blockTimestamp: Date;
    blockNumber: BigNumber;
    blockHash: string;
    data: {
        from?: EvmAddress;
        to?: EvmAddress;
        value?: EvmNative;
    };
}

/**
 * Valid input for a new EvmEvent instance.
 * This can be an existing {@link EvmEvent} or a valid {@link EvmEventInput} object
 */
type EvmEventish = EvmEventInput | EvmEvent;
/**
 * The EvmEvent is a representation of an event.
 *
 * Use this class any time you work with an event.
 *
 * @category DataType
 */
declare class EvmEvent implements MoralisDataObject {
    private readonly _data;
    /**
     * Create a new instance of EvmEvent from any valid event input
     * @param data - the EvmEventish type
     * @example
     * ```
     * const event = EvmEventish.create(data);
     *```
     */
    static create(data: EvmEventish, core?: Core): EvmEvent;
    private constructor();
    static parse: (data: EvmEventInput, core: Core) => EvmEventData;
    /**
     * Check the equality between two Evm events. It checks if the chain, block number, address and data are equal.
     * @param dataA - The first event
     * @param dataB - The second event
     * @example
     * ```ts
     * EvmEvent.equals(dataA, dataB)
     * ```
     * @returns true if the events are equal, false otherwise
     */
    static equals(dataA: EvmEventish, dataB: EvmEventish): boolean;
    /**
     * Checks the equality of the current event instance with another evm event
     * @param data - the event to compare with
     * @example
     * ```ts
     * event.equals(data)
     * ```
     * @returns true if the events are equal, false otherwise
     */
    equals(data: EvmEventish): boolean;
    /**
     * @returns a JSON represention of the event.
     * @example
     * ```
     * event.toJSON()
     * ```
     */
    toJSON(): {
        chain: string | number;
        address: string;
        blockNumber: string;
        data: {
            from: string | undefined;
            to: string | undefined;
            value: string | undefined;
        };
        transactionHash: string;
        blockTimestamp: Date;
        blockHash: string;
    };
    /**
     * @returns a JSON represention of the event.
     * @example event.format()
     */
    format(): {
        chain: string | number;
        address: string;
        blockNumber: string;
        data: {
            from: string | undefined;
            to: string | undefined;
            value: string | undefined;
        };
        transactionHash: string;
        blockTimestamp: Date;
        blockHash: string;
    };
    /**
     * @returns all the data without casting it to JSON.
     * @example event.result
     */
    get result(): EvmEventData;
    /**
     * @returns the event chain
     * @example event.chain // EvmChain
     */
    get chain(): EvmChain;
    /**
     * @returns the event address
     * @example event.address // EvmAddress
     */
    get address(): EvmAddress;
    /**
     * @returns the event block number
     * @example event.blockNumber // BigNumber
     */
    get blockNumber(): BigNumber;
    /**
     * @returns the event block timestamp
     * @example event.blockTimestamp // Date
     */
    get blockTimestamp(): Date;
    /**
     * @returns the event data with from address, to address and value
     * @example event.data
     */
    get data(): {
        from?: EvmAddress | undefined;
        to?: EvmAddress | undefined;
        value?: EvmNative | undefined;
    };
    /**
     * @returns the event block trannsaciton hash
     * @example event.transactionHash // "0xc9f62f4f6ab505a96c1a84ec2899c6bfd86245ef1effaa689fc997798be763d5"
     */
    get transactionHash(): string;
    /**
     * @returns the event block hash
     * @example event.blockHash // "0xc9f62f4f6ab505a96c1a84ec2899c6bfd86245ef1effaa689fc997798be763d5"
     */
    get blockHash(): string;
}

/**
 * This can be any object with valid transaction data.
 * @example
 * ```ts
 * const nftInput = {
          chain: 1,
          contractType: "ERC721",
          tokenAddress: "0x057Ec652A4F150f7FF94f089A38008f49a0DF88e",
          tokenId: "15",
          tokenUri: "string",
          metadata: "string",
          name: "CryptoKitties",
          symbol: "RARI",
          amount: "1",
          blockNumberMinted: "88256",
          blockNumber: "88256",
          ownerOf: "0xfB6916095ca1df60bB79Ce92cE3Ea74c37c5d359",
          tokenHash: nft.token_hash,
          lastMetadataSync: "date_string",
          lastTokenUriSync: "date_string",
        }
 * ```
 */
interface EvmNftInput {
    tokenId: number | string;
    contractType: string;
    chain: EvmChainish;
    tokenUri?: null | string;
    tokenAddress: EvmAddressish;
    tokenHash?: null | string;
    metadata?: null | string;
    name?: null | string;
    symbol?: null | string;
    ownerOf?: null | EvmAddressish;
    blockNumberMinted?: null | BigNumberish;
    blockNumber?: null | BigNumberish;
    lastMetadataSync?: null | DateInput;
    lastTokenUriSync?: null | DateInput;
    amount?: null | number | string;
}
/**
 * This is the return type of the processed EVM NFT
 */
interface EvmNftData {
    tokenId: number | string;
    contractType?: string;
    chain: EvmChain;
    tokenUri?: string;
    tokenAddress: EvmAddress;
    tokenHash?: string;
    metadata?: MoralisDataObjectValue;
    name?: string;
    symbol?: string;
    ownerOf?: EvmAddress;
    blockNumberMinted?: BigNumber;
    blockNumber?: BigNumber;
    lastMetadataSync?: Date;
    lastTokenUriSync?: Date;
    amount?: number;
}

/**
 * Valid input for a new EvmNft instance.
 * This can be an existing {@link EvmNft} or a valid {@link EvmNftInput} object
 */
type EvmNftish = EvmNftInput | EvmNft;
/**
 * The EvmNft class is a MoralisData that references to a the NFT of the type; Erc721 or Erc1155
 *
 * @category DataType
 */
declare class EvmNft implements MoralisDataObject {
    /**
     * Create a new instance of EvmNft from any valid address input
     *
     * @param data - the EvmNftish type
     * @param core - the Core instance
     * @example
     * ```ts
     * const nft = EvmNft.create(data);
     * ```
     * @returns an instance of EvmNft
     */
    static create(data: EvmNftish, core?: _moralisweb3_common_core__default): EvmNft;
    private _data;
    constructor(data: EvmNftInput, core: _moralisweb3_common_core__default);
    static parse: (data: EvmNftInput, core: _moralisweb3_common_core__default) => EvmNftData;
    /**
     * This function confirms that the NFT metadata is a valid JSON string.
     *
     * @param value - the new value for the NFT metadata
     * @returns the parsed value of the JSON string
     * @throws {CoreError} if the value is not a valid JSON string
     */
    private static validateMetadata;
    /**
     * Compares two EvmNftish data. verifies that the chain, tokenAddress and owner of values are equal.
     * @param valueA - the first EvmNftish data to compare
     * @param valueB - the second EvmNftish data to compare
     * @returns true if the values are equal, false otherwise
     * @example
     * ```ts
     *  EvmNft.equals(valueA, valueB);
     * ```
     */
    static equals(valueA: EvmNftish, valueB: EvmNftish): boolean;
    /**
     * Compares an EvmNftish data to this EvmNft instance.
     * @param value - the value to compare
     * @returns true if the value is equal to the current instance, false otherwise
     * @example
     * ```ts
     * nft.equals(value);
     * ```
     */
    equals(value: EvmNftish): boolean;
    /**
     * Converts the EvmNft instance to a JSON object.
     * @returns JSON object of the EvmNft instance
     * @example `nft.toJSON()`
     */
    toJSON(): {
        tokenAddress: string;
        chain: string | number;
        ownerOf: string | undefined;
        blockNumberMinted: string | undefined;
        blockNumber: string | undefined;
        tokenId: string | number;
        contractType?: string | undefined;
        tokenUri?: string | undefined;
        tokenHash?: string | undefined;
        metadata?: MoralisDataObjectValue | undefined;
        name?: string | undefined;
        symbol?: string | undefined;
        lastMetadataSync?: Date | undefined;
        lastTokenUriSync?: Date | undefined;
        amount?: number | undefined;
    };
    /**
     * Converts the EvmNft instance to a JSON object.
     * @returns JSON object of the EvmNft instance
     * @example `nft.format()`
     */
    format(): {
        tokenAddress: string;
        chain: string | number;
        ownerOf: string | undefined;
        blockNumberMinted: string | undefined;
        blockNumber: string | undefined;
        tokenId: string | number;
        contractType?: string | undefined;
        tokenUri?: string | undefined;
        tokenHash?: string | undefined;
        metadata?: MoralisDataObjectValue | undefined;
        name?: string | undefined;
        symbol?: string | undefined;
        lastMetadataSync?: Date | undefined;
        lastTokenUriSync?: Date | undefined;
        amount?: number | undefined;
    };
    get result(): EvmNftData;
    /**
     * @returns the NFT chain
     * @example
     * ```
     * nft.chain // EvmChain
     * ```
     */
    get chain(): EvmChain;
    /**
     * @returns the NFT contract type
     * @example
     * ```
     * nft.contractType // "ERC721" | "ERC1155"
     * ```
     */
    get contractType(): string | undefined;
    /**
     * @returns the NFT token address
     * @example
     * ```
     * nft.tokenAddress // EvmAddress
     * ```
     */
    get tokenAddress(): EvmAddress;
    /**
     * @returns the NFT metadata
     * @example
     * ```ts
     * nft.metadata
     * // {
     * // name: 'Pancake',
     * // description: 'The dessert series 1',
     * // image: 'ipfs://QmNQFXCZ6LGzvpMW9Q5PWbCrEnLknQrPwr2r8pbQAgzQ9A/4863BD6B-6C92-4B96-BF80-8020B2F7C3A5.jpeg',
     * // }
     * ```
     */
    get metadata(): MoralisDataObjectValue | undefined;
    /**
     * @returns the NFT token URI
     * @example
     * ```
     * nft.tokenUri // "https://gateway.moralisipfs.com/ipfs/QmajSqgxY3cWBgBeRm38vasJAcTit1kp5EwqVHxszJYgUC/728.json"
     * ```
     */
    get tokenUri(): string | undefined;
    /**
     * @returns the NFT token hash
     * @example
     * ```
     * nft.tokenHash // "QmajSqgxY3cWBgBeRm38vasJAcTit1kp5EwqVHxszJYgUC"
     * ```
     */
    get tokenHash(): string | undefined;
    /**
     * @returns the NFT name
     * @example
     * ```
     * nft.name // "Tether USD"
     * ```
     */
    get name(): string | undefined;
    /**
     * @returns the NFT symbol
     * @example
     * ```
     * nft.symbol // "USDT"
     * ```
     */
    get symbol(): string | undefined;
    /**
     * @returns the NFT owner of address
     * @example
     * ```
     * nft.ownerOf // EvmAddress
     * ```
     */
    get ownerOf(): EvmAddress | undefined;
    /**
     * @returns the NFT block number minted from
     * @example
     * ```
     * nft.blockNumberMinted // BigNumber
     * ```
     */
    get blockNumberMinted(): BigNumber | undefined;
    /**
     * @returns the NFT block number
     * @example
     * ```
     * nft.blockNumber // BigNumber
     * ```
     */
    get blockNumber(): BigNumber | undefined;
    /**
     * @returns the NFT latest metadata sync date
     * @example
     * ```
     * nft.latestMetadataSync // Date
     * ```
     */
    get lastMetadataSync(): Date | undefined;
    /**
     * @returns the NFT latest token URI sync date
     * @example
     * ```
     * nft.latestTokenUriSync // Date
     * ```
     */
    get lastTokenUriSync(): Date | undefined;
    /**
     * @returns the NFT amount
     * @example
     * ```
     * nft.amount // 2
     * ```
     */
    get amount(): number | undefined;
    /**
     * @returns the token id
     * @example
     * ```
     * nft.tokenId // '1234'
     * ```
     */
    get tokenId(): string | number;
}

/**
 * This can be any object with valid block data.
 * @example
 * ```
 * const input = {
 *   chain: '0x1',
 *   contractType: 'ERC721',
 *   name: 'Test NFT',
 *   symbol: 'TEST',
 *   tokenAddress: '0xe4c7bf3aff7ad07f9e80d57f7189f0252592fee6321c2a9bd9b09b6ce0690d27',
 *  }
 * ```
 */
interface EvmNftCollectionInput {
    chain: EvmChainish;
    contractType: string;
    name: string;
    symbol: string;
    tokenAddress: EvmAddressish;
}
/**
 * This is the return type of the processed EVM transaction
 */
interface EvmNftCollectionData {
    chain: EvmChain;
    contractType?: string;
    name: string;
    symbol: string;
    tokenAddress: EvmAddress;
}

/**
 * Valid input for a new EvmNftCollection instance.
 * This can be an existing {@link EvmNftCollection} or a valid {@link EvmNftCollectionInput} object
 */
type EvmNftCollectionish = EvmNftCollectionInput | EvmNftCollection;
/**
 * The EvmNftCollection is a representation of an nft collection.
 *
 * @category DataType
 */
declare class EvmNftCollection implements MoralisDataObject {
    /**
     * Create a new instance of EvmNftCollection from any valid transaction input
     * @param data - the EvmNftCollectionish type
     * @example const collection = EvmTransaction.create(data);
     */
    static create(data: EvmNftCollectionish, core?: _moralisweb3_common_core__default): EvmNftCollection;
    private _data;
    constructor(data: EvmNftCollectionInput, core: _moralisweb3_common_core__default);
    static parse: (data: EvmNftCollectionInput, core: _moralisweb3_common_core__default) => EvmNftCollectionData;
    /**
     * Check the equality between two Evm collections. It compares their hashes and collections.
     * @param dataA - The first collection to compare
     * @param dataB - The second collection to compare
     * @example EvmNftCollection.equals(dataA, dataB)
     */
    static equals(dataA: EvmNftCollectionish, dataB: EvmNftCollectionish): boolean;
    /**
     * Checks the equality of the current collection with another evm collection
     * @param data - the collection to compare with
     * @example
     * ```ts
     * collection.equals(data)
     * ```
     */
    equals(data: EvmNftCollectionish): boolean;
    /**
     * @returns a JSON represention of the collection.
     * @example
     * ```
     * collection.toJSON()
     * ```
     */
    toJSON(): {
        chain: string | number;
        tokenAddress: string;
        contractType?: string | undefined;
        name: string;
        symbol: string;
    };
    /**
     * @returns a JSON represention of the collection.
     * @example
     * ```
     * collection.format()
     * ```
     */
    format(): {
        chain: string | number;
        tokenAddress: string;
        contractType?: string | undefined;
        name: string;
        symbol: string;
    };
    /**
     * @returns all the data without casting it to JSON.
     * @example collection.result
     */
    get result(): EvmNftCollectionData;
    /**
     * @returns the chain where the collection is deployed.
     * @example collection.chain // EvmChain
     */
    get chain(): EvmChain;
    /**
     * @returns the token address of collection.
     * @example collection.tokenAddress // EvmAddress
     */
    get tokenAddress(): EvmAddress;
    /**
     * @returns the token type of collection.
     * @example collection.tokenAddress // 'ERC721'
     */
    get contractType(): string | undefined;
    /**
     * @returns the token name of collection.
     * @example collection.tokenAddress // 'Test NFT'
     */
    get name(): string;
    /**
     * @returns the token symbol of collection.
     * @example collection.symbol // 'TEST'
     */
    get symbol(): string;
}

/**
 * Valid ERC20 token input
 *
 * @example
 * ```ts
 * const input = {
 *   chain: 1,
 *   tokenAddress: "0x7de3085b3190b3a787822ee16f23be010f5f8686",
 *   syncedAt: "2022-02-19",
 *   contractType: "ERC721",
 *   symbol: "BAMC",
 * }
 * ```
 */
interface EvmNftMetadataInput {
    chain: EvmChainish;
    tokenAddress: EvmAddressish;
    name: string;
    symbol: string;
    contractType?: string;
    syncedAt: DateInput | null;
}
/**
 * This is the return type of the processed Evm NFT Metadata
 */
interface EvmNftMetadataData {
    chain: EvmChain;
    tokenAddress: EvmAddress;
    name: string;
    symbol: string;
    contractType?: string;
    syncedAt?: Date;
}

/**
 * This can be an exsisting {@link EvmNftMetadata} or a valid {@link EvmNftMetadataInput}.
 */
type EvmNftMetadataish = EvmNftMetadataInput | EvmNftMetadata;
/**
 * The EvmNftMetadata contains metadata of an NFT.
 *
 * @category DataType
 */
declare class EvmNftMetadata implements MoralisDataObject {
    /**
     *  Create a new instance of EvmNftMetadata from any valid EvmNftMetadata input
     *
     * @param data - the EvmNftMetadataish type
     * @example
     * ```ts
     * const token = EvmNftMetadataish.create(value);
     * ```
     */
    static create(data: EvmNftMetadataish): EvmNftMetadata;
    private _data;
    constructor(data: EvmNftMetadataInput);
    static parse: (data: EvmNftMetadataInput) => EvmNftMetadataData;
    /**
     * Compares two EvmNftMetadata instances. This checks if the chain and tokenAddress of both meatdatas are equal.
     *
     * @param dataA - the first EvmNftMetadataish to compare
     * @param dataB - the second EvmNftMetadataish to compare
     * @returns true if the two EvmNftMetadataData are equal
     * @example
     * ```ts
     * EvmNftMetadata.equals(dataA, dataB);
     * ```
     */
    static equals(dataA: EvmNftMetadataish, dataB: EvmNftMetadataish): boolean;
    /**
     * Compares EvmNftMetadata instance to current instance
     *
     * @param data - the EvmNftMetadataish to compare
     * @returns true if the EvmNftMetadataish is equals given metadata
     * @example
     * ```ts
     * metadata.equals(data);
     * ```
     */
    equals(data: EvmNftMetadataish): boolean;
    /**
     * @returns the data as JSON.
     * @example metadata.toJSON();
     */
    toJSON(): {
        chain: string | number;
        tokenAddress: string;
        name: string;
        symbol: string;
        contractType?: string | undefined;
        syncedAt?: Date | undefined;
    };
    /**
     * @returns the data as JSON.
     * @example metadata.format();
     */
    format(): {
        chain: string | number;
        tokenAddress: string;
        name: string;
        symbol: string;
        contractType?: string | undefined;
        syncedAt?: Date | undefined;
    };
    /**
     * @returns all the data without casting it to JSON.
     * @example metadata.result;
     */
    get result(): EvmNftMetadataData;
    /**
     * @returns the name in the metadata.
     * @example metadata.name; // "Baby Ape Mutant Club"
     */
    get name(): string;
    /**
     * @returns the symbol in the metadata.
     * @example metadata.symbol; // "BAMC"
     */
    get symbol(): string;
    /**
     * @returns the contract type of the NFT.
     * @example metadata.contractType; // "ERC721"
     */
    get contractType(): string | undefined;
    /**
     * @returns the chain in the metadata.
     * @example metadata.chain; // EvmChain
     */
    get chain(): EvmChain;
    /**
     * @returns the token address in the metadata.
     * @example metadata.tokenAddress; // EvmAddress
     */
    get tokenAddress(): EvmAddress;
    /**
     * @returns the date the metadata was synced.
     * @example metadata.syncedAt; // Date
     */
    get syncedAt(): Date | undefined;
}

/**
 * This can be any object with valid trade data.
 * @example
 * ```
 * const tradeInput = {
 * chain: 1,
 * sellerAddress: "0xbae90f486d751f133702655627ce599249cd26b8",
 * buyerAddress: "0x8795e90de359c1e0bf2579646486f7f12f270d2f",
 * marketplaceAddress: "0x7be8076f4ea4a4ad08075c2508e481d6c946d12b",
 * tokenAddress: "0xdf7952b35f24acf7fc0487d01c8d5690a60dba07",
 * price: "280000000000000000",
 * blockTimestamp: "2021-05-09T23:00:25.000Z",
 * tokenIds: ["16404"],
 * blockHash: "0xe870c197b0c614e055f4de5b264bc7c69eafc93a6d0ce300309de444b2ff7e3a",
 * blockNumber: 1,
 * transactionHash: "0x4de0bcef1450492bd5c2e7693cf644c40005868d0dcc8a7a50a80ef2efa88d1e",
 * transactionIndex: "164"
 *}
 * ```
 */
interface EvmNftTradeInput {
    chain: EvmChainish;
    transactionHash: string;
    transactionIndex: string | number;
    tokenIds: string[];
    sellerAddress: EvmAddressish;
    buyerAddress: EvmAddressish;
    tokenAddress: EvmAddressish;
    marketplaceAddress: EvmAddressish;
    price: EvmNativeish;
    priceTokenAddress?: null | EvmAddressish;
    blockTimestamp: DateInput;
    blockNumber: BigNumberish;
    blockHash: string;
}
/**
 * This is the return type of the processed EVM trade
 */
interface EvmNftTradeData {
    chain: EvmChain;
    transactionHash: string;
    transactionIndex: number;
    tokenIds: string[];
    sellerAddress: EvmAddress;
    buyerAddress: EvmAddress;
    tokenAddress: EvmAddress;
    marketplaceAddress: EvmAddress;
    price: EvmNative;
    priceTokenAddress?: EvmAddress;
    blockTimestamp: Date;
    blockNumber: BigNumber;
    blockHash: string;
}

/**
 * Valid input for a new EvmNftTrade instance.
 * This can be an existing {@link EvmNftTrade} or a valid {@link EvmNftTradeInput} object
 */
type EvmNftTradeish = EvmNftTradeInput | EvmNftTrade;
/**
 * The EvmNftTrade is a representation of a published trade.
 *
 * Use this class any time you work with a transaction.
 *
 * @category DataType
 */
declare class EvmNftTrade implements MoralisDataObject {
    /**
     * Create a new instance of EvmNftTrade from any valid transaction input
     * @param data - the EvmNftTradeish type
     * @example
     * ```
     * const trade = EvmNftTrade.create(data);
     *```
     */
    static create(data: EvmNftTradeish): EvmNftTrade;
    private _data;
    constructor(data: EvmNftTradeInput);
    static parse: (data: EvmNftTradeInput) => EvmNftTradeData;
    /**
     * Check the equality between two Evm trades. It compares the `chain`, `blockNumber`, `transactionIndex` and `transactionHash`
     * @param dataA - The first trade
     * @param dataB - The second trade
     * @example
     * ```ts
     * EvmNftTrade.equals(dataA, dataB)
     * ```
     * @returns true if the trades are equal, false otherwise
     */
    static equals(dataA: EvmNftTradeish, dataB: EvmNftTradeish): boolean;
    /**
     * Checks the equality of the current trade instance with another evm trade
     * @param data - the trade to compare with
     * @example
     * ```ts
     * trade.equals(data)
     * ```
     * @returns true if the trades are equal, false otherwise
     */
    equals(data: EvmNftTradeish): boolean;
    /**
     * @returns a JSON represention of the trade.
     * @example
     * ```
     * trade.toJSON()
     * ```
     */
    toJSON(): {
        chain: string | number;
        sellerAddress: string;
        buyerAddress: string;
        marketplaceAddress: string;
        tokenAddress: string;
        priceTokenAddress: string | undefined;
        blockNumber: string;
        price: string;
        blockTimestamp: string;
        transactionHash: string;
        transactionIndex: number;
        tokenIds: string[];
        blockHash: string;
    };
    /**
     * @returns a JSON represention of the trade.
     * @example
     * ```
     * trade.format()
     * ```
     */
    format(): {
        chain: string | number;
        sellerAddress: string;
        buyerAddress: string;
        marketplaceAddress: string;
        tokenAddress: string;
        priceTokenAddress: string | undefined;
        blockNumber: string;
        price: string;
        blockTimestamp: string;
        transactionHash: string;
        transactionIndex: number;
        tokenIds: string[];
        blockHash: string;
    };
    /**
     * @returns all the data without casting it to JSON.
     * @example trade.result
     */
    get result(): EvmNftTradeData;
    /**
     * @returns the trade seller address
     * @example trade.sellerAddress // EvmAddress
     */
    get sellerAddress(): EvmAddress;
    /**
     * @returns the trade buyer address
     * @example trade.buyerAddress // EvmAddress
     */
    get buyerAddress(): EvmAddress;
    /**
     * @returns the trade marketplace address
     * @example trade.marketplaceAddress // EvmAddress
     */
    get marketplaceAddress(): EvmAddress;
    /**
     * @returns the trade token address
     * @example trade.tokenAddress // EvmAddress
     */
    get tokenAddress(): EvmAddress;
    /**
     * @returns the trade price token address
     * @example trade.priceTokenAddress // EvmAddress
     */
    get priceTokenAddress(): EvmAddress | undefined;
    /**
     * @returns the trade price
     * @example trade.price // EvmNative
     */
    get price(): EvmNative;
    /**
     * @returns the trade block number
     * @example trade.blockNumber // BigNumber
     */
    get blockNumber(): BigNumber;
    /**
     * @returns the trade transaction index
     * @example trade.transactionIndex // 164
     */
    get transactionIndex(): number;
    /**
     * @returns the trade transaction hash
     * @example trade.transactionHash // "0x4de0bcef1450492bd5c2e7693cf644c40005868d0dcc8a7a50a80ef2efa88d1e"
     */
    get transactionHash(): string;
    /**
     * @returns the trade chain
     * @example trade.chain // EvmChain
     */
    get chain(): EvmChain;
    /**
     * @returns the trade token Ids
     * @example trade.tokenIds // ["16404"]
     */
    get tokenIds(): string[];
    /**
     * @returns the trade block hash
     * @example trade.blockHash // "0x4de0bcef1450492bd5c2e7693cf644c40005868d0dcc8a7a50a80ef2efa88d1e"
     */
    get blockHash(): string;
    /**
     * @returns the trade block timestamp
     * @example trade.blockTimestamp // Date
     */
    get blockTimestamp(): Date;
}

/**
 * This can be any object with valid transfer data.
 * @example
 * ```
 * const input = {
 *  chain: 1,
 *  tokenAddress: "0x057Ec652A4F150f7FF94f089A38008f49a0DF88e",
 *  toAddress: "0x057Ec652A4F150f7FF94f089A38008f49a0DF88e",
 *  operator: null,
 *  fromAddress: "0x057Ec652A4F150f7FF94f089A38008f49a0DF88e",
 *  value: null,
 *  blockTimestamp: "2021-06-04T16:00:15",
 *  blockHash: "0x057Ec652A4F150f7FF94f089A38008f49a0DF88e",
 *  transactionIndex: 123,
 *  blockNumber: "88256",
 *  contractType: "ERC721",
 *  logIndex: 0,
 *  tokenId: "15",
 *  transactionHash: "0x057Ec652A4F150f7FF94f089A38008f49a0DF88e",
 *  transactionType: "1",
 * }
 * ```
 */
interface EvmNftTransferInput {
    chain: EvmChainish;
    amount?: null | string | number;
    blockHash: string;
    blockNumber: BigNumberish;
    blockTimestamp: DateInput;
    contractType: string;
    fromAddress?: null | EvmAddressish;
    value?: null | EvmNativeish;
    logIndex: number | string;
    toAddress: EvmAddressish;
    tokenAddress: EvmAddressish;
    tokenId: string;
    transactionHash: string;
    transactionIndex?: null | string | number;
    transactionType?: null | string;
    operator?: null | EvmAddressish;
}
/**
 * This is the return type of the processed EVM NFT Transfer.
 */
interface EvmNftTransferData {
    chain: EvmChain;
    amount?: number;
    blockHash: string;
    blockNumber: BigNumber;
    blockTimestamp: Date;
    contractType: string;
    fromAddress?: EvmAddress;
    value?: EvmNative;
    logIndex: number;
    toAddress: EvmAddress;
    tokenAddress: EvmAddress;
    tokenId: string;
    transactionHash: string;
    transactionIndex?: number;
    transactionType?: string;
    operator?: EvmAddress;
}

/**
 * Valid input for a new EvmNftTransfer instance.
 * This can be an existing {@link EvmNftTransfer} or a valid {@link EvmNftTransferInput} object
 */
type EvmNftTransferish = EvmNftTransferInput | EvmNftTransfer;
/**
 * The EvmNftTransfer is a representation of a completed NFT transfer.
 *
 * @category DataType
 */
declare class EvmNftTransfer implements MoralisDataObject {
    /**
     * Create a new instance of EvmNftTransfer from any valid transfer input
     * @param data - the EvmNftTransferish type
     * @example
     * ```
     * const transfer = EvmNftTransfer.create(data);
     *```
     */
    static create(data: EvmNftTransferish, core?: _moralisweb3_common_core__default): EvmNftTransfer;
    protected _data: EvmNftTransferData;
    constructor(data: EvmNftTransferInput, core: _moralisweb3_common_core__default);
    static parse: (data: EvmNftTransferInput, core: _moralisweb3_common_core__default) => EvmNftTransferData;
    /**
     * Check the equality between two NFT transfers. The compares the chain, blockHash, tokenId and logIndex.
     * @param dataA - The first transfer to compare
     * @param dataB - The second transfer to compare
     * @example EvmNftTransfer.equals(dataA, dataB)
     * @returns true if the transfers are equal, false otherwise
     */
    static equals(dataA: EvmNftTransferish, dataB: EvmNftTransferish): boolean;
    /**
     * Checks the equality of the current transfer instance with another nft transfer
     * @param data - the transfer to compare with
     * @example transaction.equals(data)
     * @returns true if the transfers are equal, false otherwise
     */
    equals(data: EvmNftTransferish): boolean;
    /**
     * @returns a JSON represention of the transfer.
     * @example
     * ```
     * transfer.toJSON()
     * ```
     */
    toJSON(): {
        chain: string | number;
        fromAddress: string | undefined;
        toAddress: string;
        tokenAddress: string;
        value: string | undefined;
        operator: string | undefined;
        blockNumber: string;
        amount?: number | undefined;
        blockHash: string;
        blockTimestamp: Date;
        contractType: string;
        logIndex: number;
        tokenId: string;
        transactionHash: string;
        transactionIndex?: number | undefined;
        transactionType?: string | undefined;
    };
    /**
     * @returns a JSON represention of the transfer.
     * @example
     * ```
     * transfer.format()
     * ```
     */
    format(): {
        chain: string | number;
        fromAddress: string | undefined;
        toAddress: string;
        tokenAddress: string;
        value: string | undefined;
        operator: string | undefined;
        blockNumber: string;
        amount?: number | undefined;
        blockHash: string;
        blockTimestamp: Date;
        contractType: string;
        logIndex: number;
        tokenId: string;
        transactionHash: string;
        transactionIndex?: number | undefined;
        transactionType?: string | undefined;
    };
    /**
     * @returns all the data without casting it to JSON.
     * @example transfer.result
     */
    get result(): EvmNftTransferData;
    /**
     * @returns the chain of the transfer.
     * @example transfer.chain // EvmChain
     */
    get chain(): EvmChain;
    /**
     * @returns the block hash of the transfer.
     * @example transfer.blockHash // "0x057Ec652A4F150f7FF94f089A38008f49a0DF88e"
     */
    get blockHash(): string;
    /**
     * @returns the block number of the transfer.
     * @example transfer.blockNumber // BigNumber
     */
    get blockNumber(): BigNumber;
    /**
     * @returns the block timestamp of the transfer.
     * @example transfer.blockTimestamp // Date
     */
    get blockTimestamp(): Date;
    /**
     * @returns the from address of the transfer.
     * @example transfer.fromAddress // EvmAddress
     */
    get fromAddress(): EvmAddress | undefined;
    /**
     * @returns the to address of the transfer.
     * @example transfer.toAddress // EvmAddress
     */
    get toAddress(): EvmAddress;
    /**
     * @returns the token address of the transfer.
     * @example transfer.tokenAddress // EvmAddress
     */
    get tokenAddress(): EvmAddress;
    /**
     * @returns the token id of the transfer.
     * @example transfer.tokenId // "15"
     */
    get tokenId(): string;
    /**
     * @returns the amount of the transfer.
     * @example transfer.amount // 1
     */
    get amount(): number | undefined;
    /**
     * @returns the value of the transfer.
     * @example transfer.value // EvmNative
     */
    get value(): EvmNative | undefined;
    /**
     * @returns the log index of the transfer.
     * @example transfer.logIndex // 0
     */
    get logIndex(): number;
    /**
     * @returns the transaction hash of the transfer.
     * @example transfer.transactionHash // "0x057Ec652A4F150f7FF94f089A38008f49a0DF88e"
     */
    get transactionHash(): string;
    /**
     * @returns the transaction index of the transfer.
     * @example transfer.transactionIndex // 123
     */
    get transactionIndex(): number | undefined;
    /**
     * @returns the transaction type of the transfer.
     * @example transfer.transactionType // "1"
     */
    get transactionType(): string | undefined;
    /**
     * @returns the operator of the transfer.
     * @example transfer.operator // EvmAddress
     */
    get operator(): EvmAddress | undefined;
    /**
     * @returns the contract type of the transfer.
     * @example transfer.contractType // "ERC721"
     */
    get contractType(): string;
}

interface EvmAbiItem {
    name?: string;
    type?: string;
    anonymous?: boolean;
    payable?: boolean;
    constant?: boolean;
    stateMutability?: string;
    inputs?: EvmAbiItemVariable[];
    outputs?: EvmAbiItemVariable[];
    gas?: number;
}
interface EvmAbiItemVariable {
    name?: string;
    indexed?: boolean;
    type?: string;
    internalType?: string;
    components?: EvmAbiItemVariable[];
}

declare class CommonEvmUtils extends Module {
    static readonly moduleName = "evmUtils";
    static create(core?: _moralisweb3_common_core__default): CommonEvmUtils;
    private constructor();
    setup(): void;
    start(): void;
    get EvmAddress(): typeof EvmAddress;
    get EvmChain(): typeof EvmChain;
    get EvmNative(): typeof EvmNative;
}

declare class EvmChainResolver {
    static resolve(chain: EvmChainish | undefined, core: Core): EvmChain;
}

type OperationId$F = 'getNativeBalance';
type PathParams$v = operations$1[OperationId$F]['parameters']['path'];
type QueryParams$B = operations$1[OperationId$F]['parameters']['query'];
type RequestParams$C = PathParams$v & QueryParams$B;
type SuccessResponse$F = operations$1[OperationId$F]['responses']['200']['content']['application/json'];
interface GetNativeBalanceRequest extends Camelize<Omit<RequestParams$C, 'chain' | 'address'>> {
    chain?: EvmChainish;
    address: EvmAddressish;
}
type GetNativeBalanceJSONRequest = ReturnType<typeof serializeRequest$D>;
type GetNativeBalanceJSONResponse = SuccessResponse$F;
type GetNativeBalanceResponse = ReturnType<typeof deserializeResponse$F>;
interface GetNativeBalanceResponseAdapter extends ResponseAdapter<GetNativeBalanceResponse, GetNativeBalanceJSONResponse> {
}
/** Get the native balance for a specific wallet address. */
declare const getNativeBalanceOperation: Operation<GetNativeBalanceRequest, GetNativeBalanceJSONRequest, GetNativeBalanceResponse, GetNativeBalanceJSONResponse>;
declare function deserializeResponse$F(jsonResponse: GetNativeBalanceJSONResponse): {
    balance: EvmNative;
};
declare function serializeRequest$D(request: GetNativeBalanceRequest, core: Core): {
    chain: "0x1" | "0x5" | "0xaa36a7" | "0x89" | "0x13881" | "0x38" | "0x61" | "0xa86a" | "0xa869" | "0xfa" | "0x19" | "0x152" | "0x2a15c308d" | "0xa4B1";
    toBlock: number | undefined;
    address: string;
};

type OperationId$E = 'getNativeBalancesForAddresses';
type QueryParams$A = operations$1[OperationId$E]['parameters']['query'];
type RequestParams$B = QueryParams$A;
type SuccessResponse$E = operations$1[OperationId$E]['responses']['200']['content']['application/json'];
interface GetNativeBalancesForAddressesRequest extends Camelize<Omit<RequestParams$B, 'chain' | 'wallet_addresses'>> {
    chain?: EvmChainish;
    walletAddresses: EvmAddressish[];
}
type GetNativeBalancesForAddressesJSONRequest = ReturnType<typeof serializeRequest$C>;
type GetNativeBalancesForAddressesJSONResponse = SuccessResponse$E;
type GetNativeBalancesForAddressesResponse = ReturnType<typeof deserializeResponse$E>;
interface GetNativeBalancesForAddressesResponseAdapter extends ResponseAdapter<GetNativeBalancesForAddressesResponse, GetNativeBalancesForAddressesJSONResponse> {
}
/** Get the native balances for a set of specific addresses */
declare const getNativeBalancesForAddressesOperation: Operation<GetNativeBalancesForAddressesRequest, GetNativeBalancesForAddressesJSONRequest, GetNativeBalancesForAddressesResponse, GetNativeBalancesForAddressesJSONResponse>;
declare function deserializeResponse$E(jsonResponse: GetNativeBalancesForAddressesJSONResponse, request: GetNativeBalancesForAddressesRequest, core: Core): {
    chain: EvmChain;
    blockNumber: string;
    blockTimestamp: string;
    totalBalance: EvmNative;
    walletBalances: {
        address: EvmAddress;
        balance: EvmNative;
    }[];
}[];
declare function serializeRequest$C(request: GetNativeBalancesForAddressesRequest, core: Core): {
    chain: "0x1" | "0x5" | "0xaa36a7" | "0x89" | "0x13881" | "0x38" | "0x61" | "0xa86a" | "0xa869" | "0xfa" | "0x19" | "0x152" | "0x2a15c308d" | "0xa4B1";
    providerUrl: string | undefined;
    toBlock: number | undefined;
    walletAddresses: string[];
};

type OperationId$D = 'getBlock';
type PathParams$u = operations$1[OperationId$D]['parameters']['path'];
type QueryParams$z = operations$1[OperationId$D]['parameters']['query'];
type RequestParams$A = PathParams$u & QueryParams$z;
type SuccessResponse$D = operations$1[OperationId$D]['responses']['200']['content']['application/json'];
interface GetBlockRequest extends Camelize<Omit<RequestParams$A, 'chain'>> {
    chain?: EvmChainish;
}
type GetBlockJSONRequest = ReturnType<typeof serializeRequest$B>;
type GetBlockJSONResponse = SuccessResponse$D;
type GetBlockResponse = ReturnType<typeof deserializeResponse$D>;
interface GetBlockResponseAdapter extends ResponseAdapter<GetBlockResponse, GetBlockJSONResponse> {
}
/** Get the contents of a block given the block hash. */
declare const getBlockOperation: Operation<GetBlockRequest, GetBlockJSONRequest, GetBlockResponse, GetBlockJSONResponse>;
declare function deserializeResponse$D(jsonResponse: GetBlockJSONResponse, request: GetBlockRequest, core: Core): EvmBlock;
declare function serializeRequest$B(request: GetBlockRequest, core: Core): {
    chain: "0x1" | "0x5" | "0xaa36a7" | "0x89" | "0x13881" | "0x38" | "0x61" | "0xa86a" | "0xa869" | "0xfa" | "0x19" | "0x152" | "0x2a15c308d" | "0xa4B1";
    blockNumberOrHash: string;
};

type OperationId$C = 'getDateToBlock';
type QueryParams$y = operations$1[OperationId$C]['parameters']['query'];
type RequestParams$z = QueryParams$y;
type SuccessResponse$C = operations$1[OperationId$C]['responses']['200']['content']['application/json'];
interface GetDateToBlockRequest extends Camelize<Omit<RequestParams$z, 'chain' | 'date'>> {
    chain?: EvmChainish;
    date: DateInput;
}
type GetDateToBlockJSONRequest = ReturnType<typeof serializeRequest$A>;
type GetDateToBlockJSONResponse = SuccessResponse$C;
type GetDateToBlockResponse = ReturnType<typeof deserializeResponse$C>;
interface GetDateToBlockResponseAdapter extends ResponseAdapter<GetDateToBlockResponse, GetDateToBlockJSONResponse> {
}
/** Get the closest block given the date. */
declare const getDateToBlockOperation: Operation<GetDateToBlockRequest, GetDateToBlockJSONRequest, GetDateToBlockResponse, GetDateToBlockJSONResponse>;
declare function deserializeResponse$C(jsonResponse: GetDateToBlockJSONResponse): EvmBlockDate;
declare function serializeRequest$A(request: GetDateToBlockRequest, core: Core): {
    chain: "0x1" | "0x5" | "0xaa36a7" | "0x89" | "0x13881" | "0x38" | "0x61" | "0xa86a" | "0xa869" | "0xfa" | "0x19" | "0x152" | "0x2a15c308d" | "0xa4B1";
    date: string;
};

type OperationId$B = 'getPairAddress';
type PathParams$t = operations$1[OperationId$B]['parameters']['path'];
type QueryParams$x = operations$1[OperationId$B]['parameters']['query'];
type RequestParams$y = PathParams$t & QueryParams$x;
type SuccessResponse$B = operations$1[OperationId$B]['responses']['200']['content']['application/json'];
interface GetPairAddressRequest extends Camelize<Omit<RequestParams$y, 'chain' | 'token0_address' | 'token1_address' | 'to_date'>> {
    chain?: EvmChainish;
    token0Address: EvmAddressish;
    token1Address: EvmAddressish;
    toDate?: DateInput;
}
type GetPairAddressJSONRequest = ReturnType<typeof serializeRequest$z>;
type GetPairAddressJSONResponse = SuccessResponse$B;
type GetPairAddressResponse = ReturnType<typeof deserializeResponse$B>;
interface GetPairAddressResponseAdapter extends ResponseAdapter<GetPairAddressResponse, GetPairAddressJSONResponse> {
}
/**
 * Fetch the pair data of the provided token0+token1 combination.
 * The token0 and token1 options are interchangable (ie. there is no different outcome in "token0=WETH and token1=USDT" or "token0=USDT and token1=WETH")
 */
declare const getPairAddressOperation: Operation<GetPairAddressRequest, GetPairAddressJSONRequest, GetPairAddressResponse, GetPairAddressJSONResponse>;
declare function deserializeResponse$B(jsonResponse: GetPairAddressJSONResponse, request: GetPairAddressRequest, core: Core): {
    token0: {
        token: Erc20Token;
        blockNumber: string | undefined;
        validated: number | undefined;
        createdAt: Date | undefined;
    };
    token1: {
        token: Erc20Token;
        blockNumber: string | undefined;
        validated: number | undefined;
        createdAt: Date | undefined;
    };
    pairAddress: EvmAddress | undefined;
};
declare function serializeRequest$z(request: GetPairAddressRequest, core: Core): {
    chain: "0x1" | "0x5" | "0xaa36a7" | "0x89" | "0x13881" | "0x38" | "0x61" | "0xa86a" | "0xa869" | "0xfa" | "0x19" | "0x152" | "0x2a15c308d" | "0xa4B1";
    toBlock: string | undefined;
    toDate: string | undefined;
    exchange: Camelize<"uniswapv2" | "uniswapv3" | "sushiswapv2" | "pancakeswapv2" | "pancakeswapv1" | "quickswap">;
    token0Address: string;
    token1Address: string;
};

type OperationId$A = 'getPairReserves';
type PathParams$s = operations$1[OperationId$A]['parameters']['path'];
type QueryParams$w = operations$1[OperationId$A]['parameters']['query'];
type RequestParams$x = PathParams$s & QueryParams$w;
type SuccessResponse$A = operations$1[OperationId$A]['responses']['200']['content']['application/json'];
interface GetPairReservesRequest extends Camelize<Omit<RequestParams$x, 'chain' | 'pair_address' | 'to_date'>> {
    chain?: EvmChainish;
    pairAddress: EvmAddressish;
    toDate?: DateInput;
}
type GetPairReservesJSONRequest = ReturnType<typeof serializeRequest$y>;
type GetPairReservesJSONResponse = SuccessResponse$A;
type GetPairReservesResponse = ReturnType<typeof deserializeResponse$A>;
interface GetPairReservesResponseAdapter extends ResponseAdapter<GetPairReservesResponse, GetPairReservesJSONResponse> {
}
/** Get the liquidity reserves for a given pair address. Only Uniswap V2 based exchanges supported at the moment. */
declare const getPairReservesOperation: Operation<GetPairReservesRequest, GetPairReservesJSONRequest, GetPairReservesResponse, GetPairReservesJSONResponse>;
declare function serializeRequest$y(request: GetPairReservesRequest, core: Core): {
    chain: "0x1" | "0x5" | "0xaa36a7" | "0x89" | "0x13881" | "0x38" | "0x61" | "0xa86a" | "0xa869" | "0xfa" | "0x19" | "0x152" | "0x2a15c308d" | "0xa4B1";
    toBlock: string | undefined;
    toDate: string | undefined;
    pairAddress: string;
};
declare function deserializeResponse$A(jsonResponse: GetPairReservesJSONResponse): {
    reserve0?: string | undefined;
    reserve1?: string | undefined;
};

type OperationId$z = 'getContractEvents';
type PathParams$r = operations$1[OperationId$z]['parameters']['path'];
type QueryParams$v = operations$1[OperationId$z]['parameters']['query'];
type RequestParams$w = PathParams$r & QueryParams$v;
type SuccessResponse$z = operations$1[OperationId$z]['responses']['200']['content']['application/json'];
interface GetContractEventsRequest extends Camelize<Omit<RequestParams$w, 'chain' | 'address' | 'from_date' | 'to_date'>> {
    chain?: EvmChainish;
    address: EvmAddressish;
    abi: EvmAbiItem;
    fromDate?: DateInput;
    toDate?: DateInput;
}
type GetContractEventsJSONRequest = ReturnType<typeof serializeRequest$x>;
type GetContractEventsJSONResponse = SuccessResponse$z;
type GetContractEventsResponse = ReturnType<typeof deserializeResponse$z>;
interface GetContractEventsResponseAdapter extends PaginatedResponseAdapter<GetContractEventsResponse, GetContractEventsJSONResponse['result']> {
}
/** Get events for a contract ordered by block number in descending order. */
declare const getContractEventsOperation: PaginatedOperation<GetContractEventsRequest, GetContractEventsJSONRequest, GetContractEventsResponse, GetContractEventsJSONResponse['result']>;
declare function deserializeResponse$z(jsonResponse: GetContractEventsJSONResponse, request: GetContractEventsRequest, core: Core): EvmEvent[];
declare function serializeRequest$x(request: GetContractEventsRequest, core: Core): {
    chain: "0x1" | "0x5" | "0xaa36a7" | "0x89" | "0x13881" | "0x38" | "0x61" | "0xa86a" | "0xa869" | "0xfa" | "0x19" | "0x152" | "0x2a15c308d" | "0xa4B1";
    fromBlock: number | undefined;
    toBlock: number | undefined;
    fromDate: string | undefined;
    toDate: string | undefined;
    topic: string;
    offset: number | undefined;
    limit: number | undefined;
    address: string;
    abi: EvmAbiItem;
    disableTotal: boolean | undefined;
};

type OperationId$y = 'getContractLogs';
type PathParams$q = operations$1[OperationId$y]['parameters']['path'];
type QueryParams$u = operations$1[OperationId$y]['parameters']['query'];
type RequestParams$v = PathParams$q & QueryParams$u;
type SuccessResponse$y = operations$1[OperationId$y]['responses']['200']['content']['application/json'];
interface GetContractLogsRequest extends Camelize<Omit<RequestParams$v, 'chain' | 'address' | 'from_date' | 'to_date'>> {
    chain?: EvmChainish;
    address: EvmAddressish;
    fromDate?: DateInput;
    toDate?: DateInput;
}
type GetContractLogsJSONRequest = ReturnType<typeof serializeRequest$w>;
type GetContractLogsJSONResponse = SuccessResponse$y;
type GetContractLogsResponse = ReturnType<typeof deserializeResponse$y>;
interface GetContractLogsResponseAdapter extends PaginatedResponseAdapter<GetContractLogsResponse, GetContractLogsJSONResponse['result']> {
}
/** Get the logs for a contract. */
declare const getContractLogsOperation: PaginatedOperation<GetContractLogsRequest, GetContractLogsJSONRequest, GetContractLogsResponse, GetContractLogsJSONResponse['result']>;
declare function serializeRequest$w(request: GetContractLogsRequest, core: Core): {
    chain: "0x1" | "0x5" | "0xaa36a7" | "0x89" | "0x13881" | "0x38" | "0x61" | "0xa86a" | "0xa869" | "0xfa" | "0x19" | "0x152" | "0x2a15c308d" | "0xa4B1";
    blockNumber: string | undefined;
    fromBlock: string | undefined;
    toBlock: string | undefined;
    fromDate: string | undefined;
    toDate: string | undefined;
    topic0: string | undefined;
    topic1: string | undefined;
    topic2: string | undefined;
    topic3: string | undefined;
    limit: number | undefined;
    cursor: string | undefined;
    address: string;
    disableTotal: boolean | undefined;
};
declare function deserializeResponse$y(jsonResponse: GetContractLogsJSONResponse, request: GetContractLogsRequest, core: Core): EvmTransactionLog[];

type OperationId$x = 'uploadFolder';
type SuccessResponse$x = operations$1[OperationId$x]['responses']['200']['content']['application/json'];
interface UploadFolderRequest {
    abi: {
        path: string;
        content: string;
    }[];
}
type UploadFolderJSONRequest = ReturnType<typeof serializeRequest$v>;
type UploadFolderJSONResponse = SuccessResponse$x;
type UploadFolderResponse = ReturnType<typeof deserializeResponse$x>;
interface UploadFolderResponseAdapter extends ResponseAdapter<UploadFolderResponse, UploadFolderJSONResponse> {
}
/** Upload multiple files to IPFS and place them in a folder directory. */
declare const uploadFolderOperation: Operation<UploadFolderRequest, UploadFolderJSONRequest, UploadFolderResponse, UploadFolderJSONResponse>;
declare function deserializeResponse$x(jsonResponse: UploadFolderJSONResponse): {
    path: string;
}[];
declare function serializeRequest$v(request: UploadFolderRequest): {
    abi: string;
};

type OperationId$w = 'getContractNFTs';
type PathParams$p = operations$1[OperationId$w]['parameters']['path'];
type QueryParams$t = operations$1[OperationId$w]['parameters']['query'];
type RequestParams$u = PathParams$p & QueryParams$t;
type SuccessResponse$w = operations$1[OperationId$w]['responses']['200']['content']['application/json'];
interface GetContractNFTsRequest extends Camelize<Omit<RequestParams$u, 'chain' | 'address'>> {
    chain?: EvmChainish;
    address: EvmAddressish;
}
type GetContractNFTsJSONRequest = ReturnType<typeof serializeRequest$u>;
type GetContractNFTsJSONResponse = SuccessResponse$w;
type GetContractNFTsResponse = ReturnType<typeof deserializeResponse$w>;
interface GetContractNFTsResponseAdapter extends PaginatedResponseAdapter<GetContractNFTsResponse, GetContractNFTsJSONResponse['result']> {
}
/**
 * Get NFTs for a given contract address, including metadata for all NFTs (where available).
 * * Results are limited to 100 per page by default
 * * Requests for contract addresses not yet indexed will automatically start the indexing process for that NFT collection.
 */
declare const getContractNFTsOperation: PaginatedOperation<GetContractNFTsRequest, GetContractNFTsJSONRequest, GetContractNFTsResponse, GetContractNFTsJSONResponse['result']>;
declare function deserializeResponse$w(jsonResponse: GetContractNFTsJSONResponse, request: GetContractNFTsRequest, core: Core): EvmNft[];
declare function serializeRequest$u(request: GetContractNFTsRequest, core: Core): {
    chain: "0x1" | "0x5" | "0xaa36a7" | "0x89" | "0x13881" | "0x38" | "0x61" | "0xa86a" | "0xa869" | "0xfa" | "0x19" | "0x152" | "0x2a15c308d" | "0xa4B1";
    format: "decimal" | "hex" | undefined;
    limit: number | undefined;
    totalRanges: number | undefined;
    range: number | undefined;
    cursor: string | undefined;
    address: string;
    normalizeMetadata: boolean | undefined;
    disableTotal: boolean | undefined;
};

type GetElementType<Element extends unknown[]> = Element extends (infer Infered)[] ? Infered : never;
type OperationId$v = 'getMultipleNFTs';
type QueryParams$s = operations$1[OperationId$v]['parameters']['query'];
type BodyParams$1 = operations$1[OperationId$v]['requestBody']['content']['application/json'];
type RequestParams$t = QueryParams$s & BodyParams$1;
type SuccessElement = GetElementType<operations$1[OperationId$v]['responses']['200']['content']['application/json']>;
type SuccessResponse$v = (SuccessElement | null)[];
interface GetMultipleNFTsRequest extends Camelize<Omit<RequestParams$t, 'chain' | 'tokens'>> {
    chain?: EvmChainish;
    tokens: {
        tokenAddress: EvmAddressish;
        tokenId: string;
    }[];
}
type GetMultipleNFTsJSONRequest = ReturnType<typeof serializeRequest$t>;
type GetMultipleNFTsJSONResponse = SuccessResponse$v;
type GetMultipleNFTsResponse = ReturnType<typeof deserializeResponse$v>;
interface GetMultipleNFTsResponseAdapter extends ResponseAdapter<GetMultipleNFTsResponse, GetMultipleNFTsJSONResponse> {
}
/**
 * Get NFTs for a given contract address, including metadata for all NFTs (where available).
 * * Results are limited to 100 per page by default
 * * Requests for contract addresses not yet indexed will automatically start the indexing process for that NFT collection.
 */
declare const getMultipleNFTsOperation: Operation<GetMultipleNFTsRequest, GetMultipleNFTsJSONRequest, GetMultipleNFTsResponse, GetMultipleNFTsJSONResponse>;
declare function deserializeResponse$v(jsonResponse: GetMultipleNFTsJSONResponse, request: GetMultipleNFTsRequest, core: Core): (EvmNft | null)[];
declare function serializeRequest$t(request: GetMultipleNFTsRequest, core: Core): {
    chain: "0x1" | "0x5" | "0xaa36a7" | "0x89" | "0x13881" | "0x38" | "0x61" | "0xa86a" | "0xa869" | "0xfa" | "0x19" | "0x152" | "0x2a15c308d" | "0xa4B1";
    normalizeMetadata: boolean | undefined;
    tokens: {
        tokenAddress: string;
        tokenId: string;
    }[];
};

type OperationId$u = 'getNFTContractMetadata';
type PathParams$o = operations$1[OperationId$u]['parameters']['path'];
type QueryParams$r = operations$1[OperationId$u]['parameters']['query'];
type RequestParams$s = PathParams$o & QueryParams$r;
type SuccessResponse$u = operations$1[OperationId$u]['responses']['200']['content']['application/json'];
interface GetNFTContractMetadataRequest extends Camelize<Omit<RequestParams$s, 'chain' | 'address'>> {
    chain?: EvmChainish;
    address: EvmAddressish;
}
type GetNFTContractMetadataJSONRequest = ReturnType<typeof serializeRequest$s>;
type GetNFTContractMetadataJSONResponse = SuccessResponse$u;
type GetNFTContractMetadataResponse = ReturnType<typeof deserializeResponse$u>;
interface GetNFTContractMetadataResponseAdapter extends ResponseAdapter<GetNFTContractMetadataResponse, GetNFTContractMetadataJSONResponse> {
}
/**
 * Get the collection / contract level metadata for a given contract (name, symbol, base token uri).
 * * Requests for contract addresses not yet indexed will automatically start the indexing process for that NFT collection
 */
declare const getNFTContractMetadataOperation: Operation<GetNFTContractMetadataRequest, GetNFTContractMetadataJSONRequest, GetNFTContractMetadataResponse, GetNFTContractMetadataJSONResponse>;
declare function deserializeResponse$u(jsonResponse: GetNFTContractMetadataJSONResponse, request: GetNFTContractMetadataRequest, core: Core): EvmNftMetadata;
declare function serializeRequest$s(request: GetNFTContractMetadataRequest, core: Core): {
    chain: "0x1" | "0x5" | "0xaa36a7" | "0x89" | "0x13881" | "0x38" | "0x61" | "0xa86a" | "0xa869" | "0xfa" | "0x19" | "0x152" | "0x2a15c308d" | "0xa4B1";
    address: string;
};

type OperationId$t = 'getNFTContractTransfers';
type PathParams$n = operations$1[OperationId$t]['parameters']['path'];
type QueryParams$q = operations$1[OperationId$t]['parameters']['query'];
type RequestParams$r = PathParams$n & QueryParams$q;
type SuccessResponse$t = operations$1[OperationId$t]['responses']['200']['content']['application/json'];
interface GetNFTContractTransfersRequest extends Camelize<Omit<RequestParams$r, 'chain' | 'address' | 'from_date' | 'to_date'>> {
    chain?: EvmChainish;
    address: EvmAddressish;
    fromDate?: DateInput;
    toDate?: DateInput;
}
type GetNFTContractTransfersJSONRequest = ReturnType<typeof serializeRequest$r>;
type GetNFTContractTransfersJSONResponse = SuccessResponse$t;
type GetNFTContractTransfersResponse = ReturnType<typeof deserializeResponse$t>;
interface GetNFTContractTransfersResponseAdapter extends PaginatedResponseAdapter<GetNFTContractTransfersResponse, GetNFTContractTransfersJSONResponse['result']> {
}
/** Get transfers of NFTs for a given contract and other parameters. */
declare const getNFTContractTransfersOperation: PaginatedOperation<GetNFTContractTransfersRequest, GetNFTContractTransfersJSONRequest, GetNFTContractTransfersResponse, GetNFTContractTransfersJSONResponse['result']>;
declare function deserializeResponse$t(jsonResponse: GetNFTContractTransfersJSONResponse, request: GetNFTContractTransfersRequest, core: Core): EvmNftTransfer[];
declare function serializeRequest$r(request: GetNFTContractTransfersRequest, core: Core): {
    chain: "0x1" | "0x5" | "0xaa36a7" | "0x89" | "0x13881" | "0x38" | "0x61" | "0xa86a" | "0xa869" | "0xfa" | "0x19" | "0x152" | "0x2a15c308d" | "0xa4B1";
    format: "decimal" | "hex" | undefined;
    limit: number | undefined;
    cursor: string | undefined;
    address: string;
    fromBlock: number | undefined;
    toBlock: number | undefined;
    fromDate: string | undefined;
    toDate: string | undefined;
    disableTotal: boolean | undefined;
};

type OperationId$s = 'getNFTLowestPrice';
type PathParams$m = operations$1[OperationId$s]['parameters']['path'];
type QueryParams$p = operations$1[OperationId$s]['parameters']['query'];
type RequestParams$q = PathParams$m & QueryParams$p;
type SuccessResponse$s = operations$1[OperationId$s]['responses']['200']['content']['application/json'];
interface GetNFTLowestPriceRequest extends Camelize<Omit<RequestParams$q, 'chain' | 'address'>> {
    chain?: EvmChainish;
    address: EvmAddressish;
}
type GetNFTLowestPriceJSONRequest = ReturnType<typeof serializeRequest$q>;
type GetNFTLowestPriceJSONResponse = SuccessResponse$s;
type GetNFTLowestPriceResponse = ReturnType<typeof deserializeResponse$s>;
interface GetNFTLowestPriceResponseAdapter extends ResponseAdapter<GetNFTLowestPriceResponse, GetNFTLowestPriceJSONResponse> {
}
/** Get the lowest executed price for an NFT contract for the last x days (only trades paid in ETH). */
declare const getNFTLowestPriceOperation: Operation<GetNFTLowestPriceRequest, GetNFTLowestPriceJSONRequest, GetNFTLowestPriceResponse, GetNFTLowestPriceJSONResponse>;
declare function deserializeResponse$s(jsonResponse: GetNFTLowestPriceJSONResponse, request: GetNFTLowestPriceRequest, core: Core): EvmNftTrade;
declare function serializeRequest$q(request: GetNFTLowestPriceRequest, core: Core): {
    chain: "0x1" | "0x5" | "0xaa36a7" | "0x89" | "0x13881" | "0x38" | "0x61" | "0xa86a" | "0xa869" | "0xfa" | "0x19" | "0x152" | "0x2a15c308d" | "0xa4B1";
    days: number | undefined;
    marketplace: "opensea" | undefined;
    address: string;
};

type OperationId$r = 'getNFTMetadata';
type PathParams$l = operations$1[OperationId$r]['parameters']['path'];
type QueryParams$o = operations$1[OperationId$r]['parameters']['query'];
type RequestParams$p = PathParams$l & QueryParams$o;
type SuccessResponse$r = operations$1[OperationId$r]['responses']['200']['content']['application/json'];
interface GetNFTMetadataRequest extends Camelize<Omit<RequestParams$p, 'chain' | 'address'>> {
    chain?: EvmChainish;
    address: EvmAddressish;
}
type GetNFTMetadataJSONRequest = ReturnType<typeof serializeRequest$p>;
type GetNFTMetadataJSONResponse = SuccessResponse$r;
type GetNFTMetadataResponse = ReturnType<typeof deserializeResponse$r>;
interface GetNFTMetadataResponseAdapter extends ResponseAdapter<GetNFTMetadataResponse, GetNFTMetadataJSONResponse> {
}
/**
 * Get NFT data, including metadata (where available), for the given NFT token ID and contract address.
 * * Requests for contract addresses not yet indexed will automatically start the indexing process for that NFT collection
 */
declare const getNFTMetadataOperation: Operation<GetNFTMetadataRequest, GetNFTMetadataJSONRequest, GetNFTMetadataResponse, GetNFTMetadataJSONResponse>;
declare function deserializeResponse$r(jsonResponse: GetNFTMetadataJSONResponse, request: GetNFTMetadataRequest, core: Core): EvmNft;
declare function serializeRequest$p(request: GetNFTMetadataRequest, core: Core): {
    chain: "0x1" | "0x5" | "0xaa36a7" | "0x89" | "0x13881" | "0x38" | "0x61" | "0xa86a" | "0xa869" | "0xfa" | "0x19" | "0x152" | "0x2a15c308d" | "0xa4B1";
    format: "decimal" | "hex" | undefined;
    address: string;
    tokenId: string;
    normalizeMetadata: boolean | undefined;
};

type OperationId$q = 'getNFTOwners';
type PathParams$k = operations$1[OperationId$q]['parameters']['path'];
type QueryParams$n = operations$1[OperationId$q]['parameters']['query'];
type RequestParams$o = PathParams$k & QueryParams$n;
type SuccessResponse$q = operations$1[OperationId$q]['responses']['200']['content']['application/json'];
interface GetNFTOwnersRequest extends Camelize<Omit<RequestParams$o, 'chain' | 'address'>> {
    chain?: EvmChainish;
    address: EvmAddressish;
}
type GetNFTOwnersJSONRequest = ReturnType<typeof serializeRequest$o>;
type GetNFTOwnersJSONResponse = SuccessResponse$q;
type GetNFTOwnersResponse = ReturnType<typeof deserializeResponse$q>;
interface GetNFTOwnersResponseAdapter extends PaginatedResponseAdapter<GetNFTOwnersResponse, GetNFTOwnersJSONResponse['result']> {
}
/**
 * Get owners of NFTs for a given contract.
 * * Requests for contract addresses not yet indexed will automatically start the indexing process for that NFT collection.
 */
declare const getNFTOwnersOperation: PaginatedOperation<GetNFTOwnersRequest, GetNFTOwnersJSONRequest, GetNFTOwnersResponse, GetNFTOwnersJSONResponse['result']>;
declare function deserializeResponse$q(jsonResponse: GetNFTOwnersJSONResponse, request: GetNFTOwnersRequest, core: Core): EvmNft[];
declare function serializeRequest$o(request: GetNFTOwnersRequest, core: Core): {
    chain: "0x1" | "0x5" | "0xaa36a7" | "0x89" | "0x13881" | "0x38" | "0x61" | "0xa86a" | "0xa869" | "0xfa" | "0x19" | "0x152" | "0x2a15c308d" | "0xa4B1";
    format: "decimal" | "hex" | undefined;
    limit: number | undefined;
    cursor: string | undefined;
    address: string;
    normalizeMetadata: boolean | undefined;
    disableTotal: boolean | undefined;
};

type OperationId$p = 'getNFTTokenIdOwners';
type PathParams$j = operations$1[OperationId$p]['parameters']['path'];
type QueryParams$m = operations$1[OperationId$p]['parameters']['query'];
type RequestParams$n = PathParams$j & QueryParams$m;
type SuccessResponse$p = operations$1[OperationId$p]['responses']['200']['content']['application/json'];
interface GetNFTTokenIdOwnersRequest extends Camelize<Omit<RequestParams$n, 'chain' | 'address'>> {
    chain?: EvmChainish;
    address: EvmAddressish;
}
type GetNFTTokenIdOwnersJSONRequest = ReturnType<typeof serializeRequest$n>;
type GetNFTTokenIdOwnersJSONResponse = SuccessResponse$p;
type GetNFTTokenIdOwnersResponse = ReturnType<typeof deserializeResponse$p>;
interface GetNFTTokenIdOwnersResponseAdapter extends PaginatedResponseAdapter<GetNFTTokenIdOwnersResponse, GetNFTTokenIdOwnersJSONResponse['result']> {
}
/**
 * Get owners of a specific NFT given the contract address and token ID.
 * * Requests for contract addresses not yet indexed will automatically start the indexing process for that NFT collection
 */
declare const getNFTTokenIdOwnersOperation: PaginatedOperation<GetNFTTokenIdOwnersRequest, GetNFTTokenIdOwnersJSONRequest, GetNFTTokenIdOwnersResponse, GetNFTTokenIdOwnersJSONResponse['result']>;
declare function deserializeResponse$p(jsonResponse: GetNFTTokenIdOwnersJSONResponse, request: GetNFTTokenIdOwnersRequest, core: Core): EvmNft[];
declare function serializeRequest$n(request: GetNFTTokenIdOwnersRequest, core: Core): {
    chain: "0x1" | "0x5" | "0xaa36a7" | "0x89" | "0x13881" | "0x38" | "0x61" | "0xa86a" | "0xa869" | "0xfa" | "0x19" | "0x152" | "0x2a15c308d" | "0xa4B1";
    format: "decimal" | "hex" | undefined;
    limit: number | undefined;
    cursor: string | undefined;
    address: string;
    tokenId: string;
    normalizeMetadata: boolean | undefined;
    disableTotal: boolean | undefined;
};

type OperationId$o = 'getNFTTrades';
type PathParams$i = operations$1[OperationId$o]['parameters']['path'];
type QueryParams$l = operations$1[OperationId$o]['parameters']['query'];
type RequestParams$m = PathParams$i & QueryParams$l;
type SuccessResponse$o = operations$1[OperationId$o]['responses']['200']['content']['application/json'];
interface GetNFTTradesRequest extends Camelize<Omit<RequestParams$m, 'chain' | 'address' | 'from_date' | 'to_date'>> {
    chain?: EvmChainish;
    address: EvmAddressish;
    fromDate?: DateInput;
    toDate?: DateInput;
}
type GetNFTTradesJSONRequest = ReturnType<typeof serializeRequest$m>;
type GetNFTTradesJSONResponse = SuccessResponse$o;
type GetNFTTradesResponse = ReturnType<typeof deserializeResponse$o>;
interface GetNFTTradesResponseAdapter extends PaginatedResponseAdapter<GetNFTTradesResponse, GetNFTTradesJSONResponse['result']> {
}
/** Get trades of NFTs for a given contract and marketplace. */
declare const getNFTTradesOperation: PaginatedOperation<GetNFTTradesRequest, GetNFTTradesJSONRequest, GetNFTTradesResponse, GetNFTTradesJSONResponse['result']>;
declare function deserializeResponse$o(jsonResponse: GetNFTTradesJSONResponse, request: GetNFTTradesRequest, core: Core): EvmNftTrade[];
declare function serializeRequest$m(request: GetNFTTradesRequest, core: Core): {
    chain: "0x1" | "0x5" | "0xaa36a7" | "0x89" | "0x13881" | "0x38" | "0x61" | "0xa86a" | "0xa869" | "0xfa" | "0x19" | "0x152" | "0x2a15c308d" | "0xa4B1";
    fromBlock: number | undefined;
    toBlock: string | undefined;
    fromDate: DateInput | undefined;
    toDate: DateInput | undefined;
    marketplace: "opensea" | undefined;
    cursor: string | undefined;
    limit: number | undefined;
    address: string;
    disableTotal: boolean | undefined;
};

type OperationId$n = 'getNFTTransfersByBlock';
type PathParams$h = operations$1[OperationId$n]['parameters']['path'];
type QueryParams$k = operations$1[OperationId$n]['parameters']['query'];
type RequestParams$l = PathParams$h & QueryParams$k;
type SuccessResponse$n = operations$1[OperationId$n]['responses']['200']['content']['application/json'];
interface GetNFTTransfersByBlockRequest extends Camelize<Omit<RequestParams$l, 'chain'>> {
    chain?: EvmChainish;
}
type GetNFTTransfersByBlockJSONRequest = ReturnType<typeof serializeRequest$l>;
type GetNFTTransfersByBlockJSONResponse = SuccessResponse$n;
type GetNFTTransfersByBlockResponse = ReturnType<typeof deserializeResponse$n>;
interface GetNFTTransfersByBlockResponseAdapter extends PaginatedResponseAdapter<GetNFTTransfersByBlockResponse, GetNFTTransfersByBlockJSONResponse['result']> {
}
/** Get transfers of NFTs given a block number or block hash. */
declare const getNFTTransfersByBlockOperation: PaginatedOperation<GetNFTTransfersByBlockRequest, GetNFTTransfersByBlockJSONRequest, GetNFTTransfersByBlockResponse, GetNFTTransfersByBlockJSONResponse['result']>;
declare function deserializeResponse$n(jsonResponse: GetNFTTransfersByBlockJSONResponse, request: GetNFTTransfersByBlockRequest, core: Core): EvmNftTransfer[];
declare function serializeRequest$l(request: GetNFTTransfersByBlockRequest, core: Core): {
    chain: "0x1" | "0x5" | "0xaa36a7" | "0x89" | "0x13881" | "0x38" | "0x61" | "0xa86a" | "0xa869" | "0xfa" | "0x19" | "0x152" | "0x2a15c308d" | "0xa4B1";
    limit: number | undefined;
    cursor: string | undefined;
    blockNumberOrHash: string;
    disableTotal: boolean | undefined;
};

type OperationId$m = 'getNFTTransfersFromToBlock';
type QueryParams$j = operations$1[OperationId$m]['parameters']['query'];
type RequestParams$k = QueryParams$j;
type SuccessResponse$m = operations$1[OperationId$m]['responses']['200']['content']['application/json'];
interface GetNFTTransfersFromToBlockRequest extends Camelize<Omit<RequestParams$k, 'chain' | 'from_date' | 'to_date'>> {
    chain?: EvmChainish;
    fromDate?: DateInput;
    toDate?: DateInput;
}
type GetNFTTransfersFromToBlockJSONRequest = ReturnType<typeof serializeRequest$k>;
type GetNFTTransfersFromToBlockJSONResponse = SuccessResponse$m;
type GetNFTTransfersFromToBlockResponse = ReturnType<typeof deserializeResponse$m>;
interface GetNFTTransfersFromToBlockResponseAdapter extends PaginatedResponseAdapter<GetNFTTransfersFromToBlockResponse, GetNFTTransfersFromToBlockJSONResponse['result']> {
}
/** Get transfers of NFTs from a block number to a block number. */
declare const getNFTTransfersFromToBlockOperation: PaginatedOperation<GetNFTTransfersFromToBlockRequest, GetNFTTransfersFromToBlockJSONRequest, GetNFTTransfersFromToBlockResponse, GetNFTTransfersFromToBlockJSONResponse['result']>;
declare function deserializeResponse$m(jsonResponse: GetNFTTransfersFromToBlockJSONResponse, request: GetNFTTransfersFromToBlockRequest, core: Core): EvmNftTransfer[];
declare function serializeRequest$k(request: GetNFTTransfersFromToBlockRequest, core: Core): {
    chain: "0x1" | "0x5" | "0xaa36a7" | "0x89" | "0x13881" | "0x38" | "0x61" | "0xa86a" | "0xa869" | "0xfa" | "0x19" | "0x152" | "0x2a15c308d" | "0xa4B1";
    fromBlock: number | undefined;
    toBlock: number | undefined;
    fromDate: DateInput | undefined;
    toDate: DateInput | undefined;
    format: "decimal" | "hex" | undefined;
    limit: number | undefined;
    cursor: string | undefined;
    disableTotal: boolean | undefined;
};

type OperationId$l = 'getNFTTransfers';
type PathParams$g = operations$1[OperationId$l]['parameters']['path'];
type QueryParams$i = operations$1[OperationId$l]['parameters']['query'];
type RequestParams$j = PathParams$g & QueryParams$i;
type SuccessResponse$l = operations$1[OperationId$l]['responses']['200']['content']['application/json'];
interface GetNFTTransfersRequest extends Camelize<Omit<RequestParams$j, 'chain' | 'address'>> {
    chain?: EvmChainish;
    address: EvmAddressish;
}
type GetNFTTransfersJSONRequest = ReturnType<typeof serializeRequest$j>;
type GetNFTTransfersJSONResponse = SuccessResponse$l;
type GetNFTTransfersResponse = ReturnType<typeof deserializeResponse$l>;
interface GetNFTTransfersResponseAdapter extends PaginatedResponseAdapter<GetNFTTransfersResponse, GetNFTTransfersJSONResponse['result']> {
}
/** Get transfers of an NFT given a contract address and token ID. */
declare const getNFTTransfersOperation: PaginatedOperation<GetNFTTransfersRequest, GetNFTTransfersJSONRequest, GetNFTTransfersResponse, GetNFTTransfersJSONResponse['result']>;
declare function deserializeResponse$l(jsonResponse: GetNFTTransfersJSONResponse, request: GetNFTTransfersRequest, core: Core): EvmNftTransfer[];
declare function serializeRequest$j(request: GetNFTTransfersRequest, core: Core): {
    chain: "0x1" | "0x5" | "0xaa36a7" | "0x89" | "0x13881" | "0x38" | "0x61" | "0xa86a" | "0xa869" | "0xfa" | "0x19" | "0x152" | "0x2a15c308d" | "0xa4B1";
    format: "decimal" | "hex" | undefined;
    limit: number | undefined;
    cursor: string | undefined;
    address: string;
    tokenId: string;
    disableTotal: boolean | undefined;
};

type OperationId$k = 'getWalletNFTCollections';
type PathParams$f = operations$1[OperationId$k]['parameters']['path'];
type QueryParams$h = operations$1[OperationId$k]['parameters']['query'];
type RequestParams$i = PathParams$f & QueryParams$h;
type SuccessResponse$k = operations$1[OperationId$k]['responses']['200']['content']['application/json'];
interface GetWalletNFTCollectionsRequest extends Camelize<Omit<RequestParams$i, 'chain' | 'address'>> {
    chain?: EvmChainish;
    address: EvmAddressish;
}
type GetWalletNFTCollectionsJSONRequest = ReturnType<typeof serializeRequest$i>;
type GetWalletNFTCollectionsJSONResponse = SuccessResponse$k;
type GetWalletNFTCollectionsResponse = ReturnType<typeof deserializeResponse$k>;
interface GetWalletNFTCollectionsResponseAdapter extends PaginatedResponseAdapter<GetWalletNFTCollectionsResponse, GetWalletNFTCollectionsJSONResponse['result']> {
}
/** Get NFT collections owned by a given wallet address. */
declare const getWalletNFTCollectionsOperation: PaginatedOperation<GetWalletNFTCollectionsRequest, GetWalletNFTCollectionsJSONRequest, GetWalletNFTCollectionsResponse, GetWalletNFTCollectionsJSONResponse['result']>;
declare function deserializeResponse$k(jsonResponse: GetWalletNFTCollectionsJSONResponse, request: GetWalletNFTCollectionsRequest, core: Core): EvmNftCollection[];
declare function serializeRequest$i(request: GetWalletNFTCollectionsRequest, core: Core): {
    chain: "0x1" | "0x5" | "0xaa36a7" | "0x89" | "0x13881" | "0x38" | "0x61" | "0xa86a" | "0xa869" | "0xfa" | "0x19" | "0x152" | "0x2a15c308d" | "0xa4B1";
    limit: number | undefined;
    cursor: string | undefined;
    address: string;
    disableTotal: boolean | undefined;
};

type OperationId$j = 'getWalletNFTs';
type PathParams$e = operations$1[OperationId$j]['parameters']['path'];
type QueryParams$g = operations$1[OperationId$j]['parameters']['query'];
type RequestParams$h = PathParams$e & QueryParams$g;
type SuccessResponse$j = operations$1[OperationId$j]['responses']['200']['content']['application/json'];
interface GetWalletNFTsRequest extends Camelize<Omit<RequestParams$h, 'chain' | 'token_addresses' | 'address'>> {
    chain?: EvmChainish;
    tokenAddresses?: EvmAddressish[];
    address: EvmAddressish;
}
type GetWalletNFTsJSONRequest = ReturnType<typeof serializeRequest$h>;
type GetWalletNFTsJSONResponse = SuccessResponse$j;
type GetWalletNFTsResponse = ReturnType<typeof deserializeResponse$j>;
interface GetWalletNFTsResponseAdapter extends PaginatedResponseAdapter<GetWalletNFTsResponse, GetWalletNFTsJSONResponse['result']> {
}
/**
 * Get NFTs owned by a given address.
 * * The response will include status [SYNCED/SYNCING] based on the contracts being indexed.
 * * Use the token_address param to get results for a specific contract only
 * * Note results will include all indexed NFTs
 * * Any request which includes the token_address param will start the indexing process for that NFT collection the very first time it is requested.
 */
declare const getWalletNFTsOperation: PaginatedOperation<GetWalletNFTsRequest, GetWalletNFTsJSONRequest, GetWalletNFTsResponse, GetWalletNFTsJSONResponse['result']>;
declare function deserializeResponse$j(jsonResponse: GetWalletNFTsJSONResponse, request: GetWalletNFTsRequest, core: Core): EvmNft[];
declare function serializeRequest$h(request: GetWalletNFTsRequest, core: Core): {
    chain: "0x1" | "0x5" | "0xaa36a7" | "0x89" | "0x13881" | "0x38" | "0x61" | "0xa86a" | "0xa869" | "0xfa" | "0x19" | "0x152" | "0x2a15c308d" | "0xa4B1";
    format: "decimal" | "hex" | undefined;
    limit: number | undefined;
    tokenAddresses: string[] | undefined;
    cursor: string | undefined;
    address: string;
    normalizeMetadata: boolean | undefined;
    disableTotal: boolean | undefined;
};

type OperationId$i = 'getWalletNFTTransfers';
type PathParams$d = operations$1[OperationId$i]['parameters']['path'];
type QueryParams$f = operations$1[OperationId$i]['parameters']['query'];
type RequestParams$g = PathParams$d & QueryParams$f;
type SuccessResponse$i = operations$1[OperationId$i]['responses']['200']['content']['application/json'];
interface GetWalletNFTTransfersRequest extends Camelize<Omit<RequestParams$g, 'chain' | 'address'>> {
    chain?: EvmChainish;
    address: EvmAddressish;
}
type GetWalletNFTTransfersJSONRequest = ReturnType<typeof serializeRequest$g>;
type GetWalletNFTTransfersJSONResponse = SuccessResponse$i;
type GetWalletNFTTransfersResponse = ReturnType<typeof deserializeResponse$i>;
interface GetWalletNFTTransfersResponseAdapter extends PaginatedResponseAdapter<GetWalletNFTTransfersResponse, GetWalletNFTTransfersJSONResponse['result']> {
}
/** Get transfers of NFTs given the wallet and other parameters. */
declare const getWalletNFTTransfersOperation: PaginatedOperation<GetWalletNFTTransfersRequest, GetWalletNFTTransfersJSONRequest, GetWalletNFTTransfersResponse, GetWalletNFTTransfersJSONResponse['result']>;
declare function deserializeResponse$i(jsonResponse: GetWalletNFTTransfersJSONResponse, request: GetWalletNFTTransfersRequest, core: Core): EvmNftTransfer[];
declare function serializeRequest$g(request: GetWalletNFTTransfersRequest, core: Core): {
    chain: "0x1" | "0x5" | "0xaa36a7" | "0x89" | "0x13881" | "0x38" | "0x61" | "0xa86a" | "0xa869" | "0xfa" | "0x19" | "0x152" | "0x2a15c308d" | "0xa4B1";
    format: "decimal" | "hex" | undefined;
    direction: "from" | "to" | "both" | undefined;
    fromBlock: number | undefined;
    toBlock: string | undefined;
    limit: number | undefined;
    cursor: string | undefined;
    address: string;
    disableTotal: boolean | undefined;
};

type OperationId$h = 'reSyncMetadata';
type PathParams$c = operations$1[OperationId$h]['parameters']['path'];
type QueryParams$e = operations$1[OperationId$h]['parameters']['query'];
type RequestParams$f = PathParams$c & QueryParams$e;
type SuccessResponse$h = operations$1[OperationId$h]['responses']['200']['content']['application/json'];
interface ReSyncMetadataRequest extends Camelize<Omit<RequestParams$f, 'chain' | 'address'>> {
    chain?: EvmChainish;
    address: EvmAddressish;
}
type ReSyncMetadataJSONRequest = ReturnType<typeof serializeRequest$f>;
type ReSyncMetadataJSONResponse = SuccessResponse$h;
type ReSyncMetadataResponse = ReturnType<typeof deserializeResponse$h>;
interface ReSyncMetadataResponseAdapter extends ResponseAdapter<ReSyncMetadataResponse, ReSyncMetadataJSONResponse> {
}
/**
 * ReSync the metadata for an NFT
 * * The metadata flag will request a the NFT's metadata from the already existing token_uri
 * * The uri(default) flag will fetch the latest token_uri from the given NFT address. In sync mode the metadata will also be fetched
 * * The sync mode will make the endpoint synchronous so it will wait for the task to be completed before responding
 * * The async mode(default) will make the endpoint asynchronous so we will wait for the task to be completed before responding
 */
declare const reSyncMetadataOperation: Operation<ReSyncMetadataRequest, ReSyncMetadataJSONRequest, ReSyncMetadataResponse, ReSyncMetadataJSONResponse>;
declare function serializeRequest$f(request: ReSyncMetadataRequest, core: Core): {
    chain: "0x1" | "0x5" | "0xaa36a7" | "0x89" | "0x13881" | "0x38" | "0x61" | "0xa86a" | "0xa869" | "0xfa" | "0x19" | "0x152" | "0x2a15c308d" | "0xa4B1";
    flag: "uri" | "metadata" | undefined;
    mode: "async" | "sync" | undefined;
    address: string;
    tokenId: string;
};
declare function deserializeResponse$h(jsonResponse: ReSyncMetadataJSONResponse): {
    status: string;
};

type OperationId$g = 'searchNFTs';
type QueryParams$d = operations$1[OperationId$g]['parameters']['query'];
type RequestParams$e = QueryParams$d;
type SuccessResponse$g = operations$1[OperationId$g]['responses']['200']['content']['application/json'];
interface SearchNFTsRequest extends Camelize<Omit<RequestParams$e, 'chain' | 'addresses' | 'from_date' | 'to_date'>> {
    chain?: EvmChainish;
    addresses?: EvmAddressish[];
    fromDate?: DateInput;
    toDate?: DateInput;
}
type SearchNFTsJSONRequest = ReturnType<typeof serializeRequest$e>;
type SearchNFTsJSONResponse = SuccessResponse$g;
type SearchNFTsResponse = ReturnType<typeof deserializeResponse$g>;
interface SearchNFTsResponseAdapter extends PaginatedResponseAdapter<SearchNFTsResponse, SearchNFTsJSONResponse['result']> {
}
/** Get NFTs that match a given metadata search query. */
declare const searchNFTsOperation: PaginatedOperation<SearchNFTsRequest, SearchNFTsJSONRequest, SearchNFTsResponse, SearchNFTsJSONResponse['result']>;
declare function deserializeResponse$g(jsonResponse: SearchNFTsJSONResponse, request: SearchNFTsRequest, core: Core): {
    token: EvmNft;
    tokenHash: string;
    blockNumberMinted: string;
    lastMetadataSync: Date | undefined;
    lastTokenUriSync: Date | undefined;
    batchId: string;
    frozen: number;
    frozenLogIndex: {
        [key: string]: unknown;
    } | undefined;
    imported: {
        [key: string]: unknown;
    } | undefined;
    isValid: number;
    openseaLookup: {
        [key: string]: unknown;
    } | undefined;
    resyncing: number;
    syncing: number;
    updatedAt: Date;
}[];
declare function serializeRequest$e(request: SearchNFTsRequest, core: Core): {
    chain: "0x1" | "0x5" | "0xaa36a7" | "0x89" | "0x13881" | "0x38" | "0x61" | "0xa86a" | "0xa869" | "0xfa" | "0x19" | "0x152" | "0x2a15c308d" | "0xa4B1";
    format: "decimal" | "hex" | undefined;
    q: string;
    filter: "name" | "description" | "attributes" | "global" | "name,description" | "name,attributes" | "description,attributes" | "name,description,attributes" | undefined;
    fromBlock: number | undefined;
    toBlock: number | undefined;
    fromDate: DateInput | undefined;
    toDate: DateInput | undefined;
    addresses: string[] | undefined;
    cursor: string | undefined;
    limit: number | undefined;
    disableTotal: boolean | undefined;
};

type OperationId$f = 'syncNFTContract';
type PathParams$b = operations$1[OperationId$f]['parameters']['path'];
type QueryParams$c = operations$1[OperationId$f]['parameters']['query'];
type RequestParams$d = PathParams$b & QueryParams$c;
type SuccessResponse$f = operations$1[OperationId$f]['responses']['201'];
interface SyncNFTContractRequest extends Camelize<Omit<RequestParams$d, 'chain' | 'address'>> {
    chain?: EvmChainish;
    address: EvmAddressish;
}
type SyncNFTContractJSONRequest = ReturnType<typeof serializeRequest$d>;
type SyncNFTContractJSONResponse = SuccessResponse$f;
type SyncNFTContractResponse = ReturnType<typeof deserializeResponse$f>;
interface SyncNFTContractResponseAdapter extends ResponseAdapter<SyncNFTContractResponse, SyncNFTContractJSONResponse> {
}
/** Initiates a sync of a previously non synced Contract. */
declare const syncNFTContractOperation: Operation<SyncNFTContractRequest, SyncNFTContractJSONRequest, SyncNFTContractResponse, SyncNFTContractJSONResponse>;
declare function deserializeResponse$f(): {
    success: boolean;
};
declare function serializeRequest$d(request: SyncNFTContractRequest, core: Core): {
    chain: "0x1" | "0x5" | "0xaa36a7" | "0x89" | "0x13881" | "0x38" | "0x61" | "0xa86a" | "0xa869" | "0xfa" | "0x19" | "0x152" | "0x2a15c308d" | "0xa4B1";
    address: string;
};

type OperationId$e = 'resolveAddress';
type PathParams$a = operations$1[OperationId$e]['parameters']['path'];
type RequestParams$c = PathParams$a;
type SuccessResponse$e = operations$1[OperationId$e]['responses']['200']['content']['application/json'];
interface ResolveAddressRequest extends Camelize<Omit<RequestParams$c, 'address'>> {
    address?: EvmAddressish;
}
type ResolveAddressJSONRequest = ReturnType<typeof serializeRequest$c>;
type ResolveAddressJSONResponse = SuccessResponse$e;
type ResolveAddressResponse = ReturnType<typeof deserializeResponse$e>;
interface ResolveAddressResponseAdapter extends ResponseAdapter<ResolveAddressResponse, ResolveAddressJSONResponse> {
}
/** Resolve an ETH address and find the ENS name. */
declare const resolveAddressOperation: Operation<ResolveAddressRequest, ResolveAddressJSONRequest, ResolveAddressResponse, ResolveAddressJSONResponse>;
declare function deserializeResponse$e(jsonResponse: ResolveAddressJSONResponse): {
    name: string;
};
declare function serializeRequest$c(request: ResolveAddressRequest, core: Core): {
    address: string | undefined;
};

type OperationId$d = 'resolveDomain';
type PathParams$9 = operations$1[OperationId$d]['parameters']['path'];
type QueryParams$b = operations$1[OperationId$d]['parameters']['query'];
type RequestParams$b = PathParams$9 & QueryParams$b;
type SuccessResponse$d = operations$1[OperationId$d]['responses']['200']['content']['application/json'];
interface ResolveDomainRequest extends Camelize<RequestParams$b> {
}
type ResolveDomainJSONRequest = ReturnType<typeof serializeRequest$b>;
type ResolveDomainJSONResponse = SuccessResponse$d;
type ResolveDomainResponse = ReturnType<typeof deserializeResponse$d>;
interface ResolveDomainResponseAdapter extends ResponseAdapter<ResolveDomainResponse, ResolveDomainJSONResponse> {
}
/** Resolve an Unstoppable domain and get the address. */
declare const resolveDomainOperation: Operation<ResolveDomainRequest, ResolveDomainJSONRequest, ResolveDomainResponse, ResolveDomainJSONResponse>;
declare function serializeRequest$b(request: ResolveDomainRequest): {
    currency: "eth" | "0x1" | undefined;
    domain: string;
};
declare function deserializeResponse$d(jsonResponse: ResolveDomainJSONResponse, request: ResolveDomainRequest, core: _moralisweb3_common_core__default): {
    address: EvmAddress;
};

type OperationId$c = 'getTransaction';
type PathParams$8 = operations$1[OperationId$c]['parameters']['path'];
type QueryParams$a = operations$1[OperationId$c]['parameters']['query'];
type RequestParams$a = PathParams$8 & QueryParams$a;
type SuccessResponse$c = operations$1[OperationId$c]['responses']['200']['content']['application/json'];
interface GetTransactionRequest extends Camelize<Omit<RequestParams$a, 'chain'>> {
    chain?: EvmChainish;
}
type GetTransactionJSONRequest = ReturnType<typeof serializeRequest$a>;
type GetTransactionJSONResponse = SuccessResponse$c;
type GetTransactionResponse = ReturnType<typeof deserializeResponse$c>;
interface GetTransactionResponseAdapter extends ResponseAdapter<GetTransactionResponse, GetTransactionJSONResponse> {
}
/** Get the contents of a transaction by the given transaction hash. */
declare const getTransactionOperation: Operation<GetTransactionRequest, GetTransactionJSONRequest, GetTransactionResponse, GetTransactionJSONResponse>;
declare function serializeRequest$a(request: GetTransactionRequest, core: Core): {
    chain: "0x1" | "0x5" | "0xaa36a7" | "0x89" | "0x13881" | "0x38" | "0x61" | "0xa86a" | "0xa869" | "0xfa" | "0x19" | "0x152" | "0x2a15c308d" | "0xa4B1";
    transactionHash: string;
};
declare function deserializeResponse$c(jsonResponse: GetTransactionJSONResponse, request: GetTransactionJSONRequest, core: Core): EvmTransaction;

type OperationId$b = 'getWalletTransactions';
type PathParams$7 = operations$1[OperationId$b]['parameters']['path'];
type QueryParams$9 = operations$1[OperationId$b]['parameters']['query'];
type RequestParams$9 = PathParams$7 & QueryParams$9;
type SuccessResponse$b = operations$1[OperationId$b]['responses']['200']['content']['application/json'];
interface GetWalletTransactionsRequest extends Camelize<Omit<RequestParams$9, 'chain' | 'address' | 'from_date' | 'to_date'>> {
    chain?: EvmChainish;
    address: EvmAddressish;
    fromDate?: DateInput;
    toDate?: DateInput;
}
type GetWalletTransactionsJSONRequest = ReturnType<typeof serializeRequest$9>;
type GetWalletTransactionsJSONResponse = SuccessResponse$b;
type GetWalletTransactionsResponse = ReturnType<typeof deserializeResponse$b>;
interface GetWalletTransactionsResponseAdapter extends PaginatedResponseAdapter<GetWalletTransactionsResponse, GetWalletTransactionsJSONResponse['result']> {
}
/** Get native transactions ordered by block number in descending order. */
declare const getWalletTransactionsOperation: PaginatedOperation<GetWalletTransactionsRequest, GetWalletTransactionsJSONRequest, GetWalletTransactionsResponse, GetWalletTransactionsJSONResponse['result']>;
declare function serializeRequest$9(request: GetWalletTransactionsRequest, core: Core): {
    chain: "0x1" | "0x5" | "0xaa36a7" | "0x89" | "0x13881" | "0x38" | "0x61" | "0xa86a" | "0xa869" | "0xfa" | "0x19" | "0x152" | "0x2a15c308d" | "0xa4B1";
    fromBlock: number | undefined;
    toBlock: number | undefined;
    fromDate: DateInput | undefined;
    toDate: DateInput | undefined;
    cursor: string | undefined;
    limit: number | undefined;
    address: string;
    disableTotal: boolean | undefined;
};
declare function deserializeResponse$b(jsonResponse: GetWalletTransactionsJSONResponse, request: GetWalletTransactionsJSONRequest, core: Core): EvmTransaction[];

type OperationId$a = 'getWalletTransactionsVerbose';
type PathParams$6 = operations$1[OperationId$a]['parameters']['path'];
type QueryParams$8 = operations$1[OperationId$a]['parameters']['query'];
type RequestParams$8 = PathParams$6 & QueryParams$8;
type SuccessResponse$a = operations$1[OperationId$a]['responses']['200']['content']['application/json'];
interface GetWalletTransactionsVerboseRequest extends Camelize<Omit<RequestParams$8, 'chain' | 'address' | 'from_date' | 'to_date'>> {
    chain?: EvmChainish;
    address: EvmAddressish;
    fromDate?: DateInput;
    toDate?: DateInput;
}
type GetWalletTransactionsVerboseJSONRequest = ReturnType<typeof serializeRequest$8>;
type GetWalletTransactionsVerboseJSONResponse = SuccessResponse$a;
type GetWalletTransactionsVerboseResponse = ReturnType<typeof deserializeResponse$a>;
interface GetWalletTransactionsVerboseResponseAdapter extends PaginatedResponseAdapter<GetWalletTransactionsVerboseResponse, GetWalletTransactionsVerboseJSONResponse['result']> {
}
/** Get native transactions ordered by block number in descending order. */
declare const getWalletTransactionsVerboseOperation: PaginatedOperation<GetWalletTransactionsVerboseRequest, GetWalletTransactionsVerboseJSONRequest, GetWalletTransactionsVerboseResponse, GetWalletTransactionsVerboseJSONResponse['result']>;
declare function serializeRequest$8(request: GetWalletTransactionsVerboseRequest, core: Core): {
    chain: "0x1" | "0x5" | "0xaa36a7" | "0x89" | "0x13881" | "0x38" | "0x61" | "0xa86a" | "0xa869" | "0xfa" | "0x19" | "0x152" | "0x2a15c308d" | "0xa4B1";
    fromBlock: number | undefined;
    toBlock: number | undefined;
    fromDate: DateInput | undefined;
    toDate: DateInput | undefined;
    cursor: string | undefined;
    limit: number | undefined;
    address: string;
    disableTotal: boolean | undefined;
};
declare function deserializeResponse$a(jsonResponse: GetWalletTransactionsVerboseJSONResponse, request: GetWalletTransactionsVerboseJSONRequest, core: Core): EvmTransaction[];

type OperationId$9 = 'getTokenAllowance';
type PathParams$5 = operations$1[OperationId$9]['parameters']['path'];
type QueryParams$7 = operations$1[OperationId$9]['parameters']['query'];
type RequestParams$7 = PathParams$5 & QueryParams$7;
type SuccessResponse$9 = operations$1[OperationId$9]['responses']['200']['content']['application/json'];
interface GetTokenAllowanceRequest extends Camelize<Omit<RequestParams$7, 'chain' | 'owner_address' | 'spender_address' | 'address'>> {
    chain?: EvmChainish;
    ownerAddress: EvmAddressish;
    spenderAddress: EvmAddressish;
    address: EvmAddressish;
}
type GetTokenAllowanceJSONRequest = ReturnType<typeof serializeRequest$7>;
type GetTokenAllowanceJSONResponse = SuccessResponse$9;
type GetTokenAllowanceResponse = ReturnType<typeof deserializeResponse$9>;
interface GetTokenAllowanceResponseAdapter extends ResponseAdapter<GetTokenAllowanceResponse, GetTokenAllowanceJSONResponse> {
}
/** Get the amount which the spender is allowed to withdraw on behalf of the owner. */
declare const getTokenAllowanceOperation: Operation<GetTokenAllowanceRequest, GetTokenAllowanceJSONRequest, GetTokenAllowanceResponse, GetTokenAllowanceJSONResponse>;
declare function deserializeResponse$9(jsonResponse: GetTokenAllowanceJSONResponse): {
    allowance: BigNumber;
};
declare function serializeRequest$7(request: GetTokenAllowanceRequest, core: Core): {
    chain: "0x1" | "0x5" | "0xaa36a7" | "0x89" | "0x13881" | "0x38" | "0x61" | "0xa86a" | "0xa869" | "0xfa" | "0x19" | "0x152" | "0x2a15c308d" | "0xa4B1";
    ownerAddress: string;
    spenderAddress: string;
    address: string;
};

type OperationId$8 = 'getTokenMetadata';
type QueryParams$6 = operations$1[OperationId$8]['parameters']['query'];
type RequestParams$6 = QueryParams$6;
type SuccessResponse$8 = operations$1[OperationId$8]['responses']['200']['content']['application/json'];
interface GetTokenMetadataRequest extends Camelize<Omit<RequestParams$6, 'chain' | 'addresses'>> {
    chain?: EvmChainish;
    addresses: EvmAddressish[];
}
type GetTokenMetadataJSONRequest = ReturnType<typeof serializeRequest$6>;
type GetTokenMetadataJSONResponse = SuccessResponse$8;
type GetTokenMetadataResponse = ReturnType<typeof deserializeResponse$8>;
interface GetTokenMetadataResponseAdapter extends ResponseAdapter<GetTokenMetadataResponse, GetTokenMetadataJSONResponse> {
}
/** Get the metadata for a given token contract address (name, symbol, decimals, logo). */
declare const getTokenMetadataOperation: Operation<GetTokenMetadataRequest, GetTokenMetadataJSONRequest, GetTokenMetadataResponse, GetTokenMetadataJSONResponse>;
declare function deserializeResponse$8(jsonResponse: GetTokenMetadataJSONResponse, request: GetTokenMetadataRequest, core: Core): {
    token: Erc20Token;
    blockNumber: string | undefined;
    validated: string | undefined;
}[];
declare function serializeRequest$6(request: GetTokenMetadataRequest, core: Core): {
    chain: "0x1" | "0x5" | "0xaa36a7" | "0x89" | "0x13881" | "0x38" | "0x61" | "0xa86a" | "0xa869" | "0xfa" | "0x19" | "0x152" | "0x2a15c308d" | "0xa4B1";
    addresses: string[];
};

type OperationId$7 = 'getTokenMetadataBySymbol';
type QueryParams$5 = operations$1[OperationId$7]['parameters']['query'];
type RequestParams$5 = QueryParams$5;
type SuccessResponse$7 = operations$1[OperationId$7]['responses']['200']['content']['application/json'];
interface GetTokenMetadataBySymbolRequest extends Camelize<Omit<RequestParams$5, 'chain'>> {
    chain?: EvmChainish;
}
type GetTokenMetadataBySymbolJSONRequest = ReturnType<typeof serializeRequest$5>;
type GetTokenMetadataBySymbolJSONResponse = SuccessResponse$7;
type GetTokenMetadataBySymbolResponse = ReturnType<typeof deserializeResponse$7>;
interface GetTokenMetadataBySymbolResponseAdapter extends ResponseAdapter<GetTokenMetadataBySymbolResponse, GetTokenMetadataBySymbolJSONResponse> {
}
/** Get metadata for a list of token symbols (name, symbol, decimals, logo). */
declare const getTokenMetadataBySymbolOperation: Operation<GetTokenMetadataBySymbolRequest, GetTokenMetadataBySymbolJSONRequest, GetTokenMetadataBySymbolResponse, GetTokenMetadataBySymbolJSONResponse>;
declare function deserializeResponse$7(jsonResponse: GetTokenMetadataBySymbolJSONResponse, request: GetTokenMetadataBySymbolRequest, core: Core): {
    token: Erc20Token;
    blockNumber: string | undefined;
    validated: string | undefined;
}[];
declare function serializeRequest$5(request: GetTokenMetadataBySymbolRequest, core: Core): {
    chain: "0x1" | "0x5" | "0xaa36a7" | "0x89" | "0x13881" | "0x38" | "0x61" | "0xa86a" | "0xa869" | "0xfa" | "0x19" | "0x152" | "0x2a15c308d" | "0xa4B1";
    symbols: string[];
};

type OperationId$6 = 'getTokenPrice';
type PathParams$4 = operations$1[OperationId$6]['parameters']['path'];
type QueryParams$4 = operations$1[OperationId$6]['parameters']['query'];
type RequestParams$4 = PathParams$4 & QueryParams$4;
type SuccessResponse$6 = operations$1[OperationId$6]['responses']['200']['content']['application/json'];
interface GetTokenPriceRequest extends Camelize<Omit<RequestParams$4, 'chain' | 'address'>> {
    chain?: EvmChainish;
    address: EvmAddressish;
}
type GetTokenPriceJSONRequest = ReturnType<typeof serializeRequest$4>;
type GetTokenPriceJSONResponse = SuccessResponse$6;
type GetTokenPriceResponse = ReturnType<typeof deserializeResponse$6>;
interface GetTokenPriceResponseAdapter extends ResponseAdapter<GetTokenPriceResponse, GetTokenPriceJSONResponse> {
}
/** Get the token price denominated in the blockchains native token and USD. */
declare const getTokenPriceOperation: Operation<GetTokenPriceRequest, GetTokenPriceJSONRequest, GetTokenPriceResponse, GetTokenPriceJSONResponse>;
declare function deserializeResponse$6(jsonResponse: GetTokenPriceJSONResponse, request: GetTokenPriceRequest, core: Core): {
    nativePrice: EvmNative | null;
    exchangeAddress: EvmAddress | null;
    usdPrice: number;
    exchangeName?: string | undefined;
};
declare function serializeRequest$4(request: GetTokenPriceRequest, core: Core): {
    chain: "0x1" | "0x5" | "0xaa36a7" | "0x89" | "0x13881" | "0x38" | "0x61" | "0xa86a" | "0xa869" | "0xfa" | "0x19" | "0x152" | "0x2a15c308d" | "0xa4B1";
    exchange: string | undefined;
    toBlock: number | undefined;
    address: string;
};

type OperationId$5 = 'getTokenTransfers';
type PathParams$3 = operations$1[OperationId$5]['parameters']['path'];
type QueryParams$3 = operations$1[OperationId$5]['parameters']['query'];
type RequestParams$3 = PathParams$3 & QueryParams$3;
type SuccessResponse$5 = operations$1[OperationId$5]['responses']['200']['content']['application/json'];
interface GetTokenTransfersRequest extends Camelize<Omit<RequestParams$3, 'chain' | 'address' | 'from_date' | 'to_date'>> {
    chain?: EvmChainish;
    address: EvmAddressish;
    fromDate?: DateInput;
    toDate?: DateInput;
}
type GetTokenTransfersJSONRequest = ReturnType<typeof serializeRequest$3>;
type GetTokenTransfersJSONResponse = SuccessResponse$5;
type GetTokenTransfersResponse = ReturnType<typeof deserializeResponse$5>;
interface GetTokenTransfersResponseAdapter extends PaginatedResponseAdapter<GetTokenTransfersResponse, GetTokenTransfersJSONResponse['result']> {
}
/** Get ERC20 token transactions from a contract ordered by block number in descending order. */
declare const getTokenTransfersOperation: PaginatedOperation<GetTokenTransfersRequest, GetTokenTransfersJSONRequest, GetTokenTransfersResponse, GetTokenTransfersJSONResponse['result']>;
declare function deserializeResponse$5(jsonResponse: GetTokenTransfersJSONResponse, request: GetTokenTransfersRequest, core: Core): Erc20Transfer[];
declare function serializeRequest$3(request: GetTokenTransfersRequest, core: Core): {
    chain: "0x1" | "0x5" | "0xaa36a7" | "0x89" | "0x13881" | "0x38" | "0x61" | "0xa86a" | "0xa869" | "0xfa" | "0x19" | "0x152" | "0x2a15c308d" | "0xa4B1";
    fromBlock: number | undefined;
    toBlock: number | undefined;
    fromDate: DateInput | undefined;
    toDate: DateInput | undefined;
    limit: number | undefined;
    address: string;
    cursor: string | undefined;
    disableTotal: boolean | undefined;
};

type OperationId$4 = 'getWalletTokenBalances';
type PathParams$2 = operations$1[OperationId$4]['parameters']['path'];
type QueryParams$2 = operations$1[OperationId$4]['parameters']['query'];
type RequestParams$2 = PathParams$2 & QueryParams$2;
type SuccessResponse$4 = operations$1[OperationId$4]['responses']['200']['content']['application/json'];
interface GetWalletTokenBalancesRequest extends Camelize<Omit<RequestParams$2, 'chain' | 'token_addresses' | 'address'>> {
    chain?: EvmChainish;
    tokenAddresses?: EvmAddressish[];
    address: EvmAddressish;
}
type GetWalletTokenBalancesJSONRequest = ReturnType<typeof serializeRequest$2>;
type GetWalletTokenBalancesJSONResponse = SuccessResponse$4;
type GetWalletTokenBalancesResponse = ReturnType<typeof deserializeResponse$4>;
interface GetWalletTokenBalancesResponseAdapter extends ResponseAdapter<GetWalletTokenBalancesResponse, GetWalletTokenBalancesJSONResponse> {
}
/** Get token balances for a specific wallet address. */
declare const getWalletTokenBalancesOperation: Operation<GetWalletTokenBalancesRequest, GetWalletTokenBalancesJSONRequest, GetWalletTokenBalancesResponse, GetWalletTokenBalancesJSONResponse>;
declare function deserializeResponse$4(jsonResponse: GetWalletTokenBalancesJSONResponse, request: GetWalletTokenBalancesRequest, core: Core): Erc20Value[];
declare function serializeRequest$2(request: GetWalletTokenBalancesRequest, core: Core): {
    chain: "0x1" | "0x5" | "0xaa36a7" | "0x89" | "0x13881" | "0x38" | "0x61" | "0xa86a" | "0xa869" | "0xfa" | "0x19" | "0x152" | "0x2a15c308d" | "0xa4B1";
    tokenAddresses: string[] | undefined;
    address: string;
    toBlock: number | undefined;
};

type OperationId$3 = 'getWalletTokenTransfers';
type PathParams$1 = operations$1[OperationId$3]['parameters']['path'];
type QueryParams$1 = operations$1[OperationId$3]['parameters']['query'];
type RequestParams$1 = PathParams$1 & QueryParams$1;
type SuccessResponse$3 = operations$1[OperationId$3]['responses']['200']['content']['application/json'];
interface GetWalletTokenTransfersRequest extends Camelize<Omit<RequestParams$1, 'chain' | 'address' | 'from_date' | 'to_date'>> {
    chain?: EvmChainish;
    address: EvmAddressish;
    fromDate?: DateInput;
    toDate?: DateInput;
}
type GetWalletTokenTransfersJSONRequest = ReturnType<typeof serializeRequest$1>;
type GetWalletTokenTransfersJSONResponse = SuccessResponse$3;
type GetWalletTokenTransfersResponse = ReturnType<typeof deserializeResponse$3>;
interface GetWalletTokenTransfersResponseAdapter extends PaginatedResponseAdapter<GetWalletTokenTransfersResponse, GetWalletTokenTransfersJSONResponse['result']> {
}
/** Get ERC20 token transactions ordered by block number in descending order. */
declare const getWalletTokenTransfersOperation: PaginatedOperation<GetWalletTokenTransfersRequest, GetWalletTokenTransfersJSONRequest, GetWalletTokenTransfersResponse, GetWalletTokenTransfersJSONResponse['result']>;
declare function deserializeResponse$3(jsonResponse: GetWalletTokenTransfersJSONResponse, request: GetWalletTokenTransfersRequest, core: Core): Erc20Transfer[];
declare function serializeRequest$1(request: GetWalletTokenTransfersRequest, core: Core): {
    chain: "0x1" | "0x5" | "0xaa36a7" | "0x89" | "0x13881" | "0x38" | "0x61" | "0xa86a" | "0xa869" | "0xfa" | "0x19" | "0x152" | "0x2a15c308d" | "0xa4B1";
    address: string;
    fromBlock: number | undefined;
    toBlock: number | undefined;
    fromDate: DateInput | undefined;
    toDate: DateInput | undefined;
    limit: number | undefined;
    cursor: string | undefined;
    disableTotal: boolean | undefined;
};

type OperationId$2 = 'runContractFunction';
type PathParams = operations$1[OperationId$2]['parameters']['path'];
type QueryParams = operations$1[OperationId$2]['parameters']['query'];
type BodyParams = operations$1[OperationId$2]['requestBody']['content']['application/json'];
type RequestParams = PathParams & QueryParams & BodyParams;
type SuccessResponse$2 = operations$1[OperationId$2]['responses']['200']['content']['application/json'];
interface RunContractFunctionRequest extends Camelize<Omit<RequestParams, 'chain' | 'address' | 'abi'>> {
    chain?: EvmChainish;
    address: EvmAddressish;
    abi: unknown;
}
type RunContractFunctionJSONRequest = ReturnType<typeof serializeRequest>;
type RunContractFunctionJSONResponse = SuccessResponse$2;
type RunContractFunctionResponse = ReturnType<typeof deserializeResponse$2>;
interface RunContractFunctionResponseAdapter extends ResponseAdapter<RunContractFunctionResponse, RunContractFunctionJSONResponse> {
}
/** Run a given function of a contract ABI and retrieve readonly data. */
declare const runContractFunctionOperation: Operation<RunContractFunctionRequest, RunContractFunctionJSONRequest, RunContractFunctionResponse, RunContractFunctionJSONResponse>;
declare function deserializeResponse$2(jsonResponse: RunContractFunctionJSONResponse): string;
declare function serializeRequest(request: RunContractFunctionRequest, core: Core): {
    address: string;
    chain: "0x1" | "0x5" | "0xaa36a7" | "0x89" | "0x13881" | "0x38" | "0x61" | "0xa86a" | "0xa869" | "0xfa" | "0x19" | "0x152" | "0x2a15c308d" | "0xa4B1";
    functionName: string;
    abi: unknown;
    params: {
        [key: string]: unknown;
    } | undefined;
};

type OperationId$1 = 'endpointWeights';
type SuccessResponse$1 = operations$1[OperationId$1]['responses']['200']['content']['application/json'];
interface EndpointWeightsRequest {
}
type EndpointWeightsJSONRequest = undefined;
type EndpointWeightsJSONResponse = SuccessResponse$1;
type EndpointWeightsResponse = ReturnType<typeof deserializeResponse$1>;
interface EndpointWeightsResponseAdapter extends ResponseAdapter<EndpointWeightsResponse, EndpointWeightsJSONResponse> {
}
/** Get the endpoint price list for rate limits and cost. */
declare const endpointWeightsOperation: Operation<EndpointWeightsRequest, EndpointWeightsJSONRequest, EndpointWeightsResponse, EndpointWeightsJSONResponse>;
declare function deserializeResponse$1(jsonResponse: EndpointWeightsJSONResponse): {
    endpoint: string;
    path: string;
    rateLimitCost: string;
    price: string;
}[];

type OperationId = 'web3ApiVersion';
type SuccessResponse = operations$1[OperationId]['responses']['200']['content']['application/json'];
interface Web3ApiVersionRequest {
}
type Web3ApiVersionJSONRequest = undefined;
type Web3ApiVersionJSONResponse = SuccessResponse;
type Web3ApiVersionResponse = ReturnType<typeof deserializeResponse>;
interface Web3ApiVersionResponseAdapter extends ResponseAdapter<Web3ApiVersionResponse, Web3ApiVersionJSONResponse> {
}
/** Get the current version of the Moralis Web3 API. */
declare const web3ApiVersionOperation: Operation<Web3ApiVersionRequest, Web3ApiVersionJSONRequest, Web3ApiVersionResponse, Web3ApiVersionJSONResponse>;
declare function deserializeResponse(jsonResponse: Web3ApiVersionJSONResponse): {
    version: string;
};

declare const operations: (_moralisweb3_common_core.Operation<EndpointWeightsRequest, undefined, {
    endpoint: string;
    path: string;
    rateLimitCost: string;
    price: string;
}[], {
    endpoint: string;
    path: string;
    rateLimitCost: string;
    price: string;
}[]> | _moralisweb3_common_core.Operation<GetBlockRequest, {
    chain: "0x1" | "0x5" | "0xaa36a7" | "0x89" | "0x13881" | "0x38" | "0x61" | "0xa86a" | "0xa869" | "0xfa" | "0x19" | "0x152" | "0x2a15c308d" | "0xa4B1";
    blockNumberOrHash: string;
}, EvmBlock, {
    timestamp: string;
    number: string;
    hash: string;
    parent_hash: string;
    nonce: string;
    sha3_uncles: string;
    logs_bloom: string;
    transactions_root: string;
    state_root: string;
    receipts_root: string;
    miner: string;
    difficulty: string;
    total_difficulty: string;
    size: string;
    extra_data: string;
    gas_limit: string;
    gas_used: string;
    transaction_count: string;
    transactions: {
        hash: string;
        nonce: string;
        transaction_index: string;
        from_address: string;
        to_address: unknown;
        value: string;
        gas?: string | undefined;
        gas_price: string;
        input: string;
        receipt_cumulative_gas_used: string;
        receipt_gas_used: string;
        receipt_contract_address?: unknown;
        receipt_root?: unknown;
        receipt_status: string;
        block_timestamp: string;
        block_number: string;
        block_hash: string;
        logs?: {
            log_index: string;
            transaction_hash: string;
            transaction_index: string;
            address: string;
            data: string;
            topic0: string;
            topic1?: unknown;
            topic2?: unknown;
            topic3?: unknown;
            block_timestamp: string;
            block_number: string;
            block_hash: string;
        }[] | undefined;
    }[];
}> | _moralisweb3_common_core.PaginatedOperation<GetContractEventsRequest, {
    chain: "0x1" | "0x5" | "0xaa36a7" | "0x89" | "0x13881" | "0x38" | "0x61" | "0xa86a" | "0xa869" | "0xfa" | "0x19" | "0x152" | "0x2a15c308d" | "0xa4B1";
    fromBlock: number | undefined;
    toBlock: number | undefined;
    fromDate: string | undefined;
    toDate: string | undefined;
    topic: string;
    offset: number | undefined;
    limit: number | undefined;
    address: string;
    abi: EvmAbiItem;
    disableTotal: boolean | undefined;
}, EvmEvent[], {
    transaction_hash: string;
    address: string;
    block_timestamp: string;
    block_number: string;
    block_hash: string;
    data: {
        from?: string | undefined;
        to?: string | undefined;
        value?: string | undefined;
    };
}[] | undefined> | _moralisweb3_common_core.PaginatedOperation<GetContractLogsRequest, {
    chain: "0x1" | "0x5" | "0xaa36a7" | "0x89" | "0x13881" | "0x38" | "0x61" | "0xa86a" | "0xa869" | "0xfa" | "0x19" | "0x152" | "0x2a15c308d" | "0xa4B1";
    blockNumber: string | undefined;
    fromBlock: string | undefined;
    toBlock: string | undefined;
    fromDate: string | undefined;
    toDate: string | undefined;
    topic0: string | undefined;
    topic1: string | undefined;
    topic2: string | undefined;
    topic3: string | undefined;
    limit: number | undefined;
    cursor: string | undefined;
    address: string;
    disableTotal: boolean | undefined;
}, EvmTransactionLog[], {
    transaction_hash: string;
    address: string;
    block_timestamp: string;
    block_number: string;
    block_hash: string;
    data: string;
    topic0: string;
    topic1: string;
    topic2: string;
    topic3: string;
    transaction_index: number;
    log_index: number;
}[] | undefined> | _moralisweb3_common_core.PaginatedOperation<GetContractNFTsRequest, {
    chain: "0x1" | "0x5" | "0xaa36a7" | "0x89" | "0x13881" | "0x38" | "0x61" | "0xa86a" | "0xa869" | "0xfa" | "0x19" | "0x152" | "0x2a15c308d" | "0xa4B1";
    format: "decimal" | "hex" | undefined;
    limit: number | undefined;
    totalRanges: number | undefined;
    range: number | undefined;
    cursor: string | undefined;
    address: string;
    normalizeMetadata: boolean | undefined;
    disableTotal: boolean | undefined;
}, EvmNft[], {
    token_address: string;
    token_id: string;
    owner_of?: string | undefined;
    token_hash?: string | undefined;
    block_number?: string | undefined;
    block_number_minted?: string | undefined;
    contract_type: string;
    token_uri?: string | undefined;
    metadata?: string | undefined;
    normalized_metadata?: {
        name?: string | undefined;
        description?: string | undefined;
        image?: string | undefined;
        external_link?: string | undefined;
        animation_url?: string | undefined;
        attributes?: {
            trait_type?: string | undefined;
            value?: {
                [key: string]: unknown;
            } | undefined;
            display_type?: string | undefined;
            max_value?: number | undefined;
            trait_count?: number | undefined;
            order?: number | undefined;
        }[] | undefined;
    } | undefined;
    minter_address?: string | undefined;
    last_token_uri_sync?: string | undefined;
    last_metadata_sync?: string | undefined;
    amount?: string | undefined;
    name: string;
    symbol: string;
}[] | undefined> | _moralisweb3_common_core.Operation<GetDateToBlockRequest, {
    chain: "0x1" | "0x5" | "0xaa36a7" | "0x89" | "0x13881" | "0x38" | "0x61" | "0xa86a" | "0xa869" | "0xfa" | "0x19" | "0x152" | "0x2a15c308d" | "0xa4B1";
    date: string;
}, EvmBlockDate, {
    date: string;
    block: number;
    timestamp: number;
    block_timestamp?: string | undefined;
    hash?: string | undefined;
    parent_hash?: string | undefined;
}> | _moralisweb3_common_core.Operation<GetMultipleNFTsRequest, {
    chain: "0x1" | "0x5" | "0xaa36a7" | "0x89" | "0x13881" | "0x38" | "0x61" | "0xa86a" | "0xa869" | "0xfa" | "0x19" | "0x152" | "0x2a15c308d" | "0xa4B1";
    normalizeMetadata: boolean | undefined;
    tokens: {
        tokenAddress: string;
        tokenId: string;
    }[];
}, (EvmNft | null)[], ({
    token_address: string;
    token_id: string;
    contract_type: string;
    owner_of: string;
    block_number: string;
    block_number_minted: string;
    token_uri?: string | undefined;
    metadata?: string | undefined;
    normalized_metadata?: {
        name?: string | undefined;
        description?: string | undefined;
        image?: string | undefined;
        external_link?: string | undefined;
        animation_url?: string | undefined;
        attributes?: {
            trait_type?: string | undefined;
            value?: {
                [key: string]: unknown;
            } | undefined;
            display_type?: string | undefined;
            max_value?: number | undefined;
            trait_count?: number | undefined;
            order?: number | undefined;
        }[] | undefined;
    } | undefined;
    amount?: string | undefined;
    name: string;
    symbol: string;
    token_hash: string;
    last_token_uri_sync: string;
    last_metadata_sync: string;
} | null)[]> | _moralisweb3_common_core.Operation<GetNativeBalanceRequest, {
    chain: "0x1" | "0x5" | "0xaa36a7" | "0x89" | "0x13881" | "0x38" | "0x61" | "0xa86a" | "0xa869" | "0xfa" | "0x19" | "0x152" | "0x2a15c308d" | "0xa4B1";
    toBlock: number | undefined;
    address: string;
}, {
    balance: EvmNative;
}, {
    balance: string;
}> | _moralisweb3_common_core.Operation<GetNativeBalancesForAddressesRequest, {
    chain: "0x1" | "0x5" | "0xaa36a7" | "0x89" | "0x13881" | "0x38" | "0x61" | "0xa86a" | "0xa869" | "0xfa" | "0x19" | "0x152" | "0x2a15c308d" | "0xa4B1";
    providerUrl: string | undefined;
    toBlock: number | undefined;
    walletAddresses: string[];
}, {
    chain: EvmChain;
    blockNumber: string;
    blockTimestamp: string;
    totalBalance: EvmNative;
    walletBalances: {
        address: EvmAddress;
        balance: EvmNative;
    }[];
}[], {
    chain: string;
    chain_id: string;
    total_balance: string;
    block_number: string;
    block_timestamp: string;
    total_balance_formatted: string;
    wallet_balances: {
        address: string;
        balance: string;
        balance_formatted: string;
    }[];
}[]> | _moralisweb3_common_core.Operation<GetNFTContractMetadataRequest, {
    chain: "0x1" | "0x5" | "0xaa36a7" | "0x89" | "0x13881" | "0x38" | "0x61" | "0xa86a" | "0xa869" | "0xfa" | "0x19" | "0x152" | "0x2a15c308d" | "0xa4B1";
    address: string;
}, EvmNftMetadata, {
    token_address: string;
    name: string;
    synced_at?: string | undefined;
    symbol: string;
    contract_type: string;
}> | _moralisweb3_common_core.PaginatedOperation<GetNFTContractTransfersRequest, {
    chain: "0x1" | "0x5" | "0xaa36a7" | "0x89" | "0x13881" | "0x38" | "0x61" | "0xa86a" | "0xa869" | "0xfa" | "0x19" | "0x152" | "0x2a15c308d" | "0xa4B1";
    format: "decimal" | "hex" | undefined;
    limit: number | undefined;
    cursor: string | undefined;
    address: string;
    fromBlock: number | undefined;
    toBlock: number | undefined;
    fromDate: string | undefined;
    toDate: string | undefined;
    disableTotal: boolean | undefined;
}, EvmNftTransfer[], {
    token_address: string;
    token_id: string;
    from_address?: string | undefined;
    to_address: string;
    value?: string | undefined;
    amount?: string | undefined;
    contract_type: string;
    block_number: string;
    block_timestamp: string;
    block_hash: string;
    transaction_hash: string;
    transaction_type?: string | undefined;
    transaction_index?: number | undefined;
    log_index: number;
    operator?: string | undefined;
}[]> | _moralisweb3_common_core.Operation<GetNFTLowestPriceRequest, {
    chain: "0x1" | "0x5" | "0xaa36a7" | "0x89" | "0x13881" | "0x38" | "0x61" | "0xa86a" | "0xa869" | "0xfa" | "0x19" | "0x152" | "0x2a15c308d" | "0xa4B1";
    days: number | undefined;
    marketplace: "opensea" | undefined;
    address: string;
}, EvmNftTrade, {
    transaction_hash: string;
    transaction_index: string;
    token_ids: string[];
    seller_address: string;
    buyer_address: string;
    marketplace_address: string;
    price: string;
    block_timestamp: string;
    block_number: string;
    block_hash: string;
} & {
    token_address: unknown;
}> | _moralisweb3_common_core.Operation<GetNFTMetadataRequest, {
    chain: "0x1" | "0x5" | "0xaa36a7" | "0x89" | "0x13881" | "0x38" | "0x61" | "0xa86a" | "0xa869" | "0xfa" | "0x19" | "0x152" | "0x2a15c308d" | "0xa4B1";
    format: "decimal" | "hex" | undefined;
    address: string;
    tokenId: string;
    normalizeMetadata: boolean | undefined;
}, EvmNft, {
    token_address: string;
    token_id: string;
    owner_of?: string | undefined;
    token_hash?: string | undefined;
    block_number?: string | undefined;
    block_number_minted?: string | undefined;
    contract_type: string;
    token_uri?: string | undefined;
    metadata?: string | undefined;
    normalized_metadata?: {
        name?: string | undefined;
        description?: string | undefined;
        image?: string | undefined;
        external_link?: string | undefined;
        animation_url?: string | undefined;
        attributes?: {
            trait_type?: string | undefined;
            value?: {
                [key: string]: unknown;
            } | undefined;
            display_type?: string | undefined;
            max_value?: number | undefined;
            trait_count?: number | undefined;
            order?: number | undefined;
        }[] | undefined;
    } | undefined;
    minter_address?: string | undefined;
    last_token_uri_sync?: string | undefined;
    last_metadata_sync?: string | undefined;
    amount?: string | undefined;
    name: string;
    symbol: string;
}> | _moralisweb3_common_core.PaginatedOperation<GetNFTOwnersRequest, {
    chain: "0x1" | "0x5" | "0xaa36a7" | "0x89" | "0x13881" | "0x38" | "0x61" | "0xa86a" | "0xa869" | "0xfa" | "0x19" | "0x152" | "0x2a15c308d" | "0xa4B1";
    format: "decimal" | "hex" | undefined;
    limit: number | undefined;
    cursor: string | undefined;
    address: string;
    normalizeMetadata: boolean | undefined;
    disableTotal: boolean | undefined;
}, EvmNft[], {
    token_address: string;
    token_id: string;
    contract_type: string;
    owner_of: string;
    block_number: string;
    block_number_minted: string;
    token_uri?: string | undefined;
    metadata?: string | undefined;
    normalized_metadata?: {
        name?: string | undefined;
        description?: string | undefined;
        image?: string | undefined;
        external_link?: string | undefined;
        animation_url?: string | undefined;
        attributes?: {
            trait_type?: string | undefined;
            value?: {
                [key: string]: unknown;
            } | undefined;
            display_type?: string | undefined;
            max_value?: number | undefined;
            trait_count?: number | undefined;
            order?: number | undefined;
        }[] | undefined;
    } | undefined;
    amount?: string | undefined;
    name: string;
    symbol: string;
    token_hash: string;
    last_token_uri_sync: string;
    last_metadata_sync: string;
}[] | undefined> | _moralisweb3_common_core.PaginatedOperation<GetNFTTokenIdOwnersRequest, {
    chain: "0x1" | "0x5" | "0xaa36a7" | "0x89" | "0x13881" | "0x38" | "0x61" | "0xa86a" | "0xa869" | "0xfa" | "0x19" | "0x152" | "0x2a15c308d" | "0xa4B1";
    format: "decimal" | "hex" | undefined;
    limit: number | undefined;
    cursor: string | undefined;
    address: string;
    tokenId: string;
    normalizeMetadata: boolean | undefined;
    disableTotal: boolean | undefined;
}, EvmNft[], {
    token_address: string;
    token_id: string;
    contract_type: string;
    owner_of: string;
    block_number: string;
    block_number_minted: string;
    token_uri?: string | undefined;
    metadata?: string | undefined;
    normalized_metadata?: {
        name?: string | undefined;
        description?: string | undefined;
        image?: string | undefined;
        external_link?: string | undefined;
        animation_url?: string | undefined;
        attributes?: {
            trait_type?: string | undefined;
            value?: {
                [key: string]: unknown;
            } | undefined;
            display_type?: string | undefined;
            max_value?: number | undefined;
            trait_count?: number | undefined;
            order?: number | undefined;
        }[] | undefined;
    } | undefined;
    amount?: string | undefined;
    name: string;
    symbol: string;
    token_hash: string;
    last_token_uri_sync: string;
    last_metadata_sync: string;
}[] | undefined> | _moralisweb3_common_core.PaginatedOperation<GetNFTTradesRequest, {
    chain: "0x1" | "0x5" | "0xaa36a7" | "0x89" | "0x13881" | "0x38" | "0x61" | "0xa86a" | "0xa869" | "0xfa" | "0x19" | "0x152" | "0x2a15c308d" | "0xa4B1";
    fromBlock: number | undefined;
    toBlock: string | undefined;
    fromDate: _moralisweb3_common_core.DateInput | undefined;
    toDate: _moralisweb3_common_core.DateInput | undefined;
    marketplace: "opensea" | undefined;
    cursor: string | undefined;
    limit: number | undefined;
    address: string;
    disableTotal: boolean | undefined;
}, EvmNftTrade[], ({
    transaction_hash: string;
    transaction_index: string;
    token_ids: string[];
    seller_address: string;
    buyer_address: string;
    marketplace_address: string;
    price: string;
    block_timestamp: string;
    block_number: string;
    block_hash: string;
} & {
    token_address: unknown;
})[] | undefined> | _moralisweb3_common_core.PaginatedOperation<GetNFTTransfersByBlockRequest, {
    chain: "0x1" | "0x5" | "0xaa36a7" | "0x89" | "0x13881" | "0x38" | "0x61" | "0xa86a" | "0xa869" | "0xfa" | "0x19" | "0x152" | "0x2a15c308d" | "0xa4B1";
    limit: number | undefined;
    cursor: string | undefined;
    blockNumberOrHash: string;
    disableTotal: boolean | undefined;
}, EvmNftTransfer[], {
    token_address: string;
    token_id: string;
    from_address?: string | undefined;
    to_address: string;
    value?: string | undefined;
    amount?: string | undefined;
    contract_type: string;
    block_number: string;
    block_timestamp: string;
    block_hash: string;
    transaction_hash: string;
    transaction_type?: string | undefined;
    transaction_index?: number | undefined;
    log_index: number;
    operator?: string | undefined;
}[]> | _moralisweb3_common_core.PaginatedOperation<GetNFTTransfersFromToBlockRequest, {
    chain: "0x1" | "0x5" | "0xaa36a7" | "0x89" | "0x13881" | "0x38" | "0x61" | "0xa86a" | "0xa869" | "0xfa" | "0x19" | "0x152" | "0x2a15c308d" | "0xa4B1";
    fromBlock: number | undefined;
    toBlock: number | undefined;
    fromDate: _moralisweb3_common_core.DateInput | undefined;
    toDate: _moralisweb3_common_core.DateInput | undefined;
    format: "decimal" | "hex" | undefined;
    limit: number | undefined;
    cursor: string | undefined;
    disableTotal: boolean | undefined;
}, EvmNftTransfer[], {
    token_address: string;
    token_id: string;
    from_address?: string | undefined;
    to_address: string;
    value?: string | undefined;
    amount?: string | undefined;
    contract_type: string;
    block_number: string;
    block_timestamp: string;
    block_hash: string;
    transaction_hash: string;
    transaction_type?: string | undefined;
    transaction_index?: number | undefined;
    log_index: number;
    operator?: string | undefined;
}[]> | _moralisweb3_common_core.PaginatedOperation<GetNFTTransfersRequest, {
    chain: "0x1" | "0x5" | "0xaa36a7" | "0x89" | "0x13881" | "0x38" | "0x61" | "0xa86a" | "0xa869" | "0xfa" | "0x19" | "0x152" | "0x2a15c308d" | "0xa4B1";
    format: "decimal" | "hex" | undefined;
    limit: number | undefined;
    cursor: string | undefined;
    address: string;
    tokenId: string;
    disableTotal: boolean | undefined;
}, EvmNftTransfer[], {
    token_address: string;
    token_id: string;
    from_address?: string | undefined;
    to_address: string;
    value?: string | undefined;
    amount?: string | undefined;
    contract_type: string;
    block_number: string;
    block_timestamp: string;
    block_hash: string;
    transaction_hash: string;
    transaction_type?: string | undefined;
    transaction_index?: number | undefined;
    log_index: number;
    operator?: string | undefined;
}[]> | _moralisweb3_common_core.Operation<GetPairAddressRequest, {
    chain: "0x1" | "0x5" | "0xaa36a7" | "0x89" | "0x13881" | "0x38" | "0x61" | "0xa86a" | "0xa869" | "0xfa" | "0x19" | "0x152" | "0x2a15c308d" | "0xa4B1";
    toBlock: string | undefined;
    toDate: string | undefined;
    exchange: _moralisweb3_common_core.Camelize<"uniswapv2" | "uniswapv3" | "sushiswapv2" | "pancakeswapv2" | "pancakeswapv1" | "quickswap">;
    token0Address: string;
    token1Address: string;
}, {
    token0: {
        token: Erc20Token;
        blockNumber: string | undefined;
        validated: number | undefined;
        createdAt: Date | undefined;
    };
    token1: {
        token: Erc20Token;
        blockNumber: string | undefined;
        validated: number | undefined;
        createdAt: Date | undefined;
    };
    pairAddress: EvmAddress | undefined;
}, {
    token0?: {
        address?: string | undefined;
        name?: string | undefined;
        symbol?: string | undefined;
        decimals?: string | undefined;
        logo?: string | undefined;
        logo_hash?: string | undefined;
        thumbnail?: string | undefined;
        block_number?: string | undefined;
        validated?: number | undefined;
        created_at?: string | undefined;
    } | undefined;
    token1?: {
        address?: string | undefined;
        name?: string | undefined;
        symbol?: string | undefined;
        decimals?: string | undefined;
        logo?: string | undefined;
        logo_hash?: string | undefined;
        thumbnail?: string | undefined;
        block_number?: string | undefined;
        validated?: number | undefined;
        created_at?: string | undefined;
    } | undefined;
    pairAddress?: string | undefined;
}> | _moralisweb3_common_core.Operation<GetPairReservesRequest, {
    chain: "0x1" | "0x5" | "0xaa36a7" | "0x89" | "0x13881" | "0x38" | "0x61" | "0xa86a" | "0xa869" | "0xfa" | "0x19" | "0x152" | "0x2a15c308d" | "0xa4B1";
    toBlock: string | undefined;
    toDate: string | undefined;
    pairAddress: string;
}, {
    reserve0?: string | undefined;
    reserve1?: string | undefined;
}, {
    reserve0?: string | undefined;
    reserve1?: string | undefined;
}> | _moralisweb3_common_core.Operation<GetTokenAllowanceRequest, {
    chain: "0x1" | "0x5" | "0xaa36a7" | "0x89" | "0x13881" | "0x38" | "0x61" | "0xa86a" | "0xa869" | "0xfa" | "0x19" | "0x152" | "0x2a15c308d" | "0xa4B1";
    ownerAddress: string;
    spenderAddress: string;
    address: string;
}, {
    allowance: _moralisweb3_common_core.BigNumber;
}, {
    allowance: string;
}> | _moralisweb3_common_core.Operation<GetTokenMetadataBySymbolRequest, {
    chain: "0x1" | "0x5" | "0xaa36a7" | "0x89" | "0x13881" | "0x38" | "0x61" | "0xa86a" | "0xa869" | "0xfa" | "0x19" | "0x152" | "0x2a15c308d" | "0xa4B1";
    symbols: string[];
}, {
    token: Erc20Token;
    blockNumber: string | undefined;
    validated: string | undefined;
}[], {
    address: string;
    name: string;
    symbol: string;
    decimals: string;
    logo?: string | undefined;
    logo_hash?: string | undefined;
    thumbnail?: string | undefined;
    block_number?: string | undefined;
    validated?: string | undefined;
}[]> | _moralisweb3_common_core.Operation<GetTokenMetadataRequest, {
    chain: "0x1" | "0x5" | "0xaa36a7" | "0x89" | "0x13881" | "0x38" | "0x61" | "0xa86a" | "0xa869" | "0xfa" | "0x19" | "0x152" | "0x2a15c308d" | "0xa4B1";
    addresses: string[];
}, {
    token: Erc20Token;
    blockNumber: string | undefined;
    validated: string | undefined;
}[], {
    address: string;
    name: string;
    symbol: string;
    decimals: string;
    logo?: string | undefined;
    logo_hash?: string | undefined;
    thumbnail?: string | undefined;
    block_number?: string | undefined;
    validated?: string | undefined;
}[]> | _moralisweb3_common_core.Operation<GetTokenPriceRequest, {
    chain: "0x1" | "0x5" | "0xaa36a7" | "0x89" | "0x13881" | "0x38" | "0x61" | "0xa86a" | "0xa869" | "0xfa" | "0x19" | "0x152" | "0x2a15c308d" | "0xa4B1";
    exchange: string | undefined;
    toBlock: number | undefined;
    address: string;
}, {
    nativePrice: EvmNative | null;
    exchangeAddress: EvmAddress | null;
    usdPrice: number;
    exchangeName?: string | undefined;
}, {
    nativePrice?: {
        value: string;
        decimals: number;
        name: string;
        symbol: string;
    } | undefined;
    usdPrice: number;
    exchangeAddress?: string | undefined;
    exchangeName?: string | undefined;
}> | _moralisweb3_common_core.PaginatedOperation<GetTokenTransfersRequest, {
    chain: "0x1" | "0x5" | "0xaa36a7" | "0x89" | "0x13881" | "0x38" | "0x61" | "0xa86a" | "0xa869" | "0xfa" | "0x19" | "0x152" | "0x2a15c308d" | "0xa4B1";
    fromBlock: number | undefined;
    toBlock: number | undefined;
    fromDate: _moralisweb3_common_core.DateInput | undefined;
    toDate: _moralisweb3_common_core.DateInput | undefined;
    limit: number | undefined;
    address: string;
    cursor: string | undefined;
    disableTotal: boolean | undefined;
}, Erc20Transfer[], {
    transaction_hash: string;
    address: string;
    block_timestamp: string;
    block_number: string;
    block_hash: string;
    to_address: string;
    from_address: string;
    value: string;
    transaction_index: number;
    log_index: number;
}[] | undefined> | _moralisweb3_common_core.Operation<GetTransactionRequest, {
    chain: "0x1" | "0x5" | "0xaa36a7" | "0x89" | "0x13881" | "0x38" | "0x61" | "0xa86a" | "0xa869" | "0xfa" | "0x19" | "0x152" | "0x2a15c308d" | "0xa4B1";
    transactionHash: string;
}, EvmTransaction, {
    hash: string;
    nonce: string;
    transaction_index: string;
    from_address: string;
    to_address: unknown;
    value: string;
    gas?: string | undefined;
    gas_price: string;
    input: string;
    receipt_cumulative_gas_used: string;
    receipt_gas_used: string;
    receipt_contract_address?: unknown;
    receipt_root?: unknown;
    receipt_status: string;
    block_timestamp: string;
    block_number: string;
    block_hash: string;
    logs?: {
        log_index: string;
        transaction_hash: string;
        transaction_index: string;
        address: string;
        data: string;
        topic0: string;
        topic1?: unknown;
        topic2?: unknown;
        topic3?: unknown;
        block_timestamp: string;
        block_number: string;
        block_hash: string;
    }[] | undefined;
}> | _moralisweb3_common_core.PaginatedOperation<GetWalletNFTCollectionsRequest, {
    chain: "0x1" | "0x5" | "0xaa36a7" | "0x89" | "0x13881" | "0x38" | "0x61" | "0xa86a" | "0xa869" | "0xfa" | "0x19" | "0x152" | "0x2a15c308d" | "0xa4B1";
    limit: number | undefined;
    cursor: string | undefined;
    address: string;
    disableTotal: boolean | undefined;
}, EvmNftCollection[], {
    token_address: string;
    contract_type: string;
    name: string;
    symbol: string;
}[] | undefined> | _moralisweb3_common_core.PaginatedOperation<GetWalletNFTsRequest, {
    chain: "0x1" | "0x5" | "0xaa36a7" | "0x89" | "0x13881" | "0x38" | "0x61" | "0xa86a" | "0xa869" | "0xfa" | "0x19" | "0x152" | "0x2a15c308d" | "0xa4B1";
    format: "decimal" | "hex" | undefined;
    limit: number | undefined;
    tokenAddresses: string[] | undefined;
    cursor: string | undefined;
    address: string;
    normalizeMetadata: boolean | undefined;
    disableTotal: boolean | undefined;
}, EvmNft[], {
    token_address: string;
    token_id: string;
    contract_type: string;
    owner_of: string;
    block_number: string;
    block_number_minted: string;
    token_uri?: string | undefined;
    metadata?: string | undefined;
    normalized_metadata?: {
        name?: string | undefined;
        description?: string | undefined;
        image?: string | undefined;
        external_link?: string | undefined;
        animation_url?: string | undefined;
        attributes?: {
            trait_type?: string | undefined;
            value?: {
                [key: string]: unknown;
            } | undefined;
            display_type?: string | undefined;
            max_value?: number | undefined;
            trait_count?: number | undefined;
            order?: number | undefined;
        }[] | undefined;
    } | undefined;
    amount?: string | undefined;
    name: string;
    symbol: string;
    token_hash: string;
    last_token_uri_sync: string;
    last_metadata_sync: string;
}[] | undefined> | _moralisweb3_common_core.PaginatedOperation<GetWalletNFTTransfersRequest, {
    chain: "0x1" | "0x5" | "0xaa36a7" | "0x89" | "0x13881" | "0x38" | "0x61" | "0xa86a" | "0xa869" | "0xfa" | "0x19" | "0x152" | "0x2a15c308d" | "0xa4B1";
    format: "decimal" | "hex" | undefined;
    direction: "from" | "to" | "both" | undefined;
    fromBlock: number | undefined;
    toBlock: string | undefined;
    limit: number | undefined;
    cursor: string | undefined;
    address: string;
    disableTotal: boolean | undefined;
}, EvmNftTransfer[], {
    token_address: string;
    token_id: string;
    from_address?: string | undefined;
    to_address: string;
    value?: string | undefined;
    amount?: string | undefined;
    contract_type: string;
    block_number: string;
    block_timestamp: string;
    block_hash: string;
    transaction_hash: string;
    transaction_type?: string | undefined;
    transaction_index?: number | undefined;
    log_index: number;
    operator?: string | undefined;
}[]> | _moralisweb3_common_core.Operation<GetWalletTokenBalancesRequest, {
    chain: "0x1" | "0x5" | "0xaa36a7" | "0x89" | "0x13881" | "0x38" | "0x61" | "0xa86a" | "0xa869" | "0xfa" | "0x19" | "0x152" | "0x2a15c308d" | "0xa4B1";
    tokenAddresses: string[] | undefined;
    address: string;
    toBlock: number | undefined;
}, Erc20Value[], {
    token_address: string;
    name: string;
    symbol: string;
    logo?: string | undefined;
    thumbnail?: string | undefined;
    decimals: number;
    balance: string;
}[]> | _moralisweb3_common_core.PaginatedOperation<GetWalletTransactionsRequest, {
    chain: "0x1" | "0x5" | "0xaa36a7" | "0x89" | "0x13881" | "0x38" | "0x61" | "0xa86a" | "0xa869" | "0xfa" | "0x19" | "0x152" | "0x2a15c308d" | "0xa4B1";
    fromBlock: number | undefined;
    toBlock: number | undefined;
    fromDate: _moralisweb3_common_core.DateInput | undefined;
    toDate: _moralisweb3_common_core.DateInput | undefined;
    cursor: string | undefined;
    limit: number | undefined;
    address: string;
    disableTotal: boolean | undefined;
}, EvmTransaction[], {
    hash: string;
    nonce: string;
    transaction_index: string;
    from_address: string;
    to_address: string;
    value: string;
    gas: string;
    gas_price: string;
    input: string;
    receipt_cumulative_gas_used: string;
    receipt_gas_used: string;
    receipt_contract_address: string;
    receipt_root: string;
    receipt_status: string;
    block_timestamp: string;
    block_number: string;
    block_hash: string;
}[] | undefined> | _moralisweb3_common_core.PaginatedOperation<GetWalletTransactionsVerboseRequest, {
    chain: "0x1" | "0x5" | "0xaa36a7" | "0x89" | "0x13881" | "0x38" | "0x61" | "0xa86a" | "0xa869" | "0xfa" | "0x19" | "0x152" | "0x2a15c308d" | "0xa4B1";
    fromBlock: number | undefined;
    toBlock: number | undefined;
    fromDate: _moralisweb3_common_core.DateInput | undefined;
    toDate: _moralisweb3_common_core.DateInput | undefined;
    cursor: string | undefined;
    limit: number | undefined;
    address: string;
    disableTotal: boolean | undefined;
}, EvmTransaction[], {
    hash: string;
    nonce: string;
    transaction_index: string;
    from_address: string;
    to_address: unknown;
    value: string;
    gas?: string | undefined;
    gas_price: string;
    input: string;
    receipt_cumulative_gas_used: string;
    receipt_gas_used: string;
    receipt_contract_address?: unknown;
    receipt_root?: unknown;
    receipt_status: string;
    block_timestamp: string;
    block_number: string;
    block_hash: string;
    logs?: {
        log_index: string;
        transaction_hash: string;
        transaction_index: string;
        address: string;
        data: string;
        topic0: string;
        topic1?: unknown;
        topic2?: unknown;
        topic3?: unknown;
        block_timestamp: string;
        block_number: string;
        block_hash: string;
    }[] | undefined;
}[] | undefined> | _moralisweb3_common_core.Operation<ResolveAddressRequest, {
    address: string | undefined;
}, {
    name: string;
}, {
    name: string;
}> | _moralisweb3_common_core.Operation<ResolveDomainRequest, {
    currency: "0x1" | "eth" | undefined;
    domain: string;
}, {
    address: EvmAddress;
}, {
    address: string;
}> | _moralisweb3_common_core.Operation<ReSyncMetadataRequest, {
    chain: "0x1" | "0x5" | "0xaa36a7" | "0x89" | "0x13881" | "0x38" | "0x61" | "0xa86a" | "0xa869" | "0xfa" | "0x19" | "0x152" | "0x2a15c308d" | "0xa4B1";
    flag: "metadata" | "uri" | undefined;
    mode: "async" | "sync" | undefined;
    address: string;
    tokenId: string;
}, {
    status: string;
}, {
    status: string;
}> | _moralisweb3_common_core.Operation<RunContractFunctionRequest, {
    address: string;
    chain: "0x1" | "0x5" | "0xaa36a7" | "0x89" | "0x13881" | "0x38" | "0x61" | "0xa86a" | "0xa869" | "0xfa" | "0x19" | "0x152" | "0x2a15c308d" | "0xa4B1";
    functionName: string;
    abi: unknown;
    params: {
        [key: string]: unknown;
    } | undefined;
}, string, string> | _moralisweb3_common_core.PaginatedOperation<SearchNFTsRequest, {
    chain: "0x1" | "0x5" | "0xaa36a7" | "0x89" | "0x13881" | "0x38" | "0x61" | "0xa86a" | "0xa869" | "0xfa" | "0x19" | "0x152" | "0x2a15c308d" | "0xa4B1";
    format: "decimal" | "hex" | undefined;
    q: string;
    filter: "name" | "description" | "attributes" | "global" | "name,description" | "name,attributes" | "description,attributes" | "name,description,attributes" | undefined;
    fromBlock: number | undefined;
    toBlock: number | undefined;
    fromDate: _moralisweb3_common_core.DateInput | undefined;
    toDate: _moralisweb3_common_core.DateInput | undefined;
    addresses: string[] | undefined;
    cursor: string | undefined;
    limit: number | undefined;
    disableTotal: boolean | undefined;
}, {
    token: EvmNft;
    tokenHash: string;
    blockNumberMinted: string;
    lastMetadataSync: Date | undefined;
    lastTokenUriSync: Date | undefined;
    batchId: string;
    frozen: number;
    frozenLogIndex: {
        [key: string]: unknown;
    } | undefined;
    imported: {
        [key: string]: unknown;
    } | undefined;
    isValid: number;
    openseaLookup: {
        [key: string]: unknown;
    } | undefined;
    resyncing: number;
    syncing: number;
    updatedAt: Date;
}[], {
    token_id: string;
    token_address: string;
    token_uri: string;
    metadata: string;
    is_valid: number;
    syncing: number;
    frozen: number;
    resyncing: number;
    contract_type: string;
    token_hash: string;
    batch_id: string;
    metadata_name: string;
    metadata_description: string;
    metadata_attributes: string;
    block_number_minted: string;
    opensea_lookup?: {
        [key: string]: unknown;
    } | undefined;
    minter_address: string;
    transaction_minted: string;
    frozen_log_index?: {
        [key: string]: unknown;
    } | undefined;
    imported?: {
        [key: string]: unknown;
    } | undefined;
    last_token_uri_sync: string;
    last_metadata_sync: string;
    createdAt: string;
    updatedAt: string;
}[] | undefined> | _moralisweb3_common_core.Operation<SyncNFTContractRequest, {
    chain: "0x1" | "0x5" | "0xaa36a7" | "0x89" | "0x13881" | "0x38" | "0x61" | "0xa86a" | "0xa869" | "0xfa" | "0x19" | "0x152" | "0x2a15c308d" | "0xa4B1";
    address: string;
}, {
    success: boolean;
}, unknown> | _moralisweb3_common_core.Operation<UploadFolderRequest, {
    abi: string;
}, {
    path: string;
}[], {
    path: string;
}[]> | _moralisweb3_common_core.Operation<Web3ApiVersionRequest, undefined, {
    version: string;
}, {
    version: string;
}>)[];

declare const CommonEvmUtilsConfig: {
    formatEvmChainId: ConfigKey<EvmChainIdFormat>;
    formatEvmAddress: ConfigKey<EvmAddressFormat>;
    defaultEvmApiChain: ConfigKey<EvmChainish>;
};

declare class CommonEvmUtilsConfigSetup {
    static register(config: Config): void;
}

export { CommonEvmUtils, CommonEvmUtilsConfig, CommonEvmUtilsConfigSetup, EndpointWeightsJSONRequest, EndpointWeightsJSONResponse, EndpointWeightsRequest, EndpointWeightsResponse, EndpointWeightsResponseAdapter, Erc20Data, Erc20Input, Erc20Options, Erc20Token, Erc20Tokenish, Erc20Transfer, Erc20TransferData, Erc20TransferInput, Erc20Transferish, Erc20Value, Erc20ValueData, Erc20ValueInputAmount, Erc20ValueInputDecimals, Erc20Valueish, EvmAbiItem, EvmAbiItemVariable, EvmAddress, EvmAddressInput, EvmAddressish, EvmBlock, EvmBlockData, EvmBlockDate, EvmBlockDateData, EvmBlockDateInput, EvmBlockDateish, EvmBlockInput, EvmBlockish, EvmChain, EvmChainFeature, EvmChainListDataEntry, EvmChainParser, EvmChainResolver, EvmChainish, EvmEvent, EvmEventData, EvmEventInput, EvmEventish, EvmNative, EvmNativeCurrency, EvmNativeUnit, EvmNativeish, EvmNft, EvmNftCollection, EvmNftCollectionData, EvmNftCollectionInput, EvmNftCollectionish, EvmNftData, EvmNftInput, EvmNftMetadata, EvmNftMetadataData, EvmNftMetadataInput, EvmNftMetadataish, EvmNftTrade, EvmNftTradeData, EvmNftTradeInput, EvmNftTradeish, EvmNftTransfer, EvmNftTransferData, EvmNftTransferInput, EvmNftTransferish, EvmNftish, EvmSignature, EvmSignatureInput, EvmSignatureInputRSV, EvmSignatureish, EvmSimpleBlock, EvmSimpleBlockData, EvmSimpleBlockInput, EvmSimpleBlockish, EvmTransaction, EvmTransactionData, EvmTransactionInput, EvmTransactionLog, EvmTransactionLogData, EvmTransactionLogInput, EvmTransactionLogish, EvmTransactionish, GetBlockJSONRequest, GetBlockJSONResponse, GetBlockRequest, GetBlockResponse, GetBlockResponseAdapter, GetContractEventsJSONRequest, GetContractEventsJSONResponse, GetContractEventsRequest, GetContractEventsResponse, GetContractEventsResponseAdapter, GetContractLogsJSONRequest, GetContractLogsJSONResponse, GetContractLogsRequest, GetContractLogsResponse, GetContractLogsResponseAdapter, GetContractNFTsJSONRequest, GetContractNFTsJSONResponse, GetContractNFTsRequest, GetContractNFTsResponse, GetContractNFTsResponseAdapter, GetDateToBlockJSONRequest, GetDateToBlockJSONResponse, GetDateToBlockRequest, GetDateToBlockResponse, GetDateToBlockResponseAdapter, GetMultipleNFTsJSONRequest, GetMultipleNFTsJSONResponse, GetMultipleNFTsRequest, GetMultipleNFTsResponse, GetMultipleNFTsResponseAdapter, GetNFTContractMetadataJSONRequest, GetNFTContractMetadataJSONResponse, GetNFTContractMetadataRequest, GetNFTContractMetadataResponse, GetNFTContractMetadataResponseAdapter, GetNFTContractTransfersJSONRequest, GetNFTContractTransfersJSONResponse, GetNFTContractTransfersRequest, GetNFTContractTransfersResponse, GetNFTContractTransfersResponseAdapter, GetNFTLowestPriceJSONRequest, GetNFTLowestPriceJSONResponse, GetNFTLowestPriceRequest, GetNFTLowestPriceResponse, GetNFTLowestPriceResponseAdapter, GetNFTMetadataJSONRequest, GetNFTMetadataJSONResponse, GetNFTMetadataRequest, GetNFTMetadataResponse, GetNFTMetadataResponseAdapter, GetNFTOwnersJSONRequest, GetNFTOwnersJSONResponse, GetNFTOwnersRequest, GetNFTOwnersResponse, GetNFTOwnersResponseAdapter, GetNFTTokenIdOwnersJSONRequest, GetNFTTokenIdOwnersJSONResponse, GetNFTTokenIdOwnersRequest, GetNFTTokenIdOwnersResponse, GetNFTTokenIdOwnersResponseAdapter, GetNFTTradesJSONRequest, GetNFTTradesJSONResponse, GetNFTTradesRequest, GetNFTTradesResponse, GetNFTTradesResponseAdapter, GetNFTTransfersByBlockJSONRequest, GetNFTTransfersByBlockJSONResponse, GetNFTTransfersByBlockRequest, GetNFTTransfersByBlockResponse, GetNFTTransfersByBlockResponseAdapter, GetNFTTransfersFromToBlockJSONRequest, GetNFTTransfersFromToBlockJSONResponse, GetNFTTransfersFromToBlockRequest, GetNFTTransfersFromToBlockResponse, GetNFTTransfersFromToBlockResponseAdapter, GetNFTTransfersJSONRequest, GetNFTTransfersJSONResponse, GetNFTTransfersRequest, GetNFTTransfersResponse, GetNFTTransfersResponseAdapter, GetNativeBalanceJSONRequest, GetNativeBalanceJSONResponse, GetNativeBalanceRequest, GetNativeBalanceResponse, GetNativeBalanceResponseAdapter, GetNativeBalancesForAddressesJSONRequest, GetNativeBalancesForAddressesJSONResponse, GetNativeBalancesForAddressesRequest, GetNativeBalancesForAddressesResponse, GetNativeBalancesForAddressesResponseAdapter, GetPairAddressJSONRequest, GetPairAddressJSONResponse, GetPairAddressRequest, GetPairAddressResponse, GetPairAddressResponseAdapter, GetPairReservesJSONRequest, GetPairReservesJSONResponse, GetPairReservesRequest, GetPairReservesResponse, GetPairReservesResponseAdapter, GetTokenAllowanceJSONRequest, GetTokenAllowanceJSONResponse, GetTokenAllowanceRequest, GetTokenAllowanceResponse, GetTokenAllowanceResponseAdapter, GetTokenMetadataBySymbolJSONRequest, GetTokenMetadataBySymbolJSONResponse, GetTokenMetadataBySymbolRequest, GetTokenMetadataBySymbolResponse, GetTokenMetadataBySymbolResponseAdapter, GetTokenMetadataJSONRequest, GetTokenMetadataJSONResponse, GetTokenMetadataRequest, GetTokenMetadataResponse, GetTokenMetadataResponseAdapter, GetTokenPriceJSONRequest, GetTokenPriceJSONResponse, GetTokenPriceRequest, GetTokenPriceResponse, GetTokenPriceResponseAdapter, GetTokenTransfersJSONRequest, GetTokenTransfersJSONResponse, GetTokenTransfersRequest, GetTokenTransfersResponse, GetTokenTransfersResponseAdapter, GetTransactionJSONRequest, GetTransactionJSONResponse, GetTransactionRequest, GetTransactionResponse, GetTransactionResponseAdapter, GetWalletNFTCollectionsJSONRequest, GetWalletNFTCollectionsJSONResponse, GetWalletNFTCollectionsRequest, GetWalletNFTCollectionsResponse, GetWalletNFTCollectionsResponseAdapter, GetWalletNFTTransfersJSONRequest, GetWalletNFTTransfersJSONResponse, GetWalletNFTTransfersRequest, GetWalletNFTTransfersResponse, GetWalletNFTTransfersResponseAdapter, GetWalletNFTsJSONRequest, GetWalletNFTsJSONResponse, GetWalletNFTsRequest, GetWalletNFTsResponse, GetWalletNFTsResponseAdapter, GetWalletTokenBalancesJSONRequest, GetWalletTokenBalancesJSONResponse, GetWalletTokenBalancesRequest, GetWalletTokenBalancesResponse, GetWalletTokenBalancesResponseAdapter, GetWalletTokenTransfersJSONRequest, GetWalletTokenTransfersJSONResponse, GetWalletTokenTransfersRequest, GetWalletTokenTransfersResponse, GetWalletTokenTransfersResponseAdapter, GetWalletTransactionsJSONRequest, GetWalletTransactionsJSONResponse, GetWalletTransactionsRequest, GetWalletTransactionsResponse, GetWalletTransactionsResponseAdapter, GetWalletTransactionsVerboseJSONRequest, GetWalletTransactionsVerboseJSONResponse, GetWalletTransactionsVerboseRequest, GetWalletTransactionsVerboseResponse, GetWalletTransactionsVerboseResponseAdapter, InputChainId, InputEvmNative, LogTopic, ReSyncMetadataJSONRequest, ReSyncMetadataJSONResponse, ReSyncMetadataRequest, ReSyncMetadataResponse, ReSyncMetadataResponseAdapter, ResolveAddressJSONRequest, ResolveAddressJSONResponse, ResolveAddressRequest, ResolveAddressResponse, ResolveAddressResponseAdapter, ResolveDomainJSONRequest, ResolveDomainJSONResponse, ResolveDomainRequest, ResolveDomainResponse, ResolveDomainResponseAdapter, RunContractFunctionJSONRequest, RunContractFunctionJSONResponse, RunContractFunctionRequest, RunContractFunctionResponse, RunContractFunctionResponseAdapter, SearchNFTsJSONRequest, SearchNFTsJSONResponse, SearchNFTsRequest, SearchNFTsResponse, SearchNFTsResponseAdapter, SyncNFTContractJSONRequest, SyncNFTContractJSONResponse, SyncNFTContractRequest, SyncNFTContractResponse, SyncNFTContractResponseAdapter, UploadFolderJSONRequest, UploadFolderJSONResponse, UploadFolderRequest, UploadFolderResponse, UploadFolderResponseAdapter, Web3ApiVersionJSONRequest, Web3ApiVersionJSONResponse, Web3ApiVersionRequest, Web3ApiVersionResponse, Web3ApiVersionResponseAdapter, endpointWeightsOperation, getBlockOperation, getContractEventsOperation, getContractLogsOperation, getContractNFTsOperation, getDateToBlockOperation, getMultipleNFTsOperation, getNFTContractMetadataOperation, getNFTContractTransfersOperation, getNFTLowestPriceOperation, getNFTMetadataOperation, getNFTOwnersOperation, getNFTTokenIdOwnersOperation, getNFTTradesOperation, getNFTTransfersByBlockOperation, getNFTTransfersFromToBlockOperation, getNFTTransfersOperation, getNativeBalanceOperation, getNativeBalancesForAddressesOperation, getPairAddressOperation, getPairReservesOperation, getTokenAllowanceOperation, getTokenMetadataBySymbolOperation, getTokenMetadataOperation, getTokenPriceOperation, getTokenTransfersOperation, getTransactionOperation, getWalletNFTCollectionsOperation, getWalletNFTTransfersOperation, getWalletNFTsOperation, getWalletTokenBalancesOperation, getWalletTokenTransfersOperation, getWalletTransactionsOperation, getWalletTransactionsVerboseOperation, operations, reSyncMetadataOperation, resolveAddressOperation, resolveDomainOperation, runContractFunctionOperation, searchNFTsOperation, syncNFTContractOperation, uploadFolderOperation, web3ApiVersionOperation };
